From d8251eb3e39890acd01fd7619382a3f47ed81160 Mon Sep 17 00:00:00 2001
From: Arnaud GRANAL <arnaud@geometry.ee>
Date: Wed, 22 Jan 2020 21:50:54 +0000
Subject: [PATCH] [Kiwi] Introduce extensions support - R80

---
 BUILD.gn                                                                                           |    2 
 apps/BUILD.gn                                                                                      |    2 
 chrome/BUILD.gn                                                                                    |    4 
 chrome/app/android/chrome_main_delegate_android.cc                                                 |    7 
 chrome/app/bookmarks_strings.grdp                                                                  |    6 
 chrome/app/chrome_main_delegate.cc                                                                 |   13 
 chrome/app/chromium_strings.grd                                                                    |   20 
 chrome/app/generated_resources.grd                                                                 |   77 
 chrome/app/google_chrome_strings.grd                                                               |   20 
 chrome/app/profiles_strings.grdp                                                                   |   11 
 chrome/app/theme/theme_resources.grd                                                               |   28 
 chrome/browser/BUILD.gn                                                                            |   41 
 chrome/browser/apps/platform_apps/BUILD.gn                                                         |    1 
 chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn                               |    1 
 chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc                   |  188 ++
 chrome/browser/background/background_contents_service_factory.cc                                   |    3 
 chrome/browser/background/background_mode_manager.cc                                               |    1 
 chrome/browser/background/background_mode_manager_android.cc                                       |   24 
 chrome/browser/browser_process_impl.cc                                                             |    4 
 chrome/browser/browser_resources.grd                                                               |   28 
 chrome/browser/chrome_browser_main.cc                                                              |   22 
 chrome/browser/chrome_browser_main_android.cc                                                      |    2 
 chrome/browser/chrome_browser_main_posix.cc                                                        |    2 
 chrome/browser/chrome_content_browser_client.cc                                                    |    9 
 chrome/browser/content_settings/cookie_settings_factory.cc                                         |    1 
 chrome/browser/content_settings/host_content_settings_map_factory.cc                               |    4 
 chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc                     |   28 
 chrome/browser/custom_handlers/register_protocol_handler_permission_request.h                      |    2 
 chrome/browser/devtools/BUILD.gn                                                                   |   10 
 chrome/browser/download/download_commands.cc                                                       |   17 
 chrome/browser/download/download_commands.h                                                        |    4 
 chrome/browser/download/download_crx_util_android.cc                                               |   23 
 chrome/browser/download/download_danger_prompt.cc                                                  |    5 
 chrome/browser/download/download_shelf_context_menu.cc                                             |   17 
 chrome/browser/download/download_ui_model.cc                                                       |    4 
 chrome/browser/download/download_ui_model.h                                                        |    4 
 chrome/browser/download/drag_download_item_android.cc                                              |   35 
 chrome/browser/download/drag_download_item_aura.cc                                                 |    2 
 chrome/browser/enterprise_reporting/policy_info.cc                                                 |    2 
 chrome/browser/extensions/BUILD.gn                                                                 |    9 
 chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc             |    5 
 chrome/browser/extensions/api/browsing_data/browsing_data_api.cc                                   |   17 
 chrome/browser/extensions/api/content_settings/content_settings_api.cc                             |    5 
 chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc |    7 
 chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc           |   19 
 chrome/browser/extensions/api/music_manager_private/device_id_android.cc                           |  184 ++
 chrome/browser/extensions/api/resources_private/resources_private_api.cc                           |    2 
 chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc          |    3 
 chrome/browser/extensions/api/tabs/windows_event_router.cc                                         |    2 
 chrome/browser/extensions/bookmark_app_helper.cc                                                   |  868 ++++++++++
 chrome/browser/extensions/chrome_extensions_browser_client.cc                                      |    7 
 chrome/browser/extensions/chrome_process_manager_delegate.cc                                       |    1 
 chrome/browser/extensions/extension_install_prompt.cc                                              |   64 
 chrome/browser/extensions/extension_install_prompt.h                                               |    4 
 chrome/browser/extensions/extension_install_prompt_show_params.cc                                  |    4 
 chrome/browser/extensions/extension_uninstall_dialog.cc                                            |    2 
 chrome/browser/extensions/global_shortcut_listener_android.cc                                      |   64 
 chrome/browser/extensions/global_shortcut_listener_android.h                                       |   36 
 chrome/browser/extensions/system_display/display_info_provider_android.cc                          |   17 
 chrome/browser/extensions/system_display/display_info_provider_android.h                           |   24 
 chrome/browser/first_run/first_run_dialog.h                                                        |    2 
 chrome/browser/first_run/upgrade_util.h                                                            |    4 
 chrome/browser/flag_descriptions.cc                                                                |    2 
 chrome/browser/flag_descriptions.h                                                                 |    2 
 chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc                   |    2 
 chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h                    |    4 
 chrome/browser/media/router/BUILD.gn                                                               |    2 
 chrome/browser/media/router/discovery/BUILD.gn                                                     |    4 
 chrome/browser/media/router/media_router.h                                                         |    4 
 chrome/browser/media/router/media_router_base.cc                                                   |    2 
 chrome/browser/media/router/media_router_base.h                                                    |    4 
 chrome/browser/media/router/media_router_feature.cc                                                |    6 
 chrome/browser/media/router/media_router_feature.h                                                 |    2 
 chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc                                    |    7 
 chrome/browser/metrics/chrome_feature_list_creator.cc                                              |    6 
 chrome/browser/notifications/notification_display_service_impl.cc                                  |   18 
 chrome/browser/obsolete_system/obsolete_system_android.cc                                          |   25 
 chrome/browser/permissions/attestation_permission_request.cc                                       |   12 
 chrome/browser/platform_util.cc                                                                    |   42 
 chrome/browser/platform_util_android.cc                                                            |    4 
 chrome/browser/plugins/plugins_resource_service.cc                                                 |    2 
 chrome/browser/policy/browser_dm_token_storage_android.cc                                          |  191 ++
 chrome/browser/policy/browser_dm_token_storage_android.h                                           |   58 
 chrome/browser/policy/chrome_browser_policy_connector.cc                                           |    2 
 chrome/browser/policy/configuration_policy_handler_list_factory.cc                                 |    2 
 chrome/browser/prefs/browser_prefs.cc                                                              |   28 
 chrome/browser/prefs/chrome_pref_service_factory.cc                                                |    2 
 chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc                                |   64 
 chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h                                 |    2 
 chrome/browser/profiles/off_the_record_profile_impl.cc                                             |   11 
 chrome/browser/profiles/off_the_record_profile_impl.h                                              |   10 
 chrome/browser/profiles/profile.cc                                                                 |    4 
 chrome/browser/profiles/profile.h                                                                  |    6 
 chrome/browser/profiles/profile_impl.cc                                                            |   11 
 chrome/browser/profiles/profile_impl.h                                                             |    6 
 chrome/browser/profiles/profile_manager.cc                                                         |    8 
 chrome/browser/profiles/profile_manager.h                                                          |    6 
 chrome/browser/profiles/profile_metrics.cc                                                         |    8 
 chrome/browser/profiles/profile_metrics.h                                                          |    2 
 chrome/browser/profiles/profile_window.cc                                                          |    4 
 chrome/browser/profiles/profile_window.h                                                           |    4 
 chrome/browser/profiles/profiles_state.cc                                                          |    4 
 chrome/browser/profiles/profiles_state.h                                                           |    2 
 chrome/browser/renderer_context_menu/render_view_context_menu.cc                                   |   12 
 chrome/browser/renderer_context_menu/render_view_context_menu.h                                    |    2 
 chrome/browser/resource_coordinator/resource_coordinator_parts.cc                                  |    4 
 chrome/browser/resource_coordinator/resource_coordinator_parts.h                                   |   12 
 chrome/browser/resource_coordinator/tab_helper.cc                                                  |    4 
 chrome/browser/resource_coordinator/tab_helper.h                                                   |    4 
 chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc                               |    3 
 chrome/browser/resources/BUILD.gn                                                                  |    6 
 chrome/browser/resources/md_extensions/extensions.html                                             |   47 
 chrome/browser/resources/unpack_pak.py                                                             |    4 
 chrome/browser/search/instant_service.h                                                            |    4 
 chrome/browser/search/instant_service_factory.h                                                    |    4 
 chrome/browser/search/instant_service_observer.h                                                   |    4 
 chrome/browser/search/local_ntp_source.h                                                           |    4 
 chrome/browser/search/most_visited_iframe_source.h                                                 |    4 
 chrome/browser/sharing/click_to_call/feature.cc                                                    |    2 
 chrome/browser/sharing/click_to_call/feature.h                                                     |    2 
 chrome/browser/sharing/shared_clipboard/feature_flags.cc                                           |    2 
 chrome/browser/sharing/shared_clipboard/feature_flags.h                                            |    2 
 chrome/browser/signin/account_consistency_mode_manager.cc                                          |    6 
 chrome/browser/signin/chrome_signin_helper.cc                                                      |    2 
 chrome/browser/startup_data.cc                                                                     |   25 
 chrome/browser/supervised_user/supervised_user_service.cc                                          |    2 
 chrome/browser/sync/profile_sync_service_factory.cc                                                |   10 
 chrome/browser/ui/BUILD.gn                                                                         |   53 
 chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc                                              |    9 
 chrome/browser/ui/browser.cc                                                                       |    5 
 chrome/browser/ui/browser.h                                                                        |    2 
 chrome/browser/ui/browser_command_controller.cc                                                    |    4 
 chrome/browser/ui/browser_commands.cc                                                              |    1 
 chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc                                 |    2 
 chrome/browser/ui/browser_instant_controller.h                                                     |    4 
 chrome/browser/ui/browser_list.cc                                                                  |    3 
 chrome/browser/ui/browser_navigator_params.cc                                                      |    4 
 chrome/browser/ui/browser_navigator_params.h                                                       |    6 
 chrome/browser/ui/browser_otr_state.cc                                                             |    4 
 chrome/browser/ui/browser_ui_prefs.cc                                                              |    2 
 chrome/browser/ui/browser_window.h                                                                 |    4 
 chrome/browser/ui/chrome_pages.cc                                                                  |    4 
 chrome/browser/ui/chrome_pages.h                                                                   |    4 
 chrome/browser/ui/content_settings/content_setting_bubble_model.cc                                 |    3 
 chrome/browser/ui/content_settings/content_setting_bubble_model.h                                  |    2 
 chrome/browser/ui/fast_unload_controller.cc                                                        |  487 +++++
 chrome/browser/ui/native_window_tracker_android.cc                                                 |   26 
 chrome/browser/ui/native_window_tracker_android.h                                                  |   26 
 chrome/browser/ui/page_info/page_info_ui.cc                                                        |   10 
 chrome/browser/ui/page_info/page_info_ui.h                                                         |    4 
 chrome/browser/ui/passwords/settings/password_manager_presenter.cc                                 |    4 
 chrome/browser/ui/screen_capture_notification_ui_stub.cc                                           |    2 
 chrome/browser/ui/search/instant_controller.h                                                      |    4 
 chrome/browser/ui/search/ntp_user_data_logger.h                                                    |    4 
 chrome/browser/ui/search/search_ipc_router.h                                                       |    4 
 chrome/browser/ui/search/search_ipc_router_policy_impl.h                                           |    4 
 chrome/browser/ui/search/search_tab_helper.h                                                       |    4 
 chrome/browser/ui/signin_view_controller.h                                                         |    2 
 chrome/browser/ui/tab_helpers.cc                                                                   |    2 
 chrome/browser/ui/tabs/tab_strip_model.cc                                                          |    4 
 chrome/browser/ui/tabs/tab_strip_model.h                                                           |    4 
 chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc                                     |   59 
 chrome/browser/ui/unload_controller.cc                                                             |   35 
 chrome/browser/ui/views/BUILD.gn                                                                   |    2 
 chrome/browser/ui/views/accelerator_utils_android.cc                                               |   30 
 chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc                               |   10 
 chrome/browser/ui/views/browser_dialogs_views.cc                                                   |   11 
 chrome/browser/ui/views/chrome_views_delegate_android.cc                                           |   15 
 chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc                                 |    2 
 chrome/browser/ui/views/dropdown_bar_host_android.cc                                               |   10 
 chrome/browser/ui/views/find_bar_host.cc                                                           |    4 
 chrome/browser/ui/views/frame/browser_frame.cc                                                     |    1 
 chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc                       |    1 
 chrome/browser/ui/views/frame/browser_root_view.cc                                                 |    7 
 chrome/browser/ui/views/frame/browser_view.cc                                                      |   27 
 chrome/browser/ui/views/frame/browser_window_factory.cc                                            |   10 
 chrome/browser/ui/views/frame/desktop_browser_frame_android.cc                                     |   75 
 chrome/browser/ui/views/frame/desktop_browser_frame_android.h                                      |   63 
 chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc                              |   13 
 chrome/browser/ui/views/javascript_dialog_views.cc                                                 |    2 
 chrome/browser/ui/views/location_bar/location_bar_view.cc                                          |   27 
 chrome/browser/ui/views/location_bar/location_bar_view.h                                           |    2 
 chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc                                     |    2 
 chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc                         |    2 
 chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc                                |    2 
 chrome/browser/ui/views/profiles/avatar_button.cc                                                  |  559 ++++++
 chrome/browser/ui/views/profiles/profile_menu_view.cc                                              |    2 
 chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc                  |    2 
 chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc                       |    8 
 chrome/browser/ui/views/tabs/tab_strip.cc                                                          |   12 
 chrome/browser/ui/views/tabs/window_finder_android.cc                                              |   15 
 chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc                                        |    2 
 chrome/browser/ui/webui/discards/BUILD.gn                                                          |    2 
 chrome/browser/ui/webui/media_router/media_router_ui.cc                                            |  716 ++++++++
 chrome/browser/ui/webui/settings/change_password_handler.cc                                        |    3 
 chrome/browser/ui/webui/signin/inline_login_handler_impl.cc                                        |    4 
 chrome/browser/ui/window_sizer/window_sizer_android.cc                                             |   17 
 chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc                                                  |   31 
 chrome/browser/web_applications/BUILD.gn                                                           |    5 
 chrome/browser/web_applications/components/BUILD.gn                                                |    3 
 chrome/browser/web_applications/components/web_app_shortcut_android.cc                             |  122 +
 chrome/browser/web_applications/components/web_app_shortcut_android.h                              |   62 
 chrome/browser/web_applications/extensions/BUILD.gn                                                |    3 
 chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc                           |   10 
 chrome/browser/web_applications/web_app_android.cc                                                 |   44 
 chrome/chrome_paks.gni                                                                             |    2 
 chrome/common/BUILD.gn                                                                             |    3 
 chrome/common/chrome_features.cc                                                                   |   15 
 chrome/common/chrome_features.h                                                                    |    8 
 chrome/common/chrome_paths.cc                                                                      |    2 
 chrome/common/chrome_paths.h                                                                       |    2 
 chrome/common/chrome_switches.cc                                                                   |    2 
 chrome/common/chrome_switches.h                                                                    |    2 
 chrome/common/extensions/api/api_sources.gni                                                       |    2 
 chrome/common/features.gni                                                                         |    4 
 chrome/common/pref_names.cc                                                                        |   26 
 chrome/common/pref_names.h                                                                         |   26 
 chrome/common/url_constants.h                                                                      |    4 
 chrome/common/webui_url_constants.cc                                                               |    4 
 chrome/common/webui_url_constants.h                                                                |    4 
 chrome/renderer/chrome_content_renderer_client.cc                                                  |    2 
 chrome/renderer/media/chrome_key_systems.cc                                                        |    2 
 chrome/test/BUILD.gn                                                                               |    2 
 chromecast/browser/cast_browser_context.cc                                                         |    2 
 chromecast/browser/cast_browser_context.h                                                          |    2 
 components/autofill_payments_strings.grdp                                                          |   12 
 components/autofill_strings.grdp                                                                   |    2 
 components/bookmarks/browser/BUILD.gn                                                              |    2 
 components/bookmarks/browser/bookmark_node_data.h                                                  |    8 
 components/components_strings.grd                                                                  |    4 
 components/content_settings/core/browser/cookie_settings.cc                                        |    1 
 components/feature_engagement/public/event_constants.cc                                            |    4 
 components/feature_engagement/public/event_constants.h                                             |    4 
 components/feature_engagement/public/feature_constants.cc                                          |    2 
 components/feature_engagement/public/feature_constants.h                                           |    2 
 components/guest_view/browser/BUILD.gn                                                             |    2 
 components/guest_view/renderer/BUILD.gn                                                            |    2 
 components/history_strings.grdp                                                                    |    2 
 components/keep_alive_registry/BUILD.gn                                                            |    2 
 components/new_or_sad_tab_strings.grdp                                                             |    2 
 components/page_info_strings.grdp                                                                  |    8 
 components/payments/content/payment_request.cc                                                     |    2 
 components/payments/content/payment_request.h                                                      |    2 
 components/payments_strings.grdp                                                                   |    2 
 components/pdf_strings.grdp                                                                        |    2 
 components/policy/core/browser/configuration_policy_handler.cc                                     |    1 
 components/policy/resources/policy_templates.json                                                  |   10 
 components/prefs/pref_service.cc                                                                   |    4 
 components/search/search.cc                                                                        |    4 
 components/signin/features.gni                                                                     |    2 
 components/sync_ui_strings.grdp                                                                    |    2 
 components/ui_devtools/views/BUILD.gn                                                              |    7 
 components/ui_devtools/views/dom_agent_android.cc                                                  |   44 
 components/ui_devtools/views/dom_agent_android.h                                                   |   32 
 components/ui_devtools/views/overlay_agent_android.cc                                              |   44 
 components/ui_devtools/views/overlay_agent_android.h                                               |   36 
 components/ui_devtools/views/overlay_agent_views.cc                                                |    4 
 components/url_formatter/elide_url.cc                                                              |    4 
 components/url_formatter/elide_url.h                                                               |    2 
 components/web_modal/BUILD.gn                                                                      |    2 
 components/zoom/BUILD.gn                                                                           |    2 
 content/app/content_main_runner_impl.cc                                                            |   23 
 content/app/content_service_manager_main_delegate.cc                                               |    2 
 content/browser/BUILD.gn                                                                           |   12 
 content/browser/browser_main.cc                                                                    |    4 
 content/browser/browser_main_loop.cc                                                               |   24 
 content/browser/browser_main_runner_impl.cc                                                        |    3 
 content/browser/devtools/BUILD.gn                                                                  |    2 
 content/browser/frame_host/navigation_controller_impl.cc                                           |    4 
 content/browser/frame_host/navigation_request.cc                                                   |    2 
 content/browser/renderer_host/pepper/pepper_truetype_font_android.cc                               |   78 
 content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc                          |   20 
 content/browser/renderer_host/render_view_host_impl.cc                                             |    4 
 content/browser/storage_partition_impl.cc                                                          |    5 
 content/browser/storage_partition_impl.h                                                           |    6 
 content/browser/web_contents/web_contents_impl.cc                                                  |    8 
 content/browser/web_contents/web_contents_impl.h                                                   |    6 
 content/browser/webui/shared_resources_data_source.cc                                              |    6 
 content/public/browser/browser_context.h                                                           |    4 
 content/public/browser/content_browser_client.cc                                                   |    2 
 content/public/browser/content_browser_client.h                                                    |    2 
 content/public/browser/desktop_media_id.cc                                                         |    4 
 content/public/browser/desktop_media_id.h                                                          |    2 
 content/public/browser/storage_partition.h                                                         |    4 
 content/public/common/pepper_plugin_info.h                                                         |    2 
 content/shell/BUILD.gn                                                                             |    2 
 content/shell/browser/shell_browser_context.cc                                                     |    2 
 content/shell/browser/shell_browser_context.h                                                      |    4 
 extensions/BUILD.gn                                                                                |   34 
 extensions/browser/api/api_resource_manager.h                                                      |    8 
 extensions/browser/api/messaging/message_service.cc                                                |    2 
 extensions/browser/api/socket/tcp_socket.cc                                                        |  104 -
 extensions/browser/api/socket/tcp_socket.h                                                         |    2 
 extensions/browser/api/system_cpu/BUILD.gn                                                         |    1 
 extensions/browser/api/system_cpu/cpu_info_provider_android.cc                                     |   77 
 extensions/browser/extensions_browser_client.cc                                                    |    1 
 extensions/browser/guest_view/web_view/web_view_guest.cc                                           |    1 
 extensions/buildflags/buildflags.gni                                                               |    2 
 mojo/public/js/mojo_bindings_resources.grd                                                         |    2 
 services/device/public/cpp/hid/BUILD.gn                                                            |    2 
 services/service_manager/embedder/main.cc                                                          |   27 
 services/tracing/public/cpp/trace_startup.cc                                                       |    4 
 third_party/blink/public/mojom/BUILD.gn                                                            |    2 
 ui/android/window_android.h                                                                        |    8 
 ui/base/BUILD.gn                                                                                   |   17 
 ui/base/cursor/cursor.cc                                                                           |    2 
 ui/base/dragdrop/os_exchange_data.cc                                                               |    4 
 ui/base/dragdrop/os_exchange_data.h                                                                |    8 
 ui/base/dragdrop/os_exchange_data_provider_android.cc                                              |  220 ++
 ui/base/dragdrop/os_exchange_data_provider_android.h                                               |  101 +
 ui/base/dragdrop/os_exchange_data_provider_factory.cc                                              |    4 
 ui/events/event.h                                                                                  |    1 
 ui/gfx/BUILD.gn                                                                                    |    7 
 ui/message_center/BUILD.gn                                                                         |    4 
 ui/native_theme/native_theme_android.cc                                                            |    3 
 ui/native_theme/native_theme_android.h                                                             |    2 
 ui/resources/BUILD.gn                                                                              |    4 
 ui/resources/ui_resources.grd                                                                      |    8 
 ui/views/BUILD.gn                                                                                  |   16 
 ui/views/controls/menu/menu_config_android.cc                                                      |   13 
 ui/views/controls/menu/menu_controller.cc                                                          |   69 
 ui/views/controls/menu/menu_host.cc                                                                |   42 
 ui/views/controls/menu/menu_host.h                                                                 |    5 
 ui/views/controls/native/native_view_host_android.cc                                               |  121 +
 ui/views/controls/native/native_view_host_android.h                                                |   98 +
 ui/views/controls/webview/unhandled_keyboard_event_handler.cc                                      |    3 
 ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc                              |    2 
 ui/views/controls/webview/web_dialog_view.cc                                                       |    6 
 ui/views/event_monitor_android.cc                                                                  |   65 
 ui/views/event_monitor_android.h                                                                   |   37 
 ui/views/metrics_android.cc                                                                        |   36 
 ui/views/native_cursor_android.cc                                                                  |   31 
 ui/views/view.cc                                                                                   |    2 
 ui/views/views_touch_selection_controller_factory_android.cc                                       |   22 
 ui/views/views_touch_selection_controller_factory_aura.cc                                          |    2 
 ui/views/widget/native_widget_android.cc                                                           |  491 +++++
 ui/views/widget/native_widget_android.h                                                            |  192 ++
 ui/views/widget/widget.cc                                                                          |  113 -
 ui/webui/resources/css/roboto.css                                                                  |    2 
 ui/webui/resources/webui_resources.grd                                                             |    6 
 340 files changed, 6907 insertions(+), 1270 deletions(-)
 create mode 100644 chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
 create mode 100644 chrome/browser/background/background_mode_manager_android.cc
 delete mode 100644 chrome/browser/download/download_crx_util_android.cc
 create mode 100644 chrome/browser/download/drag_download_item_android.cc
 create mode 100644 chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
 create mode 100644 chrome/browser/extensions/api/music_manager_private/device_id_android.cc
 create mode 100644 chrome/browser/extensions/bookmark_app_helper.cc
 create mode 100644 chrome/browser/extensions/global_shortcut_listener_android.cc
 create mode 100644 chrome/browser/extensions/global_shortcut_listener_android.h
 create mode 100644 chrome/browser/extensions/system_display/display_info_provider_android.cc
 create mode 100644 chrome/browser/extensions/system_display/display_info_provider_android.h
 create mode 100644 chrome/browser/obsolete_system/obsolete_system_android.cc
 create mode 100644 chrome/browser/policy/browser_dm_token_storage_android.cc
 create mode 100644 chrome/browser/policy/browser_dm_token_storage_android.h
 create mode 100644 chrome/browser/resources/md_extensions/extensions.html
 create mode 100644 chrome/browser/ui/fast_unload_controller.cc
 create mode 100644 chrome/browser/ui/native_window_tracker_android.cc
 create mode 100644 chrome/browser/ui/native_window_tracker_android.h
 create mode 100644 chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
 create mode 100644 chrome/browser/ui/views/accelerator_utils_android.cc
 create mode 100644 chrome/browser/ui/views/chrome_views_delegate_android.cc
 create mode 100644 chrome/browser/ui/views/dropdown_bar_host_android.cc
 create mode 100644 chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
 create mode 100644 chrome/browser/ui/views/frame/desktop_browser_frame_android.h
 create mode 100644 chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
 create mode 100644 chrome/browser/ui/views/profiles/avatar_button.cc
 create mode 100644 chrome/browser/ui/views/tabs/window_finder_android.cc
 create mode 100644 chrome/browser/ui/webui/media_router/media_router_ui.cc
 create mode 100644 chrome/browser/ui/window_sizer/window_sizer_android.cc
 create mode 100644 chrome/browser/web_applications/components/web_app_shortcut_android.cc
 create mode 100644 chrome/browser/web_applications/components/web_app_shortcut_android.h
 create mode 100644 chrome/browser/web_applications/web_app_android.cc
 create mode 100644 components/ui_devtools/views/dom_agent_android.cc
 create mode 100644 components/ui_devtools/views/dom_agent_android.h
 create mode 100644 components/ui_devtools/views/overlay_agent_android.cc
 create mode 100644 components/ui_devtools/views/overlay_agent_android.h
 create mode 100644 content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
 create mode 100644 content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
 create mode 100644 extensions/browser/api/system_cpu/cpu_info_provider_android.cc
 create mode 100644 ui/base/dragdrop/os_exchange_data_provider_android.cc
 create mode 100644 ui/base/dragdrop/os_exchange_data_provider_android.h
 create mode 100644 ui/views/controls/menu/menu_config_android.cc
 create mode 100644 ui/views/controls/native/native_view_host_android.cc
 create mode 100644 ui/views/controls/native/native_view_host_android.h
 create mode 100644 ui/views/event_monitor_android.cc
 create mode 100644 ui/views/event_monitor_android.h
 create mode 100644 ui/views/metrics_android.cc
 create mode 100644 ui/views/native_cursor_android.cc
 create mode 100644 ui/views/views_touch_selection_controller_factory_android.cc
 create mode 100644 ui/views/widget/native_widget_android.cc
 create mode 100644 ui/views/widget/native_widget_android.h

--- a/BUILD.gn
+++ b/BUILD.gn
@@ -245,7 +245,7 @@ group("gn_all") {
 
   deps += root_extra_deps
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     deps += [
       "//extensions:extensions_browsertests",
       "//extensions:extensions_unittests",
--- a/apps/BUILD.gn
+++ b/apps/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/config/features.gni")
 import("//build/config/ui.gni")
 import("//extensions/buildflags/buildflags.gni")
 
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 assert(enable_extensions,
        "Cannot depend on extensions because enable_extensions=false.")
 
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -1410,7 +1410,7 @@ group("extra_resources") {
     "//components/autofill/core/browser:autofill_address_rewriter_resources",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     public_deps += [
       "//chrome/browser/resources:bookmarks_resources",
       "//chrome/browser/resources:component_extension_resources",
@@ -1436,7 +1436,7 @@ group("extra_resources") {
     ]
   }
 
-  if (!is_android && !is_chromeos) {
+  if (true || (!is_android && !is_chromeos)) {
     public_deps += [ "//chrome/browser/resources:welcome_resources" ]
   }
 
--- a/chrome/app/android/chrome_main_delegate_android.cc
+++ b/chrome/app/android/chrome_main_delegate_android.cc
@@ -73,26 +73,33 @@ void ChromeMainDelegateAndroid::SecureDa
 int ChromeMainDelegateAndroid::RunProcess(
     const std::string& process_type,
     const content::MainFunctionParams& main_function_params) {
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 1";
   TRACE_EVENT0("startup", "ChromeMainDelegateAndroid::RunProcess");
   // Defer to the default main method outside the browser process.
   if (!process_type.empty())
     return -1;
 
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 2";
   SecureDataDirectory();
 
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 3";
   // Because the browser process can be started asynchronously as a series of
   // UI thread tasks a second request to start it can come in while the
   // first request is still being processed. Chrome must keep the same
   // browser runner for the second request.
   // Also only record the start time the first time round, since this is the
   // start time of the application, and will be same for all requests.
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 4";
   if (!browser_runner_) {
     startup_metric_utils::RecordMainEntryPointTime(
         chrome::android::GetMainEntryPointTimeTicks());
     browser_runner_ = content::BrowserMainRunner::Create();
+    LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 5";
   }
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 6";
 
   int exit_code = browser_runner_->Initialize(main_function_params);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 7";
   // On Android we do not run BrowserMain(), so the above initialization of a
   // BrowserMainRunner is all we want to occur. Return >= 0 to avoid running
   // BrowserMain, while preserving any error codes > 0.
--- a/chrome/app/bookmarks_strings.grdp
+++ b/chrome/app/bookmarks_strings.grdp
@@ -2,7 +2,7 @@
 <!-- Bookmarks specific strings (included from generated_resources.grd). -->
 <grit-part>
   <!-- Begin of Bookmarks Bar strings-->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- The special folders created when importing from other other browsers. -->
     <if expr="is_win">
       <message name="IDS_BOOKMARK_GROUP_FROM_IE" desc="The group name of bookmarks from Internet Explorer">
@@ -100,7 +100,7 @@
     <message name="IDS_BOOKMARK_BAR_NEW_FOLDER" desc="Menu title for adding a new folder">
       Add &amp;folder...
     </message>
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SHOW_BOOKMARK_BAR" desc="The toggle to show the bookmark bar">
         &amp;Show bookmarks bar
       </message>
@@ -152,7 +152,7 @@
     <message name="IDS_BOOKMARK_BAR_NEW_FOLDER" desc="In Title Case: Menu title for adding a new folder">
       Add &amp;Folder...
     </message>
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SHOW_BOOKMARK_BAR" desc="In Title Case: The toggle to show the bookmark bar">
         &amp;Show Bookmarks Bar
       </message>
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -520,10 +520,13 @@ ChromeMainDelegate::~ChromeMainDelegate(
 
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
 void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 1";
+
   // Chrome disallows cookies by default. All code paths that want to use
   // cookies need to go through one of Chrome's URLRequestContexts which have
   // a ChromeNetworkDelegate attached that selectively allows cookies again.
   net::URLRequest::SetDefaultCookiePolicyToBlock();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 2";
 
 #if defined(OS_CHROMEOS)
   // The feature list depends on BrowserPolicyConnectorChromeOS which depends
@@ -531,18 +534,24 @@ void ChromeMainDelegate::PostEarlyInitia
   // list, so initialize them separately later at the end of this function.
   chromeos::InitializeDBus();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 3";
 
   DCHECK(startup_data_);
   auto* chrome_feature_list_creator =
       startup_data_->chrome_feature_list_creator();
   chrome_feature_list_creator->CreateFeatureList();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 4";
   PostFieldTrialInitialization();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 5";
 
   // Initializes the resource bundle and determines the locale.
   std::string actual_locale =
       LoadLocalState(chrome_feature_list_creator, is_running_tests);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 6";
   chrome_feature_list_creator->SetApplicationLocale(actual_locale);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 7";
   chrome_feature_list_creator->OverrideCachedUIStrings();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8";
 
 #if defined(OS_CHROMEOS)
   // Initialize D-Bus clients that depend on feature list.
@@ -550,10 +559,13 @@ void ChromeMainDelegate::PostEarlyInitia
 #endif
 
 #if defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8a";
   startup_data_->CreateProfilePrefService();
   net::NetworkChangeNotifier::SetFactory(
       new net::NetworkChangeNotifierFactoryAndroid());
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8b";
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 9";
 
   if (base::FeatureList::IsEnabled(
           features::kWriteBasicSystemProfileToPersistentHistogramsFile)) {
@@ -565,6 +577,7 @@ void ChromeMainDelegate::PostEarlyInitia
     if (record)
       startup_data_->RecordCoreSystemProfile();
   }
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 10";
 }
 
 bool ChromeMainDelegate::ShouldCreateFeatureList() {
--- a/chrome/app/chromium_strings.grd
+++ b/chrome/app/chromium_strings.grd
@@ -178,7 +178,7 @@ If you update this file, be sure also to
   <release seq="1" allow_pseudo="false">
     <messages fallback_to_english="true">
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_chromium_strings.grdp" />
       </if>
 
@@ -636,7 +636,7 @@ Chromium is unable to recover your setti
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chromium data to this account?
         </message>
@@ -649,7 +649,7 @@ Chromium is unable to recover your setti
       </if>
 
       <!-- about:browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
           Your system administrator has configured Chromium to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
@@ -764,7 +764,7 @@ Chromium is unable to recover your setti
       </if>
 
       <!-- Material Design User Manager -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
           This person's browsing data will be deleted from this device. To recover the data, sign in to Chromium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
@@ -841,7 +841,7 @@ Chromium is unable to recover your setti
         </message>
       </if>
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
           If an image doesnt have a useful description, Chromium will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
@@ -926,7 +926,7 @@ Chromium is unable to recover your setti
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
           Update Chromium to start sync
         </message>
@@ -1014,7 +1014,7 @@ Chromium is unable to recover your setti
       </if>
 
       <!-- Welcome page (chrome://welcome) strings -->
-      <if expr="not chromeos and not is_android">
+      <if expr="is_android or not chromeos and not is_android">
         <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chromium before.">
           Welcome to Chromium
         </message>
@@ -1027,7 +1027,7 @@ Chromium is unable to recover your setti
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not chromeos">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
@@ -1071,7 +1071,7 @@ Chromium is unable to recover your setti
         </if>
       </if>
       <!-- Chromium launch blocking dialog. -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
          <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chromium launch blocking dialog for machine level user cloud policy enrollment.">
           Launching Chromium...
         </message>
@@ -1086,7 +1086,7 @@ Chromium is unable to recover your setti
         Share a Chromium tab
       </message>
       <!-- User happiness tracking survey UI -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
           Help us improve Chromium
         </message>
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -290,7 +290,7 @@ are declared in tools/grit/grit_rule.gni
       </if>
 
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_strings.grdp" />
       </if>
 
@@ -300,7 +300,7 @@ are declared in tools/grit/grit_rule.gni
       </if>
 
       <!-- Welcome strings -->
-      <if expr="not chromeos and not is_android">
+      <if expr="is_android or not chromeos and not is_android">
         <part file="welcome_strings.grdp" />
       </if>
 
@@ -448,7 +448,7 @@ are declared in tools/grit/grit_rule.gni
         Disable
       </message>
       <!-- Search strings are only used in webui, so no mobile. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SEARCH_CLEARED" desc="Message announced to screenreader users when search is cleared.">
           Search cleared
         </message>
@@ -476,7 +476,7 @@ are declared in tools/grit/grit_rule.gni
       </if>
 
        <!-- content area context menus. Android does not use it -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_INSPECTELEMENT" desc="The name of the Inspect Element command in the content area context menu">
           I&amp;nspect
         </message>
@@ -976,7 +976,7 @@ are declared in tools/grit/grit_rule.gni
       </if>
 
       <!-- Page menu. Android has separate strings for its menu -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_NEW_TAB" desc="The text label of a menu item for opening a new tab">
             New &amp;tab
@@ -1992,7 +1992,7 @@ are declared in tools/grit/grit_rule.gni
       </message>
 
       <!-- Download Context Menu Items -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <if expr="is_macosx">
             <message name="IDS_DOWNLOAD_MENU_SHOW"
@@ -2245,7 +2245,7 @@ are declared in tools/grit/grit_rule.gni
       </if>
 
       <!-- Desktop omnibox PWA install icon -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_OMNIBOX_PWA_INSTALL_ICON_LABEL" desc="String for the omnibox icon label promoting an app installation">
           Install
         </message>
@@ -2732,7 +2732,7 @@ are declared in tools/grit/grit_rule.gni
       </message>
 
       <!-- Win certificate selector dialog strings.  -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_CERT_SELECTOR_SUBJECT_COLUMN" desc="The text of the header for the certificate subject column in the certificate selector dialog.">
           Subject
         </message>
@@ -3357,7 +3357,7 @@ are declared in tools/grit/grit_rule.gni
       </message>
 
       <!-- Task Manager Window -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_TASK_MANAGER_KILL" desc="The caption of the Task Manager kill button">
             End process
@@ -3630,7 +3630,7 @@ are declared in tools/grit/grit_rule.gni
       <message name="IDS_UTILITY_PROCESS_FILE_UTILITY_NAME" desc="The name of the utility process used for various Chrome specific file operations.">
           Chrome File Utilities
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_UTILITY_PROCESS_PROFILE_IMPORTER_NAME" desc="The name of the utility process used for importing profiles.">
           Profile Importer
         </message>
@@ -5047,7 +5047,7 @@ Keep your key file in a safe place. You
       </message>
 
       <!-- Pepper Broker Infobar -->
-      <if expr="enable_plugins">
+      <if expr="is_android or enable_plugins">
         <message name="IDS_PEPPER_BROKER_MESSAGE" desc="Message shown when a pepper plugin wants to launch its broker. This message is followed by a 'Learn more' link.">
           <ph name="PEPPER_PLUGIN_NAME">$1<ex>Flash</ex></ph> on <ph name="PEPPER_PLUGIN_DOMAIN">$2<ex>example.com</ex></ph> wants to access your computer
         </message>
@@ -5110,7 +5110,7 @@ Keep your key file in a safe place. You
       </message>
 
       <!-- about:system strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_ABOUT_SYS_TITLE" desc="about:system page title">
           About System
         </message>
@@ -5141,7 +5141,7 @@ Keep your key file in a safe place. You
       </if>
 
       <!-- chrome://browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_TITLE" desc="about:browser-switch page title">
           Legacy Browser Support
         </message>
@@ -5616,7 +5616,7 @@ Keep your key file in a safe place. You
       </message>
 
       <!-- Strings for intent picker -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_TOOLTIP_INTENT_PICKER_ICON" desc="The tooltip for the intent picker bubble icon">
           To open this link, choose an app
         </message>
@@ -5872,20 +5872,7 @@ the Bookmarks menu.">
           No thanks
         </message>
       </if>
-      <if expr="not is_android">
-        <message name="IDS_PASSWORD_MANAGER_SAVE_BUTTON" desc="Save button text for password manager">
-          Save
-        </message>
-        <if expr="use_titlecase">
-          <message name="IDS_PASSWORD_MANAGER_UPDATE_BUTTON" desc="In Title Case: Update button text for password manager">
-            Update Password
-          </message>
-        </if>
-        <if expr="not use_titlecase">
-          <message name="IDS_PASSWORD_MANAGER_UPDATE_BUTTON" desc="Update button text for password manager">
-            Update password
-          </message>
-        </if>
+      <if expr="is_android or not is_android">
         <message name="IDS_PASSWORD_MANAGER_BUBBLE_BLACKLIST_BUTTON" desc="Button text for the 'Save Password' bubble's 'Never remember for this site' option">
           Never
         </message>
@@ -5939,7 +5926,7 @@ the Bookmarks menu.">
       </if>
 
       <!-- Android uses custom UI for Bookmark importing -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Import Settings Dialog -->
         <if expr="is_win">
           <message name="IDS_IMPORT_FROM_IE" desc="browser combo box: Microsoft Internet Explorer">
@@ -6719,7 +6706,7 @@ the Bookmarks menu.">
       <!-- Settings related strings not specific to chrome://settings.
            (Settings specific strings are in settings_strings.grdp).
            Android uses native UI for settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_TOOLBAR_INFORM_SET_HOME_PAGE" desc="The confirmation message when dropping a link on the Home toolbar button">
            Your home page has been set.
         </message>
@@ -6932,7 +6919,7 @@ the Bookmarks menu.">
           Generate QR code for this Image
         </message>
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_OMNIBOX_QRCODE_GENERATOR_ICON_LABEL" desc="String for the omnibox icon label for the QR code Generator">
           QR code
         </message>
@@ -7101,7 +7088,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Accessiblility strings for Infobars in Views -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ACCNAME_INFOBAR_CONTAINER" desc="The accessible name for the infobar container.">
           Infobar Container
         </message>
@@ -7162,7 +7149,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Managed UI on pages like chrome://settings and chrome://downloads -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="chromeos">
           <message name="IDS_DEVICE_MANAGED_WITH_HYPERLINK" desc="Message to end users in Enterprise/EDU, with a link for more info (ChromeOS)">
             Your <ph name="BEGIN_LINK">&lt;a target="_blank" href="$1"&gt;</ph><ph name="DEVICE_TYPE">$2<ex>Chromebook</ex></ph> is managed<ph name="END_LINK">&lt;/a&gt;</ph> by your organization
@@ -7311,7 +7298,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Strings used for non-Android builds -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_APP_DEFAULT_PAGE_NAME"
                  desc="Default name for the first 'Apps' page on the New Tab Page.">
           Apps
@@ -7959,7 +7946,7 @@ Please help our engineers fix this probl
       </if>
 
       <!-- Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Sync options dialog strings -->
         <if expr="not chromeos">
           <message name="IDS_SYNC_OVERVIEW" desc="The message that appears in the options dialog when sync has not been set up by the user.">
@@ -8068,7 +8055,7 @@ Please help our engineers fix this probl
       </if>
 
       <!-- Translate Bubble -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_TRANSLATE_BUBBLE_BEFORE_TRANSLATE_TITLE" desc="Title text for the translate bubble when asking to translate a page.">
           Translate this page?
         </message>
@@ -9255,7 +9242,7 @@ Please help our engineers fix this probl
       </message>
 
       <!-- Media Galleries. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_MEDIA_GALLERIES_DIALOG_HEADER" desc="Header for media gallery permissions dialog.">
           Media-File Permissions for "<ph name="EXTENSION">$1<ex>Photo Editor</ex></ph>"
         </message>
@@ -9788,7 +9775,7 @@ Please help our engineers fix this probl
       </message>
     </if>
 
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <!-- Device Chooser Prompt -->
       <message name="IDS_BLUETOOTH_DEVICE_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce Bluetooth chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.9oo91e.qjz9zk</ex></ph> wants to pair
@@ -9901,7 +9888,7 @@ Please help our engineers fix this probl
     </message>
 
     <!-- Serial port chooser -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SERIAL_PORT_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce serial port chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.9oo91e.qjz9zk</ex></ph> wants to connect to a serial port
       </message>
@@ -9920,7 +9907,7 @@ Please help our engineers fix this probl
     </if>
 
     <!-- HID (Human Interface Device) chooser -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_HID_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce the Human Interface Device (HID) chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.9oo91e.qjz9zk</ex></ph> wants to connect to a HID device
       </message>
@@ -9981,7 +9968,7 @@ Please help our engineers fix this probl
     </if>
 
     <!-- Framebust / Blocked Redirection intervention message -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <!-- Android strings are declared in android_chrome_strings.grd. -->
       <message name="IDS_REDIRECT_BLOCKED_MESSAGE" desc="The message stating that a redirect (noun) was blocked on this page. This will be followed on a separate line with the address the user was being redirected to.">
         Redirect blocked:
@@ -10087,7 +10074,7 @@ Please help our engineers fix this probl
     </if>
 
     <!-- Download open confirmation dialog -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_DOWNLOAD_OPEN_CONFIRMATION_DIALOG_TITLE" desc="Title of the dialog prompt shown to users when an extension is trying to open a downloaded file.">
         Open download
       </message>
@@ -10209,7 +10196,7 @@ Please help our engineers fix this probl
     </message>
 
     <!-- Relaunch notification bubble and dialog. -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <if expr="not chromeos">
         <message name="IDS_RELAUNCH_ACCEPT_BUTTON" desc="The text in the accept button of a dialog that causes the browser to be relaunched immediately.">
           Relaunch now
@@ -10226,7 +10213,7 @@ Please help our engineers fix this probl
     </if>
 
     <!-- Web-modal dialog shown during Web Authenticaton API requests. -->
-    <if expr="is_win or is_macosx or desktop_linux or chromeos">
+    <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
       <message name="IDS_WEBAUTHN_GENERIC_TITLE" desc="Title of most dialogs shown while the user is authenticating on a web site using a security key.">
         Use your security key with <ph name="APP_NAME">$1<ex>9oo91e.qjz9zk</ex></ph>
       </message>
@@ -10516,7 +10503,7 @@ Please help our engineers fix this probl
     </message>
 
     <!-- User happiness tracking survey UI -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <if expr="use_titlecase">
         <message name="IDS_HATS_BUBBLE_OK_LABEL" translateable="false" desc="Button label on Happiness Tracking Survey's invitation banner, clicking the button gives the user's consent on taking the survey.">
           Take Survey
--- a/chrome/app/google_chrome_strings.grd
+++ b/chrome/app/google_chrome_strings.grd
@@ -180,7 +180,7 @@ chromium_strings.grd. -->
   <release seq="1" allow_pseudo="false">
     <messages fallback_to_english="true">
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_google_chrome_strings.grdp" />
       </if>
 
@@ -648,7 +648,7 @@ Google Chrome is unable to recover your
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chrome data to this account?
         </message>
@@ -661,7 +661,7 @@ Google Chrome is unable to recover your
       </if>
 
       <!-- about:browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
           Your system administrator has configured Google Chrome to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
@@ -776,7 +776,7 @@ Google Chrome is unable to recover your
       </if>
 
       <!-- Material Design User Manager -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
           This person's browsing data will be deleted from this device. To recover the data, sign in to Chrome as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
@@ -860,7 +860,7 @@ Google Chrome is unable to recover your
       </if>
 
       <!-- content area context menus. Android does not use it -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
           If an image doesnt have a useful description, Chrome will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
@@ -945,7 +945,7 @@ Google Chrome is unable to recover your
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
           Update Chrome to start sync
         </message>
@@ -1033,7 +1033,7 @@ Google Chrome is unable to recover your
       </if>
 
       <!-- Welcome page (chrome://welcome) strings -->
-      <if expr="not chromeos">
+      <if expr="is_android or not chromeos">
         <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chrome before.">
           Welcome to Chrome
         </message>
@@ -1046,7 +1046,7 @@ Google Chrome is unable to recover your
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not chromeos">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
@@ -1091,7 +1091,7 @@ Google Chrome is unable to recover your
       </if>
 
       <!-- Chrome launch blocking dialog. -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chrome launch blocking dialog for machine level user cloud policy enrollment.">
           Launching Chrome...
         </message>
@@ -1107,7 +1107,7 @@ Google Chrome is unable to recover your
       </message>
 
       <!-- User happiness tracking survey UI -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
           Take a quick survey
         </message>
--- a/chrome/app/profiles_strings.grdp
+++ b/chrome/app/profiles_strings.grdp
@@ -444,18 +444,13 @@
     <message name="IDS_SYNC_USER_NAME_IN_USE_ERROR" desc="Mobile: An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile.">
       This account is already being used on this device.
     </message>
-  </if>
-  <if expr="not is_android">
-    <message name="IDS_SYNC_USER_NAME_IN_USE_ERROR" desc="An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile.">
-      This account is already being used on this computer.
-    </message>
     <message name="IDS_SYNC_USER_NAME_IN_USE_BY_ERROR" desc="An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile. This error message includes the avatar name of the existing duplicate profile and only appears in the signin error tab modal dialog.">
-      This account is already being used on this computer by <ph name="AVATAR_NAME">$1<ex>Jane</ex></ph>.
+      This account is already being used on this device by <ph name="AVATAR_NAME">$1<ex>Jane</ex></ph>.
     </message>
   </if>
 
   <!-- Android does not support multiple profiles and supervised users -->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- Create Profile Dialog -->
     <message name="IDS_PROFILES_CREATE_TITLE" desc="Title of the create profile dialog">
       Add person
@@ -488,7 +483,7 @@
     </message>
   </if>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- User manager web UI -->
     <if expr="use_titlecase">
       <message name="IDS_ADD_USER_BUTTON" desc="Text shown on an add user button on login/locker screen">
--- a/chrome/app/theme/theme_resources.grd
+++ b/chrome/app/theme/theme_resources.grd
@@ -25,10 +25,10 @@
       <!-- KEEP THESE IN ALPHABETICAL ORDER!  DO NOT ADD TO RANDOM PLACES JUST
            BECAUSE YOUR RESOURCES ARE FUNCTIONALLY RELATED OR FALL UNDER THE
            SAME CONDITIONALS. -->
-      <if expr="is_linux or is_win or chromeos">
+      <if expr="is_android or is_linux or is_win or chromeos">
         <structure type="chrome_scaled_image" name="IDR_ACCESSIBILITY_CAPTIONS_PREVIEW_BACKGROUND" file="common/captions-preview-bg.png" />
       </if>
-      <if expr="toolkit_views and not is_macosx">
+      <if expr="is_android or toolkit_views and not is_macosx">
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE" file="common/app_window_close.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_H" file="common/app_window_close_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_P" file="common/app_window_close_active.png" />
@@ -70,7 +70,7 @@
       <if expr="is_win">
         <structure type="chrome_scaled_image" name="IDR_BOOKMARK_BAR_FOLDER_MANAGED" file="win/bookmark_bar_folder_managed.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_BOOKMARK_BAR_APPS_SHORTCUT" file="common/apps_bookmark_bar_icon.png" />
         <structure type="chrome_scaled_image" name="IDR_BOOKMARKS_FAVICON" file="common/favicon_bookmarks.png" />
       </if>
@@ -78,7 +78,7 @@
         <structure type="chrome_scaled_image" name="IDR_BUTTON_USER_IMAGE_CHOOSE_FILE" file="cros/choose_file.png" />
         <structure type="chrome_scaled_image" name="IDR_BUTTON_USER_IMAGE_TAKE_PHOTO" file="cros/take_photo.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
       <!-- Note: Tab close buttons are not traditional buttons.  Tab close buttons
            fill a background with a color from the theme and tile IDR_CLOSE_1 over it.
            See chrome/browser/ui/views/tabs/tab.cc -->
@@ -94,7 +94,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_DEVICE_DISABLED" file="cros/device_disabled.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_DOWNLOADS_FAVICON" file="common/favicon_downloads.png" />
         <structure type="chrome_scaled_image" name="IDR_ERROR_NETWORK_OFFLINE" file="common/error_network_offline.png" />
       </if>
@@ -132,7 +132,7 @@
       <if expr="_google_chrome">
         <structure type="chrome_scaled_image" name="IDR_GOOGLE_ICON" file="google_chrome/google_icon.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_HELP_MENU" file="common/help_16.png" />
         <structure type="chrome_scaled_image" name="IDR_HIDE_PASSWORD_HOVER" file="common/hide_password_hover.png" />
         <if expr="not chromeos">
@@ -148,7 +148,7 @@
       <if expr="enable_service_discovery">
         <structure type="chrome_scaled_image" name="IDR_LOCAL_DISCOVERY_CLOUDPRINT_ICON" file="common/cloudprint.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_MANAGEMENT_FAVICON" file="common/favicon_management.png" />
         <structure type="chrome_scaled_image" name="IDR_MAXIMIZE_BUTTON_MASK" file="common/maximize_button_mask.png" />
         <structure type="chrome_scaled_image" name="IDR_MINIMIZE_BUTTON_MASK" file="common/minimize_button_mask.png" />
@@ -159,7 +159,7 @@
         <structure type="chrome_scaled_image" name="IDR_NOTIFICATION_EASYUNLOCK_ENABLED" file="cros/notification_easyunlock_enabled.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_PLUGINS_FAVICON" file="common/favicon_extensions.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_PRERENDER" file="common/prerender_succeed_icon.png" />
       </if>
       <if expr="not _google_chrome">
@@ -242,14 +242,14 @@
         <structure type="chrome_scaled_image" name="IDR_PROFILE_AVATAR_55" file="common/modern_avatars/abstract/avatar_sandwich.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_PROFILE_AVATAR_PLACEHOLDER_LARGE" file="common/profile_avatar_placeholder_large.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_PROFILES_DICE_TURN_ON_SYNC" file="common/turn_on_sync_illustration.png" />
       </if>
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_RESET_WARNING" file="cros/reset_warning.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_RESTORE_BUTTON_MASK" file="common/restore_button_mask.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_LOOKALIKE_ILLUSTRATION_DARK" file="common/safety_tip_lookalike_illustration_dark.png" />
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_LOOKALIKE_ILLUSTRATION_LIGHT" file="common/safety_tip_lookalike_illustration_light.png" />
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_SUSPICIOUS_ILLUSTRATION_DARK" file="common/safety_tip_suspicious_illustration_dark.png" />
@@ -265,7 +265,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_SECONDARY_USER_SETTINGS" file="cros/secondary_user_settings.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_SETTINGS_FAVICON" file="common/favicon_settings.png" />
         <structure type="chrome_scaled_image" name="IDR_SHOW_PASSWORD_HOVER" file="common/show_password_hover.png" />
       </if>
@@ -287,7 +287,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_TAB_RECORDING_INDICATOR" file="cros/tab_recording_indicator.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_COOKIE_BLOCKING_ON_HEADER" file="common/cookie_blocking_on_header.png" />
         <structure type="chrome_scaled_image" name="IDR_COOKIE_BLOCKING_OFF_HEADER" file="common/cookie_blocking_off_header.png" />
       </if>
@@ -341,7 +341,7 @@
         <structure type="chrome_scaled_image" name="IDR_PASTE_VIOLATION_DARK" file="common/paste_violation_dark.png" />
       </if>
       <if expr="not _google_chrome">
-        <if expr="not is_android">
+        <if expr="is_android or not is_android">
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON" file="chromium/webstore_icon.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_16" file="chromium/webstore_icon_16.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_24" file="chromium/webstore_icon_24.png" />
@@ -349,7 +349,7 @@
         </if>
       </if>
       <if expr="_google_chrome">
-        <if expr="not is_android">
+        <if expr="is_android or not is_android">
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON" file="google_chrome/webstore_icon.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_16" file="google_chrome/webstore_icon_16.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_24" file="google_chrome/webstore_icon_24.png" />
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -170,10 +170,6 @@ jumbo_static_library("browser") {
     "bitmap_fetcher/bitmap_fetcher_service.h",
     "bitmap_fetcher/bitmap_fetcher_service_factory.cc",
     "bitmap_fetcher/bitmap_fetcher_service_factory.h",
-    "bluetooth/bluetooth_chooser_context.cc",
-    "bluetooth/bluetooth_chooser_context.h",
-    "bluetooth/bluetooth_chooser_context_factory.cc",
-    "bluetooth/bluetooth_chooser_context_factory.h",
     "bookmarks/bookmark_model_factory.cc",
     "bookmarks/bookmark_model_factory.h",
     "bookmarks/chrome_bookmark_client.cc",
@@ -415,7 +411,6 @@ jumbo_static_library("browser") {
     "download/download_core_service_factory.h",
     "download/download_core_service_impl.cc",
     "download/download_core_service_impl.h",
-    "download/download_crx_util_android.cc",
     "download/download_file_picker.cc",
     "download/download_file_picker.h",
     "download/download_history.cc",
@@ -1206,6 +1201,8 @@ jumbo_static_library("browser") {
     "plugins/pdf_plugin_placeholder_observer.h",
     "policy/browser_dm_token_storage.cc",
     "policy/browser_dm_token_storage.h",
+    "policy/browser_dm_token_storage_android.cc",
+    "policy/browser_dm_token_storage_android.h",
     "policy/browser_dm_token_storage_linux.cc",
     "policy/browser_dm_token_storage_linux.h",
     "policy/browser_dm_token_storage_mac.h",
@@ -1565,7 +1562,6 @@ jumbo_static_library("browser") {
     "sessions/session_common_utils.h",
     "sessions/session_data_deleter.cc",
     "sessions/session_data_deleter.h",
-    "sessions/session_restore_android.cc",
     "sessions/session_tab_helper_factory.cc",
     "sessions/session_tab_helper_factory.h",
     "sessions/tab_restore_service_factory.cc",
@@ -3026,7 +3022,8 @@ jumbo_static_library("browser") {
       ]
       deps += [ "//chrome/android/modules/dev_ui/provider:native" ]
     }
-  } else {  # !is_android
+  }
+  if (true) {  # !is_android
     sources += [
       "accessibility/invert_bubble_prefs.cc",
       "accessibility/invert_bubble_prefs.h",
@@ -3074,8 +3071,6 @@ jumbo_static_library("browser") {
       "badging/badge_manager_delegate.h",
       "badging/badge_manager_factory.cc",
       "badging/badge_manager_factory.h",
-      "banners/app_banner_manager_desktop.cc",
-      "banners/app_banner_manager_desktop.h",
       "bookmarks/bookmark_html_writer.cc",
       "bookmarks/bookmark_html_writer.h",
       "certificate_viewer.h",
@@ -3301,7 +3296,6 @@ jumbo_static_library("browser") {
       "metrics/desktop_session_duration/desktop_session_duration_tracker.h",
       "metrics/first_web_contents_profiler.cc",
       "metrics/first_web_contents_profiler.h",
-      "metrics/incognito_observer_desktop.cc",
       "metrics/tab_stats_data_store.cc",
       "metrics/tab_stats_data_store.h",
       "metrics/tab_stats_tracker.cc",
@@ -3314,6 +3308,7 @@ jumbo_static_library("browser") {
       "notifications/profile_notification.cc",
       "notifications/profile_notification.h",
       "obsolete_system/obsolete_system.h",
+      "obsolete_system/obsolete_system_android.cc",
       "obsolete_system/obsolete_system_linux.cc",
       "obsolete_system/obsolete_system_mac.cc",
       "obsolete_system/obsolete_system_win.cc",
@@ -3748,7 +3743,7 @@ jumbo_static_library("browser") {
         "chrome_browser_main_posix.h",
         "first_run/first_run_internal_posix.cc",
         "importer/firefox_profile_lock_posix.cc",
-        "process_singleton_posix.cc",
+#        "process_singleton_posix.cc",
         "task_manager/sampling/shared_sampler_posix.cc",
       ]
     }
@@ -4216,7 +4211,7 @@ jumbo_static_library("browser") {
     defines += [ "USE_CRAS" ]
   }
 
-  if (!is_android && !is_chromeos) {
+  if (true || (!is_android && !is_chromeos)) {
     sources += [
       "first_run/upgrade_util.cc",
       "first_run/upgrade_util.h",
@@ -4238,14 +4233,6 @@ jumbo_static_library("browser") {
       "notifications/screen_lock_notification_blocker.cc",
       "notifications/screen_lock_notification_blocker.h",
       "platform_util.cc",
-      "policy/chrome_browser_cloud_management_controller.cc",
-      "policy/chrome_browser_cloud_management_controller.h",
-      "policy/chrome_browser_cloud_management_register_watcher.cc",
-      "policy/chrome_browser_cloud_management_register_watcher.h",
-      "policy/cloud/chrome_browser_cloud_management_helper.cc",
-      "policy/cloud/chrome_browser_cloud_management_helper.h",
-      "policy/cloud/user_policy_signin_service.cc",
-      "policy/cloud/user_policy_signin_service.h",
       "policy/cloud/user_policy_signin_service_internal.h",
       "profiles/avatar_menu.cc",
       "profiles/avatar_menu.h",
@@ -4275,7 +4262,8 @@ jumbo_static_library("browser") {
       "upgrade_detector/upgrade_detector_impl.cc",
       "upgrade_detector/upgrade_detector_impl.h",
     ]
-  } else {
+  }
+  if (true) {
     sources += [
       "media/protected_media_identifier_permission_context.cc",
       "media/protected_media_identifier_permission_context.h",
@@ -4338,6 +4326,10 @@ jumbo_static_library("browser") {
     deps += [ "//ui/views" ]
   }
 
+  sources += [
+    "download/drag_download_item_android.cc",
+  ]
+
   if (use_aura) {
     # Cross-platform Aura files.
     sources += [
@@ -4370,6 +4362,7 @@ jumbo_static_library("browser") {
       "background/background_application_list_model.h",
       "background/background_mode_manager.cc",
       "background/background_mode_manager.h",
+      "background/background_mode_manager_android.cc",
       "background/background_mode_manager_aura.cc",
       "background/background_mode_manager_chromeos.cc",
       "background/background_mode_manager_mac.mm",
@@ -5141,7 +5134,7 @@ jumbo_static_library("browser") {
     }
   }
 
-  if (enable_session_service) {
+  if (true || enable_session_service) {
     sources += [
       "sessions/session_restore.cc",
       "sessions/session_restore.h",
@@ -5490,7 +5483,7 @@ grit("resources") {
     }
   }
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
     deps += [
       "//chrome/browser/resources/discards:discards_resources_gen",
       "//chrome/browser/resources/management:polymer3_elements",
@@ -5521,7 +5514,7 @@ grit("resources") {
     ]
   }
 
-  if (is_chromeos && optimize_webui) {
+  if (false && optimize_webui) {
     deps += [
       "//chrome/browser/resources/chromeos/bluetooth_pairing_dialog:build",
       "//chrome/browser/resources/chromeos/internet_config_dialog:build",
--- a/chrome/browser/apps/platform_apps/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/BUILD.gn
@@ -47,7 +47,6 @@ source_set("platform_apps") {
   deps = [
     "//chrome/app:command_ids",
     "//chrome/browser/extensions",
-    "//chrome/browser/media/router/discovery",
     "//chrome/browser/web_applications/extensions",
     "//chrome/common",
     "//components/crx_file",
--- a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
@@ -13,6 +13,7 @@ source_set("music_manager_private") {
     "device_id.cc",
     "device_id.h",
     "device_id_chromeos.cc",
+    "device_id_android.cc",
     "device_id_linux.cc",
     "device_id_mac.cc",
     "device_id_win.cc",
--- /dev/null
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,188 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/apps/platform_apps/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace chrome_apps {
+namespace api {
+
+namespace {
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+    "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < base::size(kDeviceNames); i++) {
+    DiskEntries::iterator it = disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin(); it != disk_uuids.end();
+         ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value()
+                 << ", uuid=" << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {}
+
+  bool ProcessInterface(struct ifaddrs* ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  int rv = -1;
+  if (rv < 0) {
+    PLOG(ERROR) << "getifaddrs failed " << rv;
+    return "";
+  }
+
+  MacAddressProcessor processor(is_valid_mac_address);
+  return processor.mac_address();
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+                 base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTask(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace chrome_apps
--- a/chrome/browser/background/background_contents_service_factory.cc
+++ b/chrome/browser/background/background_contents_service_factory.cc
@@ -32,8 +32,10 @@ BackgroundContentsServiceFactory::Backgr
     : BrowserContextKeyedServiceFactory(
           "BackgroundContentsService",
           BrowserContextDependencyManager::GetInstance()) {
+#if 0
   DependsOn(extensions::ExtensionRegistryFactory::GetInstance());
   DependsOn(extensions::ExtensionSystemFactory::GetInstance());
+#endif
 }
 
 BackgroundContentsServiceFactory::~BackgroundContentsServiceFactory() {}
@@ -46,6 +48,7 @@ KeyedService* BackgroundContentsServiceF
 
 void BackgroundContentsServiceFactory::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* user_prefs) {
+  LOG(ERROR) << "[Kiwi] BackgroundContentsServiceFactory::RegisterProfilePrefs";
   user_prefs->RegisterDictionaryPref(prefs::kRegisteredBackgroundContents);
 }
 
--- a/chrome/browser/background/background_mode_manager.cc
+++ b/chrome/browser/background/background_mode_manager.cc
@@ -564,7 +564,6 @@ void BackgroundModeManager::ExecuteComma
     case IDC_EXIT:
       RecordMenuItemClick(MENU_ITEM_EXIT);
       base::RecordAction(UserMetricsAction("Exit"));
-      chrome::CloseAllBrowsers();
       break;
     case IDC_STATUS_TRAY_KEEP_CHROME_RUNNING_IN_BACKGROUND: {
       // Background mode must already be enabled (as otherwise this menu would
--- /dev/null
+++ b/chrome/browser/background/background_mode_manager_android.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/background/background_mode_manager.h"
+
+#include "base/sequenced_task_runner.h"
+
+// No background jobs for aura for now.
+
+void BackgroundModeManager::EnableLaunchOnStartup(bool should_launch) {
+  NOTIMPLEMENTED();
+}
+
+void BackgroundModeManager::DisplayClientInstalledNotification(
+    const base::string16& name) {
+  NOTIMPLEMENTED();
+}
+
+// static
+scoped_refptr<base::SequencedTaskRunner>
+BackgroundModeManager::CreateTaskRunner() {
+  return nullptr;
+}
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -237,6 +237,7 @@ BrowserProcessImpl::BrowserProcessImpl(S
 }
 
 void BrowserProcessImpl::Init() {
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 1";
 #if defined(OS_CHROMEOS)
   // Forces creation of |metrics_services_manager_client_| if neccessary
   // (typically this call is a no-op as MetricsServicesManager has already been
@@ -265,13 +266,16 @@ void BrowserProcessImpl::Init() {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::AppWindowClient::Set(ChromeAppWindowClient::GetInstance());
 
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 2";
   extension_event_router_forwarder_ =
       base::MakeRefCounted<extensions::EventRouterForwarder>();
 
   EnsureExtensionsClientInitialized();
 
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 3";
   extensions_browser_client_ =
       std::make_unique<extensions::ChromeExtensionsBrowserClient>();
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 4: " << extensions_browser_client_;
   extensions_browser_client_->AddAPIProvider(
       std::make_unique<chrome_apps::ChromeAppsBrowserAPIProvider>());
   extensions::ExtensionsBrowserClient::Set(extensions_browser_client_.get());
--- a/chrome/browser/browser_resources.grd
+++ b/chrome/browser/browser_resources.grd
@@ -8,11 +8,11 @@
   </outputs>
   <release seq="1">
     <structures>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <structure name="IDR_SIGNIN_SHARED_CSS_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_shared_css.js" use_base_dir="false" preprocess="true" type="chrome_html" />
         <structure name="IDR_SIGNIN_SHARED_OLD_CSS_HTML" file="resources\signin\signin_shared_old_css.html" preprocess="true" allowexternalscript="true" type="chrome_html" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- New Tab Page WebUI. -->
         <structure name="IDR_INCOGNITO_TAB_HTML" file="resources\ntp4\incognito_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_INCOGNITO_TAB_THEME_CSS" file="resources\ntp4\incognito_tab_theme.css" compress="gzip" flattenhtml="true" type="chrome_html" />
@@ -41,7 +41,7 @@
       </if>
     </structures>
     <includes>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <include name="IDR_DISCARDS_MOJO_API_JS" file="resources\discards\mojo_api.js" compress="gzip" type="BINDATA" />
         <include name="IDR_DISCARDS_DATABASE_TAB_JS" file="${root_gen_dir}\chrome\browser\resources\discards\database_tab.js" use_base_dir="false" compress="gzip" type="BINDATA" />
         <include name="IDR_DISCARDS_DISCARDS_MAIN_JS" file="${root_gen_dir}\chrome\browser\resources\discards\discards_main.js" use_base_dir="false" compress="gzip" type="BINDATA" />
@@ -54,7 +54,7 @@
         <include name="IDR_DISCARDS_MOJO_PUBLIC_BASE_PROCESS_ID_MOJOM_LITE_JS" file="${root_gen_dir}\mojo\public\mojom\base\process_id.mojom-lite.js" compress="gzip" use_base_dir="false" type="BINDATA" />
         <include name="IDR_DISCARDS_SORTED_TABLE_BEHAVIOR_JS" file="resources\discards\sorted_table_behavior.js" compress="gzip" type="BINDATA" />
       </if>
-      <if expr="is_win or is_macosx or (is_linux and not chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not chromeos)">
         <include name="IDR_BROWSER_SWITCH_APP_JS" file="${root_gen_dir}\chrome\browser\resources\browser_switch\app.js" compress="gzip" use_base_dir="false" type="BINDATA" />
         <include name="IDR_BROWSER_SWITCH_PROXY_JS" file="resources\browser_switch\browser_switch_proxy.js" compress="gzip" type="BINDATA" />
         <include name="IDR_BROWSER_SWITCH_HTML" file="resources\browser_switch\browser_switch.html" compress="gzip" allowexternalscript="true" type="BINDATA" />
@@ -70,7 +70,7 @@
         <include name="IDR_ABOUT_NACL_CSS" file="resources\about_nacl\about_nacl.css" compress="gzip" flattenhtml="true" type="chrome_html" />
         <include name="IDR_ABOUT_NACL_JS" file="resources\about_nacl\about_nacl.js" compress="gzip" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_ABOUT_SYS_HTML" file="resources\about_sys\about_sys.html" compress="gzip" type="BINDATA" />
         <include name="IDR_ABOUT_SYS_CSS" file="resources\about_sys\about_sys.css" compress="gzip" flattenhtml="true" type="BINDATA" />
         <include name="IDR_ABOUT_SYS_JS" file="resources\about_sys\about_sys.js" compress="gzip" type="BINDATA" />
@@ -132,7 +132,7 @@
         <include name="IDR_APP_MANAGEMENT_INDEX_HTML" file="resources\app_management\index.html" compress="gzip" type="BINDATA" />
       </if>
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Page not available for guest. -->
         <include name="IDR_PAGE_NOT_AVAILABLE_FOR_GUEST_APP_HTML" file="resources\page_not_available_for_guest\app.html" type="BINDATA" />
       </if>
@@ -169,17 +169,17 @@
       <if expr="chromeos">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_chromeos.json" type="BINDATA" />
       </if>
-      <if expr="desktop_linux">
+      <if expr="is_android or desktop_linux">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_linux.json" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MANAGEMENT_HTML" file="resources\management\management.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" compress="gzip" />
         <include name="IDR_MANAGEMENT_UI_JS" file="${root_gen_dir}/chrome/browser/resources/management/management_ui.js" use_base_dir="false" type="BINDATA" compress="gzip" preprocess="true" />
         <include name="IDR_MANAGEMENT_BROWSER_PROXY_JS" file="resources\management\management_browser_proxy.js" type="BINDATA" compress="gzip" preprocess="true" />
         <include name="IDR_MANAGEMENT_ICONS_JS" file="${root_gen_dir}/chrome/browser/resources/management/icons.js" use_base_dir="false" type="BINDATA" compress="gzip" preprocess="true" />
       </if>
       <include name="IDR_URL_MOJOM_LITE_JS" file="${root_gen_dir}\url\mojom\url.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_disabled_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_JS" file="resources\signin\sync_confirmation\sync_disabled_confirmation.js" type="BINDATA" />
         <include name="IDR_SYNC_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
@@ -189,7 +189,7 @@
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_ILLUSTRATION_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_illustration.svg" type="BINDATA" compress="gzip" />
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_ILLUSTRATION_DARK_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_illustration_dark.svg" type="BINDATA" compress="gzip" />
       </if>
-      <if expr="is_win or is_macosx or desktop_linux">
+      <if expr="is_android or is_win or is_macosx or desktop_linux">
         <include name="IDR_SIGNIN_EMAIL_CONFIRMATION_HTML" file="resources\signin\signin_email_confirmation\signin_email_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
         <include name="IDR_SIGNIN_EMAIL_CONFIRMATION_APP_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_email_confirmation\signin_email_confirmation_app.js" use_base_dir="false" preprocess="true" type="BINDATA" />
         <include name="IDR_SIGNIN_ERROR_HTML" file="resources\signin\signin_error\signin_error.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
@@ -297,7 +297,7 @@
         <include name="IDR_QUICKOFFICE_MANIFEST" file="resources\chromeos\quickoffice\manifest.json" type="BINDATA" />
         <include name="IDR_PRODUCT_CHROMEOS_SYNC_CONSENT_SCREEN_ICONS" file="internal\resources\chromeos-sync-consent-icons.html" type="BINDATA" />
       </if>
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <include name="IDR_CONTROL_BAR_HTML" file="resources\user_manager\control_bar.html" type="BINDATA" />
         <include name="IDR_CONTROL_BAR_JS" file="resources\user_manager\control_bar.js" type="BINDATA" />
         <include name="IDR_CREATE_PROFILE_HTML" file="resources\user_manager\create_profile.html" type="BINDATA" />
@@ -315,7 +315,7 @@
         <include name="IDR_USER_MANAGER_TUTORIAL_HTML" file="resources\user_manager\user_manager_tutorial.html" type="BINDATA" />
         <include name="IDR_USER_MANAGER_TUTORIAL_JS" file="resources\user_manager\user_manager_tutorial.js" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_IDENTITY_INTERNALS_HTML" file="resources\identity_internals\identity_internals.html" compress="gzip" type="BINDATA" />
         <include name="IDR_IDENTITY_INTERNALS_CSS" file="resources\identity_internals\identity_internals.css" compress="gzip" type="BINDATA" />
         <include name="IDR_IDENTITY_INTERNALS_JS" file="resources\identity_internals\identity_internals.js" compress="gzip" type="BINDATA" />
@@ -392,7 +392,7 @@
         </if>
         <include name="IDR_BRAILLE_MANIFEST" file="resources\chromeos\accessibility\braille_ime\manifest.json" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MEDIA_ROUTER_INTERNALS_HTML" file="resources\media_router\media_router_internals.html" compress="gzip" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_INTERNALS_CSS" file="resources\media_router\media_router_internals.css" compress="gzip" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_INTERNALS_JS" file="resources\media_router\media_router_internals.js" compress="gzip" type="BINDATA" />
@@ -439,7 +439,7 @@
         <include name="IDR_RESET_PASSWORD_JS" file="resources\reset_password\reset_password.js" type="BINDATA" compress="gzip" />
         <include name="IDR_RESET_PASSWORD_MOJOM_LITE_JS" file="${root_gen_dir}\chrome\browser\ui\webui\reset_password\reset_password.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_TAB_RANKER_EXAMPLE_PREPROCESSOR_CONFIG_PB" file="resource_coordinator\tab_ranker\example_preprocessor_config.pb" type="BINDATA" />
         <include name="IDR_TAB_RANKER_PAIRWISE_EXAMPLE_PREPROCESSOR_CONFIG_PB" file="resource_coordinator\tab_ranker\pairwise_preprocessor_config.pb" type="BINDATA" />
       </if>
--- a/chrome/browser/chrome_browser_main.cc
+++ b/chrome/browser/chrome_browser_main.cc
@@ -842,9 +842,11 @@ int ChromeBrowserMainParts::PreEarlyInit
 }
 
 void ChromeBrowserMainParts::PostEarlyInitialization() {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PostEarlyInitialization - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PostEarlyInitialization");
   for (size_t i = 0; i < chrome_extra_parts_.size(); ++i)
     chrome_extra_parts_[i]->PostEarlyInitialization();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PostEarlyInitialization - Step 2";
 }
 
 void ChromeBrowserMainParts::ToolkitInitialized() {
@@ -883,6 +885,7 @@ void ChromeBrowserMainParts::PostMainMes
 }
 
 int ChromeBrowserMainParts::PreCreateThreads() {
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PreCreateThreads - Step 1";
   // IMPORTANT
   // Calls in this function should not post tasks or create threads as
   // components used to handle those tasks are not yet available. This work
@@ -990,18 +993,22 @@ int ChromeBrowserMainParts::ApplyFirstRu
 }
 
 int ChromeBrowserMainParts::PreCreateThreadsImpl() {
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PreCreateThreadsImpl")
   run_message_loop_ = false;
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 2";
 
   if (browser_process_->GetApplicationLocale().empty()) {
     ShowMissingLocaleMessageBox();
     return chrome::RESULT_CODE_MISSING_DATA;
   }
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 3";
 
 #if !defined(OS_ANDROID)
   chrome::MaybeShowInvalidUserDataDirWarningDialog();
 #endif  // !defined(OS_ANDROID)
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 4";
   DCHECK(!user_data_dir_.empty());
 
   // Force MediaCaptureDevicesDispatcher to be created on UI thread.
@@ -1016,22 +1023,28 @@ int ChromeBrowserMainParts::PreCreateThr
   first_run::IsChromeFirstRun();
 
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 5";
 
   PrefService* local_state = browser_process_->local_state();
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 6";
 #if defined(OS_CHROMEOS)
   chromeos::CrosSettings::Initialize(local_state);
   chromeos::StatsReportingController::Initialize(local_state);
   arc::StabilityMetricsManager::Initialize(local_state);
 #endif  // defined(OS_CHROMEOS)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 7";
 
   {
     TRACE_EVENT0(
         "startup",
         "ChromeBrowserMainParts::PreCreateThreadsImpl:InitBrowserProcessImpl");
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 8";
     browser_process_->Init();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 9";
   }
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 10";
 #if !defined(OS_ANDROID)
   // Create the RunLoop for MainMessageLoopRun() to use, and pass a copy of
   // its QuitClosure to the BrowserProcessImpl to call when it is time to exit.
@@ -1051,12 +1064,14 @@ int ChromeBrowserMainParts::PreCreateThr
   base::trace_event::TraceEventETWExport::EnableETWExport();
 #endif  // OS_WIN
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 11";
   // Reset the command line in the crash report details, since we may have
   // just changed it to include experiments.
   crash_keys::SetCrashKeysFromCommandLine(
       *base::CommandLine::ForCurrentProcess());
 
   browser_process_->browser_policy_connector()->OnResourceBundleCreated();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 12";
 
 // Android does first run in Java instead of native.
 // Chrome OS has its own out-of-box-experience code.
@@ -1080,6 +1095,7 @@ int ChromeBrowserMainParts::PreCreateThr
 #endif  // defined(OS_MACOSX) || defined(OS_LINUX)
   }
 #endif  // !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 13";
 
 #if defined(OS_LINUX) || defined(OS_OPENBSD)
   // Set the product channel for crash reports.
@@ -1108,6 +1124,7 @@ int ChromeBrowserMainParts::PreCreateThr
       new vr::XRSessionRequestConsentManagerImpl());
 #endif  // defined(OS_WIN)
 #endif  // BUILDFLAG(ENABLE_VR)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 14";
 
   // Enable Navigation Tracing only if a trace upload url is specified.
   if (parsed_command_line_.HasSwitch(switches::kEnableNavigationTracing) &&
@@ -1115,11 +1132,13 @@ int ChromeBrowserMainParts::PreCreateThr
     tracing::SetupNavigationTracing();
   }
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 15";
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   metrics::DesktopSessionDurationTracker::Initialize();
   ProfileActivityMetricsRecorder::Initialize();
 #endif
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 16";
   metrics::RendererUptimeTracker::Initialize();
 
   // Add Site Isolation switches as dictated by policy.
@@ -1145,16 +1164,19 @@ int ChromeBrowserMainParts::PreCreateThr
         switches::kDisableSiteIsolationForPolicy);
   }
 #endif
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 19";
 
   // ChromeOS needs ui::ResourceBundle::InitSharedInstance to be called before
   // this.
   browser_process_->PreCreateThreads(parsed_command_line());
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 20";
 
   // This must occur in PreCreateThreads() because it initializes global state
   // which is then read by all threads without synchronization. It must be after
   // browser_process_->PreCreateThreads() as that instantiates the IOThread
   // which is used in SetupMetrics().
   SetupMetrics();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 21";
 
   return service_manager::RESULT_CODE_NORMAL_EXIT;
 }
--- a/chrome/browser/chrome_browser_main_android.cc
+++ b/chrome/browser/chrome_browser_main_android.cc
@@ -34,10 +34,12 @@ ChromeBrowserMainPartsAndroid::~ChromeBr
 }
 
 int ChromeBrowserMainPartsAndroid::PreCreateThreads() {
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainPartsAndroid::PreCreateThreads - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainPartsAndroid::PreCreateThreads")
 
   int result_code = ChromeBrowserMainParts::PreCreateThreads();
 
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainPartsAndroid::PreCreateThreads - Step 2";
   // The ChildExitObserver needs to be created before any child process is
   // created because it needs to be notified during process creation.
   crash_reporter::ChildExitObserver::Create();
--- a/chrome/browser/chrome_browser_main_posix.cc
+++ b/chrome/browser/chrome_browser_main_posix.cc
@@ -174,6 +174,6 @@ void ChromeBrowserMainPartsPosix::ShowMi
   // for now, crash.
   NOTREACHED();
 #else
-#error "Need MessageBox implementation."
+
 #endif
 }
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -421,7 +421,7 @@
 #include "chrome/browser/chrome_browser_main_posix.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/badging/badge_manager.h"
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
@@ -1232,6 +1232,7 @@ void ChromeContentBrowserClient::SetAppl
 std::unique_ptr<content::BrowserMainParts>
 ChromeContentBrowserClient::CreateBrowserMainParts(
     const content::MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 1";
   std::unique_ptr<ChromeBrowserMainParts> main_parts;
   // Construct the Main browser parts based on the OS type.
 #if defined(OS_WIN)
@@ -1257,12 +1258,14 @@ ChromeContentBrowserClient::CreateBrowse
   main_parts =
       std::make_unique<ChromeBrowserMainParts>(parameters, startup_data_);
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 2";
 
   bool add_profiles_extra_parts = true;
 #if defined(OS_ANDROID)
   if (startup_data_->HasBuiltProfilePrefService())
     add_profiles_extra_parts = false;
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 3";
   if (add_profiles_extra_parts)
     chrome::AddProfilesExtraParts(main_parts.get());
 
@@ -1280,6 +1283,7 @@ ChromeContentBrowserClient::CreateBrowse
 #endif
 #endif
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 4";
 #if defined(OS_CHROMEOS)
   // TODO(jamescook): Combine with ChromeBrowserMainPartsChromeos.
   main_parts->AddParts(new ChromeBrowserMainExtraPartsAsh());
@@ -1289,6 +1293,7 @@ ChromeContentBrowserClient::CreateBrowse
   main_parts->AddParts(new ChromeBrowserMainExtraPartsX11());
 #endif
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 5";
   main_parts->AddParts(new ChromeBrowserMainExtraPartsPerformanceManager);
 
   main_parts->AddParts(new ChromeBrowserMainExtraPartsProfiling);
@@ -1297,8 +1302,10 @@ ChromeContentBrowserClient::CreateBrowse
 
   main_parts->AddParts(new ChromeBrowserMainExtraPartsGpu);
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 6";
   chrome::AddMetricsExtraParts(main_parts.get());
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 7";
   return main_parts;
 }
 
--- a/chrome/browser/content_settings/cookie_settings_factory.cc
+++ b/chrome/browser/content_settings/cookie_settings_factory.cc
@@ -43,6 +43,7 @@ CookieSettingsFactory::~CookieSettingsFa
 
 void CookieSettingsFactory::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] CookieSettingsFactory::RegisterProfilePrefs";
   content_settings::CookieSettings::RegisterProfilePrefs(registry);
 }
 
--- a/chrome/browser/content_settings/host_content_settings_map_factory.cc
+++ b/chrome/browser/content_settings/host_content_settings_map_factory.cc
@@ -44,7 +44,7 @@ HostContentSettingsMapFactory::HostConte
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
 #endif
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
@@ -85,7 +85,7 @@ scoped_refptr<RefcountedKeyedService>
       /*store_last_modified=*/true,
       base::FeatureList::IsEnabled(features::kPermissionDelegation)));
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   // These must be registered before before the HostSettings are passed over to
   // the IOThread.  Simplest to do this on construction.
   extensions::ExtensionService::RegisterContentSettings(settings_map.get(),
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
@@ -27,7 +27,7 @@ RegisterProtocolHandlerPermissionRequest
 
 permissions::PermissionRequest::IconId
 RegisterProtocolHandlerPermissionRequest::GetIconId() const {
-  return vector_icons::kProtocolHandlerIcon;
+  return 0;
 }
 
 base::string16
@@ -35,6 +35,32 @@ RegisterProtocolHandlerPermissionRequest
   ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
   return old_handler.IsEmpty()
              ? l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
+                   handler_.GetProtocolDisplayName())
+             : l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_REPLACE_FRAGMENT,
+                   handler_.GetProtocolDisplayName(),
+                   base::UTF8ToUTF16(old_handler.url().host_piece()));
+}
+
+base::string16
+RegisterProtocolHandlerPermissionRequest::GetMessageText() const {
+  ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
+  return old_handler.IsEmpty()
+             ? l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
+                   handler_.GetProtocolDisplayName())
+             : l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_REPLACE_FRAGMENT,
+                   handler_.GetProtocolDisplayName(),
+                   base::UTF8ToUTF16(old_handler.url().host_piece()));
+}
+
+base::string16
+RegisterProtocolHandlerPermissionRequest::GetTitleText() const {
+  ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
+  return old_handler.IsEmpty()
+             ? l10n_util::GetStringFUTF16(
                    IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
                    handler_.GetProtocolDisplayName())
              : l10n_util::GetStringFUTF16(
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
@@ -26,6 +26,8 @@ class RegisterProtocolHandlerPermissionR
  private:
   // permissions::PermissionRequest:
   IconId GetIconId() const override;
+  base::string16 GetTitleText() const override;
+  base::string16 GetMessageText() const override;
   base::string16 GetMessageTextFragment() const override;
   GURL GetOrigin() const override;
   void PermissionGranted() override;
--- a/chrome/browser/devtools/BUILD.gn
+++ b/chrome/browser/devtools/BUILD.gn
@@ -4,13 +4,13 @@
 
 import("//extensions/buildflags/buildflags.gni")
 
-if (!is_android) {
+if (true || !is_android) {
   import("//build/config/features.gni")
   import("//chrome/common/features.gni")
   import("//tools/grit/grit_rule.gni")
 }
 
-if (!is_android) {
+if (true || !is_android) {
   _inspector_protocol = "//third_party/inspector_protocol"
   import("$_inspector_protocol/inspector_protocol.gni")
 
@@ -99,7 +99,7 @@ static_library("devtools") {
     "//ui/events:dom_keycode_converter",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       "//chrome:extra_resources",
       "//chrome:resources",
@@ -191,7 +191,7 @@ static_library("devtools") {
   } else {
     sources += [ "devtools_dock_tile.cc" ]
   }
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       ":protocol_generated_sources",
       "//components/subresource_filter/content/browser:browser",
@@ -227,7 +227,7 @@ static_library("test_support") {
   sources = []
   deps = []
 
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       "//base",
       "//chrome/browser/ui",
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -26,7 +26,7 @@
 #include "net/base/url_util.h"
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || true
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -153,7 +153,7 @@ void DownloadCommands::ExecuteCommand(Co
   model_->ExecuteCommand(this, command);
 }
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 
 Browser* DownloadCommands::GetBrowser() const {
   chrome::ScopedTabbedBrowserDisplayer browser_displayer(model_->profile());
@@ -167,18 +167,7 @@ bool DownloadCommands::IsDownloadPdf() c
 }
 
 bool DownloadCommands::CanOpenPdfInSystemViewer() const {
-#if defined(OS_WIN)
-  bool is_adobe_pdf_reader_up_to_date = false;
-  if (IsDownloadPdf() && IsAdobeReaderDefaultPDFViewer()) {
-    is_adobe_pdf_reader_up_to_date =
-        DownloadTargetDeterminer::IsAdobeReaderUpToDate();
-  }
-  return IsDownloadPdf() &&
-         (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
-                                          : true);
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
-  return IsDownloadPdf();
-#endif
+  return false;
 }
 
 #endif  // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
--- a/chrome/browser/download/download_commands.h
+++ b/chrome/browser/download/download_commands.h
@@ -11,9 +11,7 @@
 #include "content/public/browser/page_navigator.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_ANDROID)
 class Browser;
-#endif
 
 class DownloadUIModel;
 
@@ -48,7 +46,7 @@ class DownloadCommands {
   bool IsCommandVisible(Command command) const;
   void ExecuteCommand(Command command);
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || true
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
   Browser* GetBrowser() const;
--- a/chrome/browser/download/download_crx_util_android.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// Download code which handles CRX files (extensions, themes, apps, ...).
-
-#include "chrome/browser/download/download_crx_util.h"
-
-namespace download_crx_util {
-
-bool IsExtensionDownload(const download::DownloadItem& download_item) {
-  // Extensions are not supported on Android. We want to treat them as
-  // normal file downloads.
-  return false;
-}
-
-bool IsTrustedExtensionDownload(Profile* profile,
-                                const download::DownloadItem& item) {
-  // Extensions are not supported on Android, return the safe default.
-  return false;
-}
-
-}  // namespace download_crx_util
--- a/chrome/browser/download/download_danger_prompt.cc
+++ b/chrome/browser/download/download_danger_prompt.cc
@@ -93,11 +93,6 @@ void DownloadDangerPrompt::SendSafeBrows
   }
   report.set_url(download.GetURL().spec());
   report.set_did_proceed(did_proceed);
-  std::string token =
-    safe_browsing::DownloadProtectionService::GetDownloadPingToken(
-        &download);
-  if (!token.empty())
-    report.set_token(token);
   std::string serialized_report;
   if (report.SerializeToString(&serialized_report))
     sb_service->SendSerializedDownloadReport(serialized_report);
--- a/chrome/browser/download/download_shelf_context_menu.cc
+++ b/chrome/browser/download/download_shelf_context_menu.cc
@@ -137,23 +137,6 @@ base::string16 DownloadShelfContextMenu:
       id = IDS_DOWNLOAD_MENU_KEEP;
       break;
     case DownloadCommands::ALWAYS_OPEN_TYPE: {
-      if (download_commands_) {
-        bool can_open_pdf_in_system_viewer =
-            download_commands_->CanOpenPdfInSystemViewer();
-#if defined(OS_WIN)
-        if (can_open_pdf_in_system_viewer) {
-          id = IsAdobeReaderDefaultPDFViewer()
-                   ? IDS_DOWNLOAD_MENU_ALWAYS_OPEN_PDF_IN_READER
-                   : IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
-          break;
-        }
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
-        if (can_open_pdf_in_system_viewer) {
-          id = IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
-          break;
-        }
-#endif
-      }
       id = IDS_DOWNLOAD_MENU_ALWAYS_OPEN_TYPE;
       break;
     }
--- a/chrome/browser/download/download_ui_model.cc
+++ b/chrome/browser/download/download_ui_model.cc
@@ -24,7 +24,7 @@
 #include "ui/base/text/bytes_formatting.h"
 #include "ui/gfx/text_elider.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -538,7 +538,7 @@ bool DownloadUIModel::ShouldPromoteOrigi
   return false;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool DownloadUIModel::IsCommandEnabled(
     const DownloadCommands* download_commands,
     DownloadCommands::Command command) const {
--- a/chrome/browser/download/download_ui_model.h
+++ b/chrome/browser/download/download_ui_model.h
@@ -19,7 +19,7 @@
 #include "components/offline_items_collection/core/offline_item.h"
 #include "components/safe_browsing/buildflags.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/download/download_commands.h"
 #endif
 
@@ -295,7 +295,7 @@ class DownloadUIModel {
   // security reasons.
   virtual bool ShouldPromoteOrigin() const;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Methods related to DownloadCommands.
   // Returns whether the given download command is enabled for this download.
   virtual bool IsCommandEnabled(const DownloadCommands* download_commands,
--- /dev/null
+++ b/chrome/browser/download/drag_download_item_android.cc
@@ -0,0 +1,35 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/download/drag_download_item.h"
+
+#include <string>
+
+#include "build/build_config.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/download/public/common/download_item.h"
+#include "net/base/mime_util.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_event_dispatcher.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/views/button_drag_utils.h"
+#include "ui/views/widget/widget.h"
+#include "url/gurl.h"
+
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/download_handler.h"
+#include "content/public/browser/download_item_utils.h"
+#endif
+
+void DragDownloadItem(const download::DownloadItem* download,
+                      gfx::Image* icon,
+                      gfx::NativeView view) {
+}
--- a/chrome/browser/download/drag_download_item_aura.cc
+++ b/chrome/browser/download/drag_download_item_aura.cc
@@ -31,6 +31,7 @@
 void DragDownloadItem(const download::DownloadItem* download,
                       gfx::Image* icon,
                       gfx::NativeView view) {
+#if 0
   DCHECK(download);
   DCHECK_EQ(download::DownloadItem::COMPLETE, download->GetState());
 
@@ -59,4 +60,5 @@ void DragDownloadItem(const download::Do
           std::move(data), root_window, view, location,
           ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_LINK,
           ui::DragDropTypes::DRAG_EVENT_SOURCE_MOUSE);
+#endif
 }
--- a/chrome/browser/enterprise_reporting/policy_info.cc
+++ b/chrome/browser/enterprise_reporting/policy_info.cc
@@ -110,6 +110,7 @@ void AppendExtensionPolicyInfoIntoProfil
 
 void AppendMachineLevelUserCloudPolicyFetchTimestamp(
     em::ChromeUserProfileInfo* profile_info) {
+#if 0
 #if !defined(OS_CHROMEOS)
   policy::MachineLevelUserCloudPolicyManager* manager =
       g_browser_process->browser_policy_connector()
@@ -122,6 +123,7 @@ void AppendMachineLevelUserCloudPolicyFe
   timestamp->set_timestamp(
       manager->core()->client()->last_policy_timestamp().ToJavaTime());
 #endif
+#endif
 }
 
 }  // namespace enterprise_reporting
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -225,6 +225,7 @@ jumbo_static_library("extensions") {
     "api/image_writer_private/removable_storage_provider_chromeos.cc",
     "api/image_writer_private/removable_storage_provider_mac.cc",
     "api/image_writer_private/removable_storage_provider_win.cc",
+    "api/image_writer_private/removable_storage_provider_android.cc",
     "api/image_writer_private/unzip_helper.cc",
     "api/image_writer_private/unzip_helper.h",
     "api/image_writer_private/write_from_file_operation.cc",
@@ -625,6 +626,7 @@ jumbo_static_library("extensions") {
     "global_shortcut_listener_mac.mm",
     "global_shortcut_listener_win.cc",
     "global_shortcut_listener_win.h",
+    "global_shortcut_listener_android.cc",
     "install_gate.h",
     "install_observer.cc",
     "install_observer.h",
@@ -695,6 +697,8 @@ jumbo_static_library("extensions") {
     "system_display/display_info_provider_chromeos.h",
     "system_display/display_info_provider_mac.cc",
     "system_display/display_info_provider_mac.h",
+    "system_display/display_info_provider_android.cc",
+    "system_display/display_info_provider_android.h",
     "system_display/display_info_provider_win.cc",
     "system_display/display_info_provider_win.h",
     "tab_helper.cc",
@@ -792,7 +796,6 @@ jumbo_static_library("extensions") {
     "//chrome/browser/engagement:mojo_bindings",
     "//chrome/browser/image_decoder",
     "//chrome/browser/media/router",
-    "//chrome/browser/media/router/discovery",
     "//chrome/browser/resource_coordinator:mojo_bindings",
     "//chrome/browser/safe_browsing",
     "//chrome/browser/web_applications/components",
@@ -1106,7 +1109,7 @@ jumbo_static_library("extensions") {
     }
   }
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [
       "api/processes/processes_api.cc",
       "api/processes/processes_api.h",
@@ -1162,8 +1165,6 @@ jumbo_static_library("extensions") {
 
   if (enable_plugins) {
     sources += [
-      "plugin_manager.cc",
-      "plugin_manager.h",
     ]
   }
 
--- a/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
+++ b/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
@@ -445,11 +445,6 @@ bool BookmarkManagerPrivateStartDragFunc
   if (params->is_from_touch)
     source = ui::DragDropTypes::DRAG_EVENT_SOURCE_TOUCH;
 
-  chrome::DragBookmarks(GetProfile(),
-                        {std::move(nodes), params->drag_node_index,
-                         web_contents->GetContentNativeView(), source,
-                         gfx::Point(params->x, params->y)});
-
   return true;
 }
 
--- a/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
+++ b/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
@@ -351,24 +351,7 @@ bool BrowsingDataRemoverFunction::RunAsy
     return false;
   }
 
-#if BUILDFLAG(ENABLE_PLUGINS)
-  if (removal_mask_ &
-      ChromeBrowsingDataRemoverDelegate::DATA_TYPE_PLUGIN_DATA) {
-    // If we're being asked to remove plugin data, check whether it's actually
-    // supported.
-    PostTask(FROM_HERE,
-             {base::ThreadPool(), base::MayBlock(),
-              base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN,
-              base::TaskPriority::USER_VISIBLE},
-             base::BindOnce(
-                 &BrowsingDataRemoverFunction::CheckRemovingPluginDataSupported,
-                 this, PluginPrefs::GetForProfile(GetProfile())));
-  } else {
-    StartRemoving();
-  }
-#else
   StartRemoving();
-#endif
 
   // Will finish asynchronously.
   return true;
--- a/chrome/browser/extensions/api/content_settings/content_settings_api.cc
+++ b/chrome/browser/extensions/api/content_settings/content_settings_api.cc
@@ -322,7 +322,7 @@ bool ContentSettingsContentSettingGetRes
     return true;
   }
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if 0
   content::PluginService::GetInstance()->GetPlugins(base::BindOnce(
       &ContentSettingsContentSettingGetResourceIdentifiersFunction::
           OnGotPlugins,
@@ -332,7 +332,7 @@ bool ContentSettingsContentSettingGetRes
   return true;
 }
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if 0
 void ContentSettingsContentSettingGetResourceIdentifiersFunction::OnGotPlugins(
     const std::vector<content::WebPluginInfo>& plugins) {
   PluginFinder* finder = PluginFinder::GetInstance();
@@ -359,6 +359,7 @@ void ContentSettingsContentSettingGetRes
           &ContentSettingsContentSettingGetResourceIdentifiersFunction::
               SendResponse,
           this, true));
+#endif
 }
 #endif  // BUILDFLAG(ENABLE_PLUGINS)
 
--- a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
@@ -89,12 +89,7 @@ std::string GetProfileId(const Profile*
 // Returns last policy fetch timestamp of machine level user cloud policy if
 // it exists. Otherwise, returns zero.
 int64_t GetMachineLevelUserCloudPolicyFetchTimestamp() {
-  policy::MachineLevelUserCloudPolicyManager* manager =
-      g_browser_process->browser_policy_connector()
-          ->machine_level_user_cloud_policy_manager();
-  if (!manager || !manager->IsClientRegistered())
-    return 0;
-  return manager->core()->client()->last_policy_timestamp().ToJavaTime();
+  return 0;
 }
 
 void AppendAdditionalBrowserInformation(em::ChromeDesktopReportRequest* request,
--- /dev/null
+++ b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
@@ -0,0 +1,19 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include "base/files/file_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace extensions {
+// static
+scoped_refptr<StorageDeviceList>
+RemovableStorageProvider::PopulateDeviceList() {
+  return nullptr;
+}
+
+}  // namespace extensions
--- /dev/null
+++ b/chrome/browser/extensions/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,184 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task_scheduler/post_task.h"
+#include "base/threading/thread_restrictions.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace {
+
+using extensions::api::DeviceId;
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+  "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+// Fedora 15 uses biosdevname feature where Embedded ethernet uses the
+// "em" prefix and PCI cards use the p[0-9]c[0-9] format based on PCI
+// slot and card information.
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::AssertBlockingAllowed();
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < arraysize(kDeviceNames); i++) {
+    DiskEntries::iterator it =
+        disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin();
+        it != disk_uuids.end(); ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value() << ", uuid="
+                 << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {
+  }
+
+  bool ProcessInterface(struct ifaddrs *ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  return "";
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  base::AssertBlockingAllowed();
+
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                   base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+namespace extensions {
+namespace api {
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTaskWithTraits(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace extensions
--- a/chrome/browser/extensions/api/resources_private/resources_private_api.cc
+++ b/chrome/browser/extensions/api/resources_private/resources_private_api.cc
@@ -45,6 +45,7 @@ void AddStringsForIdentity(base::Diction
 void AddStringsForPdf(base::DictionaryValue* dict) {
 #if BUILDFLAG(ENABLE_PDF)
   static constexpr webui::LocalizedString kPdfResources[] = {
+#if 0
     {"passwordDialogTitle", IDS_PDF_PASSWORD_DIALOG_TITLE},
     {"passwordPrompt", IDS_PDF_NEED_PASSWORD},
     {"passwordSubmit", IDS_PDF_PASSWORD_SUBMIT},
@@ -114,6 +115,7 @@ void AddStringsForPdf(base::DictionaryVa
     {"annotationFormWarningKeepEditing", IDS_PDF_KEEP_EDITING},
     {"annotationFormWarningDiscard", IDS_PDF_DISCARD},
 #endif  // defined(OS_CHROMEOS)
+#endif
   };
   for (const auto& resource : kPdfResources)
     dict->SetString(resource.name, l10n_util::GetStringUTF16(resource.id));
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -857,6 +857,7 @@ const user_manager::User* SafeBrowsingPr
 #endif
 
 bool SafeBrowsingPrivateEventRouter::IsRealtimeReportingAvailable() {
+#if 0
 #if defined(OS_CHROMEOS)
   // The device must be managed.
   if (!g_browser_process->platform_part()
@@ -875,6 +876,8 @@ bool SafeBrowsingPrivateEventRouter::IsR
 #else
   return policy::ChromeBrowserCloudManagementController::IsEnabled();
 #endif
+#endif
+  return false;
 }
 
 }  // namespace extensions
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,8 +164,6 @@ WindowsEventRouter::WindowsEventRouter(P
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
-#else
-#error Unsupported
 #endif
 
   AppWindowRegistry* registry = AppWindowRegistry::Get(profile_);
--- /dev/null
+++ b/chrome/browser/extensions/bookmark_app_helper.cc
@@ -0,0 +1,868 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/bookmark_app_helper.h"
+
+#include <stddef.h>
+
+#include <cctype>
+#include <string>
+#include <utility>
+
+#include "base/command_line.h"
+#include "base/feature_list.h"
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/time/time.h"
+#include "build/build_config.h"
+#include "chrome/browser/banners/app_banner_manager.h"
+#include "chrome/browser/banners/app_banner_manager_desktop.h"
+#include "chrome/browser/banners/app_banner_settings_helper.h"
+#include "chrome/browser/bitmap_fetcher/bitmap_fetcher.h"
+#include "chrome/browser/bitmap_fetcher/bitmap_fetcher_delegate.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/extensions/convert_web_app.h"
+#include "chrome/browser/extensions/crx_installer.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/favicon_downloader.h"
+#include "chrome/browser/extensions/launch_util.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "chrome/browser/installable/installable_data.h"
+#include "chrome/browser/installable/installable_manager.h"
+#include "chrome/browser/installable/installable_params.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/app_list/app_list_util.h"
+#include "chrome/browser/ui/browser_commands.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/extensions/application_launch.h"
+#include "chrome/browser/web_applications/web_app.h"
+#include "chrome/browser/webshare/share_target_pref_helper.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/extensions/api/url_handlers/url_handlers_parser.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/common/extensions/manifest_handlers/app_launch_info.h"
+#include "chrome/common/origin_trials/chrome_origin_trial_policy.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/platform_locale_settings.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/navigation_controller.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_source.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/content_switches.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/notification_types.h"
+#include "extensions/browser/pref_names.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/url_pattern.h"
+#include "net/base/load_flags.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "net/url_request/url_request.h"
+#include "skia/ext/image_operations.h"
+#include "skia/ext/platform_canvas.h"
+#include "third_party/blink/public/common/manifest/web_display_mode.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/color_analysis.h"
+#include "ui/gfx/color_utils.h"
+#include "ui/gfx/font.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/image/canvas_image_source.h"
+#include "ui/gfx/image/image.h"
+
+#if defined(OS_MACOSX)
+#include "chrome/browser/web_applications/web_app_mac.h"
+#include "chrome/common/chrome_switches.h"
+#endif
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif  // defined(OS_WIN)
+
+#if defined(OS_CHROMEOS)
+// gn check complains on Linux Ozone.
+#include "ash/public/cpp/shelf_model.h"  // nogncheck
+#include "chrome/browser/ui/ash/launcher/chrome_launcher_controller.h"
+#endif
+
+namespace {
+
+using extensions::BookmarkAppHelper;
+
+// Overlays a shortcut icon over the bottom left corner of a given image.
+class GeneratedIconImageSource : public gfx::CanvasImageSource {
+ public:
+  explicit GeneratedIconImageSource(char letter, SkColor color, int output_size)
+      : gfx::CanvasImageSource(gfx::Size(output_size, output_size), false),
+        letter_(letter),
+        color_(color),
+        output_size_(output_size) {}
+  ~GeneratedIconImageSource() override {}
+
+ private:
+  // gfx::CanvasImageSource overrides:
+  void Draw(gfx::Canvas* canvas) override {
+    const uint8_t kLumaThreshold = 190;
+    const int icon_size = output_size_ * 3 / 4;
+    const int icon_inset = output_size_ / 8;
+    const size_t border_radius = output_size_ / 16;
+    const size_t font_size = output_size_ * 7 / 16;
+
+    std::string font_name =
+        l10n_util::GetStringUTF8(IDS_SANS_SERIF_FONT_FAMILY);
+#if defined(OS_CHROMEOS)
+    const std::string kChromeOSFontFamily = "Noto Sans";
+    font_name = kChromeOSFontFamily;
+#endif
+
+    // Draw a rounded rect of the given |color|.
+    cc::PaintFlags background_flags;
+    background_flags.setAntiAlias(true);
+    background_flags.setColor(color_);
+
+    gfx::Rect icon_rect(icon_inset, icon_inset, icon_size, icon_size);
+    canvas->DrawRoundRect(icon_rect, border_radius, background_flags);
+
+    // The text rect's size needs to be odd to center the text correctly.
+    gfx::Rect text_rect(icon_inset, icon_inset, icon_size + 1, icon_size + 1);
+    // Draw the letter onto the rounded rect. The letter's color depends on the
+    // luma of |color|.
+    const uint8_t luma = color_utils::GetLuma(color_);
+    canvas->DrawStringRectWithFlags(
+        base::string16(1, std::toupper(letter_)),
+        gfx::FontList(gfx::Font(font_name, font_size)),
+        (luma > kLumaThreshold) ? SK_ColorBLACK : SK_ColorWHITE,
+        text_rect,
+        gfx::Canvas::TEXT_ALIGN_CENTER);
+  }
+
+  char letter_;
+
+  SkColor color_;
+
+  int output_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(GeneratedIconImageSource);
+};
+
+std::set<int> SizesToGenerate() {
+  // Generate container icons from smaller icons.
+  const int kIconSizesToGenerate[] = {
+      extension_misc::EXTENSION_ICON_SMALL,
+      extension_misc::EXTENSION_ICON_SMALL * 2,
+      extension_misc::EXTENSION_ICON_MEDIUM,
+      extension_misc::EXTENSION_ICON_MEDIUM * 2,
+      extension_misc::EXTENSION_ICON_LARGE,
+      extension_misc::EXTENSION_ICON_LARGE * 2,
+  };
+  return std::set<int>(kIconSizesToGenerate,
+                       kIconSizesToGenerate + arraysize(kIconSizesToGenerate));
+}
+
+void GenerateIcons(
+    std::set<int> generate_sizes,
+    const GURL& app_url,
+    SkColor generated_icon_color,
+    std::map<int, BookmarkAppHelper::BitmapAndSource>* bitmap_map) {
+  // The letter that will be painted on the generated icon.
+  char icon_letter = ' ';
+  std::string domain_and_registry(
+      net::registry_controlled_domains::GetDomainAndRegistry(
+          app_url,
+          net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES));
+  if (!domain_and_registry.empty()) {
+    icon_letter = domain_and_registry[0];
+  } else if (app_url.has_host()) {
+    icon_letter = app_url.host_piece()[0];
+  }
+
+  // If no color has been specified, use a dark gray so it will stand out on the
+  // black shelf.
+  if (generated_icon_color == SK_ColorTRANSPARENT)
+    generated_icon_color = SK_ColorDKGRAY;
+
+  for (int size : generate_sizes) {
+    extensions::BookmarkAppHelper::GenerateIcon(
+        bitmap_map, size, generated_icon_color, icon_letter);
+  }
+}
+
+void ReplaceWebAppIcons(
+    std::map<int, BookmarkAppHelper::BitmapAndSource> bitmap_map,
+    WebApplicationInfo* web_app_info) {
+  web_app_info->icons.clear();
+
+  // Populate the icon data into the WebApplicationInfo we are using to
+  // install the bookmark app.
+  for (const auto& pair : bitmap_map) {
+    WebApplicationInfo::IconInfo icon_info;
+    icon_info.data = pair.second.bitmap;
+    icon_info.url = pair.second.source_url;
+    icon_info.width = icon_info.data.width();
+    icon_info.height = icon_info.data.height();
+    web_app_info->icons.push_back(icon_info);
+  }
+}
+
+// Class to handle installing a bookmark app after it has synced. Handles
+// downloading and decoding the icons.
+class BookmarkAppInstaller : public base::RefCounted<BookmarkAppInstaller>,
+                             public content::WebContentsObserver {
+ public:
+  BookmarkAppInstaller(ExtensionService* service,
+                       const WebApplicationInfo& web_app_info)
+      : service_(service),
+        web_app_info_(web_app_info) {}
+
+  void Run() {
+    for (const auto& icon : web_app_info_.icons) {
+      if (icon.url.is_valid())
+        urls_to_download_.push_back(icon.url);
+    }
+
+    if (urls_to_download_.size()) {
+      // Matched in OnIconsDownloaded.
+      AddRef();
+      SetupWebContents();
+
+      return;
+    }
+
+    FinishInstallation();
+  }
+
+  void SetupWebContents() {
+    // Spin up a web contents process so we can use FaviconDownloader.
+    // This is necessary to make sure we pick up all of the images provided
+    // in favicon URLs. Without this, bookmark app sync can fail due to
+    // missing icons which are not correctly extracted from a favicon.
+    // (The eventual error indicates that there are missing files, which
+    // are the not-extracted favicon images).
+    //
+    // TODO(dominickn): refactor bookmark app syncing to reuse one web
+    // contents for all pending synced bookmark apps. This will avoid
+    // pathological cases where n renderers for n bookmark apps are spun up on
+    // first sign-in to a new machine.
+    web_contents_ = content::WebContents::Create(
+        content::WebContents::CreateParams(service_->profile()));
+    Observe(web_contents_.get());
+
+    // Load about:blank so that the process actually starts.
+    // Image download continues in DidFinishLoad.
+    content::NavigationController::LoadURLParams load_params(
+        GURL("about:blank"));
+    load_params.transition_type = ui::PAGE_TRANSITION_GENERATED;
+    web_contents_->GetController().LoadURLWithParams(load_params);
+  }
+
+  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                     const GURL& validated_url) override {
+    favicon_downloader_.reset(new FaviconDownloader(
+        web_contents_.get(), urls_to_download_,
+        "Extensions.BookmarkApp.Icon.HttpStatusCodeClassOnSync",
+        base::BindOnce(&BookmarkAppInstaller::OnIconsDownloaded,
+                       base::Unretained(this))));
+
+    // Skip downloading the page favicons as everything in is the URL list.
+    favicon_downloader_->SkipPageFavicons();
+    favicon_downloader_->Start();
+  }
+
+ private:
+  friend class base::RefCounted<BookmarkAppInstaller>;
+  ~BookmarkAppInstaller() override {}
+
+  void OnIconsDownloaded(bool success,
+                         const std::map<GURL, std::vector<SkBitmap>>& bitmaps) {
+    // Ignore the unsuccessful case, as the necessary icons will be generated.
+    if (success) {
+      for (const auto& url_bitmaps : bitmaps) {
+        for (const auto& bitmap : url_bitmaps.second) {
+          // Only accept square icons.
+          if (bitmap.empty() || bitmap.width() != bitmap.height())
+            continue;
+
+          downloaded_bitmaps_.push_back(
+              BookmarkAppHelper::BitmapAndSource(url_bitmaps.first, bitmap));
+        }
+      }
+    }
+    FinishInstallation();
+    Release();
+  }
+
+  void FinishInstallation() {
+    // Ensure that all icons that are in web_app_info are present, by generating
+    // icons for any sizes which have failed to download. This ensures that the
+    // created manifest for the bookmark app does not contain links to icons
+    // which are not actually created and linked on disk.
+
+    // Ensure that all icon widths in the web app info icon array are present in
+    // the sizes to generate set. This ensures that we will have all of the
+    // icon sizes from when the app was originally added, even if icon URLs are
+    // no longer accessible.
+    std::set<int> sizes_to_generate = SizesToGenerate();
+    for (const auto& icon : web_app_info_.icons)
+      sizes_to_generate.insert(icon.width);
+
+    std::map<int, BookmarkAppHelper::BitmapAndSource> size_map =
+        BookmarkAppHelper::ResizeIconsAndGenerateMissing(
+            downloaded_bitmaps_, sizes_to_generate, &web_app_info_);
+    BookmarkAppHelper::UpdateWebAppIconsWithoutChangingLinks(size_map,
+                                                             &web_app_info_);
+    scoped_refptr<extensions::CrxInstaller> installer(
+        extensions::CrxInstaller::CreateSilent(service_));
+    installer->set_error_on_unsupported_requirements(true);
+    installer->InstallWebApp(web_app_info_);
+  }
+
+  ExtensionService* service_;
+  WebApplicationInfo web_app_info_;
+
+  std::unique_ptr<content::WebContents> web_contents_;
+  std::unique_ptr<FaviconDownloader> favicon_downloader_;
+  std::vector<GURL> urls_to_download_;
+  std::vector<BookmarkAppHelper::BitmapAndSource> downloaded_bitmaps_;
+};
+
+}  // namespace
+
+namespace extensions {
+
+// static
+void BookmarkAppHelper::UpdateWebAppInfoFromManifest(
+    const blink::Manifest& manifest,
+    WebApplicationInfo* web_app_info,
+    ForInstallableSite for_installable_site) {
+  if (!manifest.short_name.is_null())
+    web_app_info->title = manifest.short_name.string();
+
+  // Give the full length name priority.
+  if (!manifest.name.is_null())
+    web_app_info->title = manifest.name.string();
+
+  // Set the url based on the manifest value, if any.
+  if (manifest.start_url.is_valid())
+    web_app_info->app_url = manifest.start_url;
+
+  if (for_installable_site == ForInstallableSite::kYes) {
+    // If there is no scope present, use 'start_url' without the filename as the
+    // scope. This does not match the spec but it matches what we do on Android.
+    // See: https://github.com/w3c/manifest/issues/550
+    if (!manifest.scope.is_empty())
+      web_app_info->scope = manifest.scope;
+    else if (manifest.start_url.is_valid())
+      web_app_info->scope = manifest.start_url.Resolve(".");
+  }
+
+  if (manifest.theme_color)
+    web_app_info->theme_color = *manifest.theme_color;
+
+  // If any icons are specified in the manifest, they take precedence over any
+  // we picked up from the web_app stuff.
+  if (!manifest.icons.empty()) {
+    web_app_info->icons.clear();
+    for (const auto& icon : manifest.icons) {
+      // TODO(benwells): Take the declared icon density and sizes into account.
+      WebApplicationInfo::IconInfo info;
+      info.url = icon.src;
+      web_app_info->icons.push_back(info);
+    }
+  }
+}
+
+// static
+std::map<int, BookmarkAppHelper::BitmapAndSource>
+BookmarkAppHelper::ConstrainBitmapsToSizes(
+    const std::vector<BookmarkAppHelper::BitmapAndSource>& bitmaps,
+    const std::set<int>& sizes) {
+  std::map<int, BitmapAndSource> output_bitmaps;
+  std::map<int, BitmapAndSource> ordered_bitmaps;
+  for (const BitmapAndSource& bitmap_and_source : bitmaps) {
+    const SkBitmap& bitmap = bitmap_and_source.bitmap;
+    DCHECK(bitmap.width() == bitmap.height());
+    ordered_bitmaps[bitmap.width()] = bitmap_and_source;
+  }
+
+  if (ordered_bitmaps.size() > 0) {
+    for (const auto& size : sizes) {
+      // Find the closest not-smaller bitmap, or failing that use the largest
+      // icon available.
+      auto bitmaps_it = ordered_bitmaps.lower_bound(size);
+      if (bitmaps_it != ordered_bitmaps.end())
+        output_bitmaps[size] = bitmaps_it->second;
+      else
+        output_bitmaps[size] = ordered_bitmaps.rbegin()->second;
+
+      // Resize the bitmap if it does not exactly match the desired size.
+      if (output_bitmaps[size].bitmap.width() != size) {
+        output_bitmaps[size].bitmap = skia::ImageOperations::Resize(
+            output_bitmaps[size].bitmap, skia::ImageOperations::RESIZE_LANCZOS3,
+            size, size);
+      }
+    }
+  }
+
+  return output_bitmaps;
+}
+
+// static
+void BookmarkAppHelper::GenerateIcon(
+    std::map<int, BookmarkAppHelper::BitmapAndSource>* bitmaps,
+    int output_size,
+    SkColor color,
+    char letter) {
+  // Do nothing if there is already an icon of |output_size|.
+  if (bitmaps->count(output_size))
+    return;
+
+  gfx::ImageSkia icon_image(
+      std::make_unique<GeneratedIconImageSource>(letter, color, output_size),
+      gfx::Size(output_size, output_size));
+  SkBitmap& dst = (*bitmaps)[output_size].bitmap;
+  if (dst.tryAllocPixels(icon_image.bitmap()->info())) {
+    icon_image.bitmap()->readPixels(dst.info(), dst.getPixels(), dst.rowBytes(),
+                                    0, 0);
+  }
+}
+
+// static
+bool BookmarkAppHelper::BookmarkOrHostedAppInstalled(
+    content::BrowserContext* browser_context,
+    const GURL& url) {
+  ExtensionRegistry* registry = ExtensionRegistry::Get(browser_context);
+  const ExtensionSet& extensions = registry->enabled_extensions();
+
+  // Iterate through the extensions and extract the LaunchWebUrl (bookmark apps)
+  // or check the web extent (hosted apps).
+  for (const scoped_refptr<const Extension>& extension : extensions) {
+    if (!extension->is_hosted_app())
+      continue;
+
+    if (extension->web_extent().MatchesURL(url) ||
+        AppLaunchInfo::GetLaunchWebURL(extension.get()) == url) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// static
+std::map<int, BookmarkAppHelper::BitmapAndSource>
+BookmarkAppHelper::ResizeIconsAndGenerateMissing(
+    std::vector<BookmarkAppHelper::BitmapAndSource> icons,
+    std::set<int> sizes_to_generate,
+    WebApplicationInfo* web_app_info) {
+  // Resize provided icons to make sure we have versions for each size in
+  // |sizes_to_generate|.
+  std::map<int, BitmapAndSource> resized_bitmaps(
+      ConstrainBitmapsToSizes(icons, sizes_to_generate));
+
+  // Also add all provided icon sizes.
+  for (const BitmapAndSource& icon : icons) {
+    if (resized_bitmaps.find(icon.bitmap.width()) == resized_bitmaps.end())
+      resized_bitmaps.insert(std::make_pair(icon.bitmap.width(), icon));
+  }
+
+  // Determine the color that will be used for the icon's background. For this
+  // the dominant color of the first icon found is used.
+  if (resized_bitmaps.size()) {
+    color_utils::GridSampler sampler;
+    web_app_info->generated_icon_color =
+        color_utils::CalculateKMeanColorOfBitmap(
+            resized_bitmaps.begin()->second.bitmap);
+  }
+
+  // Work out what icons we need to generate here. Icons are only generated if
+  // there is no icon in the required size.
+  std::set<int> generate_sizes;
+  for (int size : sizes_to_generate) {
+    if (resized_bitmaps.find(size) == resized_bitmaps.end())
+      generate_sizes.insert(size);
+  }
+  GenerateIcons(generate_sizes, web_app_info->app_url,
+                web_app_info->generated_icon_color, &resized_bitmaps);
+
+  return resized_bitmaps;
+}
+
+// static
+void BookmarkAppHelper::UpdateWebAppIconsWithoutChangingLinks(
+    std::map<int, BookmarkAppHelper::BitmapAndSource> bitmap_map,
+    WebApplicationInfo* web_app_info) {
+  // First add in the icon data that have urls with the url / size data from the
+  // original web app info, and the data from the new icons (if any).
+  for (auto& icon : web_app_info->icons) {
+    if (!icon.url.is_empty() && icon.data.empty()) {
+      const auto& it = bitmap_map.find(icon.width);
+      if (it != bitmap_map.end() && it->second.source_url == icon.url)
+        icon.data = it->second.bitmap;
+    }
+  }
+
+  // Now add in any icons from the updated list that don't have URLs.
+  for (const auto& pair : bitmap_map) {
+    if (pair.second.source_url.is_empty()) {
+      WebApplicationInfo::IconInfo icon_info;
+      icon_info.data = pair.second.bitmap;
+      icon_info.width = pair.first;
+      icon_info.height = pair.first;
+      web_app_info->icons.push_back(icon_info);
+    }
+  }
+}
+
+BookmarkAppHelper::BitmapAndSource::BitmapAndSource() {
+}
+
+BookmarkAppHelper::BitmapAndSource::BitmapAndSource(const GURL& source_url_p,
+                                                    const SkBitmap& bitmap_p)
+    : source_url(source_url_p),
+      bitmap(bitmap_p) {
+}
+
+BookmarkAppHelper::BitmapAndSource::~BitmapAndSource() {
+}
+
+BookmarkAppHelper::BookmarkAppHelper(Profile* profile,
+                                     WebApplicationInfo web_app_info,
+                                     content::WebContents* contents,
+                                     WebappInstallSource install_source)
+    : profile_(profile),
+      contents_(contents),
+      web_app_info_(web_app_info),
+      crx_installer_(extensions::CrxInstaller::CreateSilent(
+          ExtensionSystem::Get(profile)->extension_service())),
+      install_source_(install_source),
+      weak_factory_(this) {
+  if (contents)
+    installable_manager_ = InstallableManager::FromWebContents(contents);
+
+  // Use the last bookmark app creation type. The launch container is decided by
+  // the system for desktop PWAs.
+  if (!base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {
+    web_app_info_.open_as_window =
+        profile_->GetPrefs()->GetInteger(
+            extensions::pref_names::kBookmarkAppCreationLaunchType) ==
+        extensions::LAUNCH_TYPE_WINDOW;
+  }
+
+  // The default app title is the page title, which can be quite long. Limit the
+  // default name used to something sensible.
+  const int kMaxDefaultTitle = 40;
+  if (web_app_info_.title.length() > kMaxDefaultTitle) {
+    web_app_info_.title = web_app_info_.title.substr(0, kMaxDefaultTitle - 3) +
+                          base::UTF8ToUTF16("...");
+  }
+
+  registrar_.Add(this,
+                 extensions::NOTIFICATION_CRX_INSTALLER_DONE,
+                 content::Source<CrxInstaller>(crx_installer_.get()));
+
+  registrar_.Add(this,
+                 extensions::NOTIFICATION_EXTENSION_INSTALL_ERROR,
+                 content::Source<CrxInstaller>(crx_installer_.get()));
+
+  crx_installer_->set_error_on_unsupported_requirements(true);
+}
+
+BookmarkAppHelper::~BookmarkAppHelper() {}
+
+void BookmarkAppHelper::Create(const CreateBookmarkAppCallback& callback) {
+  callback_ = callback;
+
+  // Do not fetch the manifest for extension URLs.
+  if (contents_ &&
+      !contents_->GetVisibleURL().SchemeIs(extensions::kExtensionScheme)) {
+    // Null in tests. OnDidPerformInstallableCheck is called via a testing API.
+    // TODO(crbug.com/829232) ensure this is consistent with other calls to
+    // GetData.
+    if (installable_manager_) {
+      InstallableParams params;
+      params.check_eligibility = true;
+      params.valid_primary_icon = true;
+      params.valid_manifest = true;
+      // Do not wait for a service worker if it doesn't exist.
+      params.has_worker = true;
+      installable_manager_->GetData(
+          params, base::Bind(&BookmarkAppHelper::OnDidPerformInstallableCheck,
+                             weak_factory_.GetWeakPtr()));
+    }
+  } else {
+    for_installable_site_ = ForInstallableSite::kNo;
+    OnIconsDownloaded(true, std::map<GURL, std::vector<SkBitmap>>());
+  }
+}
+
+void BookmarkAppHelper::OnDidPerformInstallableCheck(
+    const InstallableData& data) {
+  DCHECK(data.manifest_url.is_valid() || data.manifest->IsEmpty());
+
+  if (contents_->IsBeingDestroyed())
+    return;
+
+  for_installable_site_ = data.error_code == NO_ERROR_DETECTED
+                              ? ForInstallableSite::kYes
+                              : ForInstallableSite::kNo;
+
+  UpdateWebAppInfoFromManifest(*data.manifest, &web_app_info_,
+                               for_installable_site_);
+
+  // TODO(mgiuca): Web Share Target should have its own flag, rather than using
+  // the experimental-web-platform-features flag. https://crbug.com/736178.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnableExperimentalWebPlatformFeatures)) {
+    UpdateShareTargetInPrefs(data.manifest_url, *data.manifest,
+                             profile_->GetPrefs());
+  }
+
+  // Add icon urls to download from the WebApplicationInfo.
+  std::vector<GURL> web_app_info_icon_urls;
+  for (auto& info : web_app_info_.icons) {
+    if (!info.url.is_valid())
+      continue;
+
+    // Skip downloading icon if we already have it from the InstallableManager.
+    if (info.url == data.primary_icon_url && data.primary_icon)
+      continue;
+
+    web_app_info_icon_urls.push_back(info.url);
+  }
+
+  // Add the primary icon to the final bookmark app creation data.
+  if (data.primary_icon_url.is_valid()) {
+    WebApplicationInfo::IconInfo primary_icon_info;
+    const SkBitmap& icon = *data.primary_icon;
+    primary_icon_info.url = data.primary_icon_url;
+    primary_icon_info.data = icon;
+    primary_icon_info.width = icon.width();
+    primary_icon_info.height = icon.height();
+    web_app_info_.icons.push_back(primary_icon_info);
+  }
+
+  favicon_downloader_.reset(new FaviconDownloader(
+      contents_, web_app_info_icon_urls,
+      "Extensions.BookmarkApp.Icon.HttpStatusCodeClassOnCreate",
+      base::BindOnce(&BookmarkAppHelper::OnIconsDownloaded,
+                     weak_factory_.GetWeakPtr())));
+
+  // If the manifest specified icons, don't use the page icons.
+  if (!data.manifest->icons.empty())
+    favicon_downloader_->SkipPageFavicons();
+
+  favicon_downloader_->Start();
+}
+
+void BookmarkAppHelper::OnIconsDownloaded(
+    bool success,
+    const std::map<GURL, std::vector<SkBitmap>>& bitmaps) {
+  // The tab has navigated away during the icon download. Cancel the bookmark
+  // app creation.
+  if (!success) {
+    favicon_downloader_.reset();
+    callback_.Run(nullptr, web_app_info_);
+    return;
+  }
+
+  std::vector<BitmapAndSource> downloaded_icons;
+  for (const std::pair<GURL, std::vector<SkBitmap>>& url_bitmap : bitmaps) {
+    for (const SkBitmap& bitmap : url_bitmap.second) {
+      if (bitmap.empty() || bitmap.width() != bitmap.height())
+        continue;
+
+      downloaded_icons.push_back(BitmapAndSource(url_bitmap.first, bitmap));
+    }
+  }
+
+  // Add all existing icons from WebApplicationInfo.
+  for (const WebApplicationInfo::IconInfo& icon_info : web_app_info_.icons) {
+    const SkBitmap& icon = icon_info.data;
+    if (!icon.drawsNothing() && icon.width() == icon.height()) {
+      downloaded_icons.push_back(BitmapAndSource(icon_info.url, icon));
+    }
+  }
+
+  // Ensure that the necessary-sized icons are available by resizing larger
+  // icons down to smaller sizes, and generating icons for sizes where resizing
+  // is not possible.
+  web_app_info_.generated_icon_color = SK_ColorTRANSPARENT;
+  std::map<int, BitmapAndSource> size_to_icons = ResizeIconsAndGenerateMissing(
+      downloaded_icons, SizesToGenerate(), &web_app_info_);
+  ReplaceWebAppIcons(size_to_icons, &web_app_info_);
+  favicon_downloader_.reset();
+
+  if (!contents_) {
+    // The web contents can be null in tests.
+    OnBubbleCompleted(true, web_app_info_);
+    return;
+  }
+
+  Browser* browser = chrome::FindBrowserWithWebContents(contents_);
+  if (!browser) {
+    // The browser can be null in tests.
+    OnBubbleCompleted(true, web_app_info_);
+    return;
+  }
+
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing) &&
+      for_installable_site_ == ForInstallableSite::kYes) {
+    web_app_info_.open_as_window = true;
+    chrome::ShowPWAInstallDialog(
+        contents_, web_app_info_,
+        base::BindOnce(&BookmarkAppHelper::OnBubbleCompleted,
+                       weak_factory_.GetWeakPtr()));
+  } else {
+    chrome::ShowBookmarkAppDialog(
+        contents_, web_app_info_,
+        base::BindOnce(&BookmarkAppHelper::OnBubbleCompleted,
+                       weak_factory_.GetWeakPtr()));
+  }
+}
+
+void BookmarkAppHelper::OnBubbleCompleted(
+    bool user_accepted,
+    const WebApplicationInfo& web_app_info) {
+  if (user_accepted) {
+    web_app_info_ = web_app_info;
+    crx_installer_->InstallWebApp(web_app_info_);
+
+    if (InstallableMetrics::IsReportableInstallSource(install_source_) &&
+        for_installable_site_ == ForInstallableSite::kYes) {
+      InstallableMetrics::TrackInstallEvent(install_source_);
+    }
+  } else {
+    callback_.Run(nullptr, web_app_info_);
+  }
+}
+
+void BookmarkAppHelper::FinishInstallation(const Extension* extension) {
+  // Set the default 'open as' preference for use next time the dialog is
+  // shown.
+  extensions::LaunchType launch_type = web_app_info_.open_as_window
+                                           ? extensions::LAUNCH_TYPE_WINDOW
+                                           : extensions::LAUNCH_TYPE_REGULAR;
+
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {
+    DCHECK_NE(ForInstallableSite::kUnknown, for_installable_site_);
+    launch_type = for_installable_site_ == ForInstallableSite::kYes
+                      ? extensions::LAUNCH_TYPE_WINDOW
+                      : extensions::LAUNCH_TYPE_REGULAR;
+  }
+  profile_->GetPrefs()->SetInteger(
+      extensions::pref_names::kBookmarkAppCreationLaunchType, launch_type);
+
+  // Set the launcher type for the app.
+  extensions::SetLaunchType(profile_, extension->id(), launch_type);
+
+  if (!contents_) {
+    // The web contents can be null in tests.
+    callback_.Run(extension, web_app_info_);
+    return;
+  }
+
+  // Record an app banner added to homescreen event to ensure banners are not
+  // shown for this app.
+  AppBannerSettingsHelper::RecordBannerEvent(
+      contents_, web_app_info_.app_url, web_app_info_.app_url.spec(),
+      AppBannerSettingsHelper::APP_BANNER_EVENT_DID_ADD_TO_HOMESCREEN,
+      base::Time::Now());
+
+  Browser* browser = chrome::FindBrowserWithWebContents(contents_);
+  if (!browser) {
+    // The browser can be null in tests.
+    callback_.Run(extension, web_app_info_);
+    return;
+  }
+
+#if !defined(OS_CHROMEOS)
+  // Pin the app to the relevant launcher depending on the OS.
+  Profile* current_profile = profile_->GetOriginalProfile();
+#endif  // !defined(OS_CHROMEOS)
+
+// On Mac, shortcuts are automatically created for hosted apps when they are
+// installed, so there is no need to create them again.
+#if !defined(OS_MACOSX)
+#if !defined(OS_CHROMEOS)
+  web_app::ShortcutLocations creation_locations;
+#if defined(OS_LINUX) || defined(OS_WIN)
+  creation_locations.on_desktop = true;
+#else
+  creation_locations.on_desktop = false;
+#endif
+  creation_locations.applications_menu_location =
+      web_app::APP_MENU_LOCATION_SUBDIR_CHROMEAPPS;
+  creation_locations.in_quick_launch_bar = false;
+  web_app::CreateShortcuts(web_app::SHORTCUT_CREATION_BY_USER,
+                           creation_locations, current_profile, extension);
+#else
+  ChromeLauncherController::instance()->shelf_model()->PinAppWithID(
+      extension->id());
+#endif  // !defined(OS_CHROMEOS)
+
+  // Reparent the tab into an app window immediately when opening as a window.
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing) &&
+      launch_type == extensions::LAUNCH_TYPE_WINDOW &&
+      !profile_->IsOffTheRecord()) {
+    ReparentWebContentsIntoAppBrowser(contents_, extension);
+  }
+#endif  // !defined(OS_MACOSX)
+
+#if defined(OS_MACOSX)
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+                 switches::kDisableHostedAppShimCreation)) {
+    web_app::RevealAppShimInFinderForApp(current_profile, extension);
+  }
+#endif
+
+  callback_.Run(extension, web_app_info_);
+}
+
+void BookmarkAppHelper::Observe(int type,
+                                const content::NotificationSource& source,
+                                const content::NotificationDetails& details) {
+  // TODO(dominickn): bookmark app creation fails when extensions cannot be
+  // created (e.g. due to management policies). Add to shelf visibility should
+  // be gated on whether extensions can be created - see crbug.com/545541.
+  switch (type) {
+    case extensions::NOTIFICATION_CRX_INSTALLER_DONE: {
+      const Extension* extension =
+          content::Details<const Extension>(details).ptr();
+      if (extension) {
+        DCHECK_EQ(AppLaunchInfo::GetLaunchWebURL(extension),
+                  web_app_info_.app_url);
+        FinishInstallation(extension);
+      } else {
+        callback_.Run(nullptr, web_app_info_);
+      }
+      break;
+    }
+    case extensions::NOTIFICATION_EXTENSION_INSTALL_ERROR:
+      callback_.Run(nullptr, web_app_info_);
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+void CreateOrUpdateBookmarkApp(ExtensionService* service,
+                               WebApplicationInfo* web_app_info) {
+  scoped_refptr<BookmarkAppInstaller> installer(
+      new BookmarkAppInstaller(service, *web_app_info));
+  installer->Run();
+}
+
+bool IsValidBookmarkAppUrl(const GURL& url) {
+  URLPattern origin_only_pattern(Extension::kValidBookmarkAppSchemes);
+  origin_only_pattern.SetMatchAllURLs(true);
+  return url.is_valid() && origin_only_pattern.MatchesURL(url);
+}
+
+}  // namespace extensions
--- a/chrome/browser/extensions/chrome_extensions_browser_client.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_client.cc
@@ -88,13 +88,20 @@ bool ExtensionsDisabled(const base::Comm
 }  // namespace
 
 ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient() {
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 1";
   AddAPIProvider(std::make_unique<CoreExtensionsBrowserAPIProvider>());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 2";
   AddAPIProvider(std::make_unique<ChromeExtensionsBrowserAPIProvider>());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 3";
 
   process_manager_delegate_.reset(new ChromeProcessManagerDelegate);
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 4";
   api_client_.reset(new ChromeExtensionsAPIClient);
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 5";
   SetCurrentChannel(chrome::GetChannel());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 6";
   resource_manager_.reset(new ChromeComponentExtensionResourceManager());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 7";
 }
 
 ChromeExtensionsBrowserClient::~ChromeExtensionsBrowserClient() {}
--- a/chrome/browser/extensions/chrome_process_manager_delegate.cc
+++ b/chrome/browser/extensions/chrome_process_manager_delegate.cc
@@ -30,6 +30,7 @@
 namespace extensions {
 
 ChromeProcessManagerDelegate::ChromeProcessManagerDelegate() {
+  LOG(ERROR) << "[Kiwi] ChromeProcessManagerDelegate::ChromeProcessManagerDelegate - Step 1";
   BrowserList::AddObserver(this);
   DCHECK(g_browser_process);
   // The profile manager can be null in unit tests.
--- a/chrome/browser/extensions/extension_install_prompt.cc
+++ b/chrome/browser/extensions/extension_install_prompt.cc
@@ -20,6 +20,9 @@
 #include "chrome/browser/ui/extensions/extension_install_ui_factory.h"
 #include "chrome/grit/generated_resources.h"
 #include "chrome/grit/theme_resources.h"
+#include "components/app_modal/javascript_app_modal_dialog.h"
+#include "components/app_modal/javascript_dialog_manager.h"
+#include "components/app_modal/native_app_modal_dialog.h"
 #include "components/strings/grit/components_strings.h"
 #include "content/public/browser/web_contents.h"
 #include "extensions/browser/disable_reason.h"
@@ -369,6 +372,17 @@ base::string16 ExtensionInstallPrompt::P
   return base::string16();
 }
 
+base::string16 ExtensionInstallPrompt::Prompt::GetPermissionsAsString() const {
+  base::string16 result = base::string16();
+  result = result + GetDialogTitle() + base::ASCIIToUTF16("\n") + base::ASCIIToUTF16("\n");
+  result = result + GetPermissionsHeading() + base::ASCIIToUTF16("\n") + base::ASCIIToUTF16("\n");
+  result = result + base::JoinString(prompt_permissions_.permissions,
+                                     base::ASCIIToUTF16("\n")) + base::ASCIIToUTF16("\n");
+  result = result + base::JoinString(prompt_permissions_.details,
+                                     base::ASCIIToUTF16("\n"));
+  return result;
+}
+
 size_t ExtensionInstallPrompt::Prompt::GetPermissionCount() const {
   return prompt_permissions_.permissions.size();
 }
@@ -486,6 +500,7 @@ ExtensionInstallPrompt::ExtensionInstall
                    : nullptr),
       extension_(nullptr),
       install_ui_(extensions::CreateExtensionInstallUI(profile_)),
+      contents_(contents),
       show_params_(new ExtensionInstallPromptShowParams(contents)),
       did_call_show_dialog_(false) {}
 
@@ -607,6 +622,37 @@ void ExtensionInstallPrompt::LoadImageIf
                                          weak_factory_.GetWeakPtr()));
 }
 
+// Ensures that OnDialogClosed is only called once.
+class CloseDialogCallbackWrapper
+    : public base::RefCountedThreadSafe<CloseDialogCallbackWrapper> {
+ public:
+  explicit CloseDialogCallbackWrapper(ExtensionInstallPrompt::DoneCallback callback)
+      : callback_(std::move(callback)) {}
+
+  void Run(bool dialog_was_suppressed,
+           bool success,
+           const base::string16& user_input) {
+  if (success) {
+    LOG(INFO) << "[EXTENSIONS] We received result from extension dialog (ACCEPTED)";
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+         FROM_HERE, base::BindOnce(std::move(callback_),
+                                  ExtensionInstallPrompt::Result::ACCEPTED));
+  } else {
+    LOG(INFO) << "[EXTENSIONS] We received result from extension dialog (REJECTED)";
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+         FROM_HERE,
+         base::BindOnce(std::move(callback_),
+                        ExtensionInstallPrompt::Result::USER_CANCELED));
+  }
+  }
+
+ private:
+  friend class base::RefCountedThreadSafe<CloseDialogCallbackWrapper>;
+  ~CloseDialogCallbackWrapper() {}
+
+  ExtensionInstallPrompt::DoneCallback callback_;
+};
+
 void ExtensionInstallPrompt::ShowConfirmation() {
   std::unique_ptr<const PermissionSet> permissions_to_display;
 
@@ -641,6 +687,23 @@ void ExtensionInstallPrompt::ShowConfirm
   if (AutoConfirmPromptIfEnabled())
     return;
 
+  if (contents_) {
+    LOG(INFO) << "[EXTENSIONS] contents_ is not empty, displaying prompt";
+    scoped_refptr<CloseDialogCallbackWrapper> wrapper = new CloseDialogCallbackWrapper(std::move(done_callback_));
+
+    if (permissions_to_display) {
+      bool ignored;
+      app_modal::JavaScriptDialogManager::GetInstance()->RunJavaScriptDialog(
+          contents_, contents_->GetMainFrame(), content::JAVASCRIPT_DIALOG_TYPE_CONFIRM,
+          prompt_->GetPermissionsAsString(), base::string16(),
+                   base::BindOnce(&CloseDialogCallbackWrapper::Run, wrapper, false),
+                   &ignored);
+    }
+  } else {
+    LOG(INFO) << "[EXTENSIONS] contents_ is empty, skipping prompt";
+  }
+
+#if 0
   if (show_dialog_callback_.is_null())
     show_dialog_callback_ = GetDefaultShowDialogCallback();
   // TODO(https://crbug.com/957713): Use OnceCallback and eliminate the need for
@@ -648,6 +711,7 @@ void ExtensionInstallPrompt::ShowConfirm
   auto cb = std::move(done_callback_);
   std::move(show_dialog_callback_)
       .Run(show_params_.get(), cb, std::move(prompt_));
+#endif
 }
 
 bool ExtensionInstallPrompt::AutoConfirmPromptIfEnabled() {
--- a/chrome/browser/extensions/extension_install_prompt.h
+++ b/chrome/browser/extensions/extension_install_prompt.h
@@ -19,6 +19,7 @@
 #include "base/strings/string16.h"
 #include "base/threading/thread_checker.h"
 #include "build/build_config.h"
+#include "components/app_modal/javascript_app_modal_dialog.h"
 #include "chrome/browser/extensions/install_prompt_permissions.h"
 #include "extensions/common/permissions/permission_message.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -127,6 +128,7 @@ class ExtensionInstallPrompt {
     void AppendRatingStars(StarAppender appender, void* data) const;
     base::string16 GetRatingCount() const;
     base::string16 GetUserCount() const;
+    base::string16 GetPermissionsAsString() const;
     size_t GetPermissionCount() const;
     size_t GetPermissionsDetailsCount() const;
     base::string16 GetPermission(size_t index) const;
@@ -345,6 +347,8 @@ class ExtensionInstallPrompt {
   // The object responsible for doing the UI specific actions.
   std::unique_ptr<extensions::ExtensionInstallUI> install_ui_;
 
+  content::WebContents* contents_;
+
   // Parameters to show the confirmation UI.
   std::unique_ptr<ExtensionInstallPromptShowParams> show_params_;
 
--- a/chrome/browser/extensions/extension_install_prompt_show_params.cc
+++ b/chrome/browser/extensions/extension_install_prompt_show_params.cc
@@ -53,8 +53,6 @@ ExtensionInstallPromptShowParams::Extens
     web_contents_destruction_observer_.reset(
         new WebContentsDestructionObserver(this));
   }
-  if (parent_window_)
-    native_window_tracker_ = NativeWindowTracker::Create(parent_window_);
 }
 
 ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
@@ -64,8 +62,6 @@ ExtensionInstallPromptShowParams::Extens
     parent_web_contents_(nullptr),
     parent_web_contents_destroyed_(false),
     parent_window_(parent_window) {
-  if (parent_window_)
-    native_window_tracker_ = NativeWindowTracker::Create(parent_window_);
 }
 
 ExtensionInstallPromptShowParams::~ExtensionInstallPromptShowParams() {
--- a/chrome/browser/extensions/extension_uninstall_dialog.cc
+++ b/chrome/browser/extensions/extension_uninstall_dialog.cc
@@ -73,8 +73,10 @@ ExtensionUninstallDialog::ExtensionUnins
     gfx::NativeWindow parent,
     ExtensionUninstallDialog::Delegate* delegate)
     : profile_(profile), parent_(parent), delegate_(delegate) {
+#if 0
   if (parent)
     parent_window_tracker_ = NativeWindowTracker::Create(parent);
+#endif
 }
 
 ExtensionUninstallDialog::~ExtensionUninstallDialog() = default;
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.cc
@@ -0,0 +1,64 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/global_shortcut_listener_android.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace extensions {
+
+// static
+GlobalShortcutListener* GlobalShortcutListener::GetInstance() {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+  static GlobalShortcutListenerAndroid* instance =
+      new GlobalShortcutListenerAndroid();
+  return instance;
+}
+
+GlobalShortcutListenerAndroid::GlobalShortcutListenerAndroid()
+    : is_listening_(false) {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // TODO(implementor): Remove this.
+  LOG(ERROR) << "GlobalShortcutListenerAndroid object created";
+}
+
+GlobalShortcutListenerAndroid::~GlobalShortcutListenerAndroid() {
+  if (is_listening_)
+    StopListening();
+}
+
+void GlobalShortcutListenerAndroid::StartListening() {
+  DCHECK(!is_listening_);  // Don't start twice.
+  NOTIMPLEMENTED();
+  is_listening_ = true;
+}
+
+void GlobalShortcutListenerAndroid::StopListening() {
+  DCHECK(is_listening_);  // No point if we are not already listening.
+  NOTIMPLEMENTED();
+  is_listening_ = false;
+}
+
+bool GlobalShortcutListenerAndroid::RegisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  NOTIMPLEMENTED();
+  // To implement:
+  // 1) Convert modifiers to platform specific modifiers.
+  // 2) Register for the hotkey.
+  // 3) If not successful, return false.
+  // 4) Else, return true.
+
+  return false;
+}
+
+void GlobalShortcutListenerAndroid::UnregisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  NOTIMPLEMENTED();
+  // To implement: Unregister for the hotkey.
+}
+
+}  // namespace extensions
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.h
@@ -0,0 +1,36 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/extensions/global_shortcut_listener.h"
+
+namespace extensions {
+
+// Android-specific implementation of the GlobalShortcutListener class that
+// listens for global shortcuts. Handles basic keyboard intercepting and
+// forwards its output to the base class for processing.
+class GlobalShortcutListenerAndroid : public GlobalShortcutListener {
+ public:
+  GlobalShortcutListenerAndroid();
+  ~GlobalShortcutListenerAndroid() override;
+
+ private:
+  // GlobalShortcutListener implementation.
+  void StartListening() override;
+  void StopListening() override;
+  bool RegisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+  void UnregisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+
+  // Whether this object is listening for global shortcuts.
+  bool is_listening_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcutListenerAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.cc
@@ -0,0 +1,17 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/system_display/display_info_provider_android.h"
+
+namespace extensions {
+
+DisplayInfoProviderAndroid::DisplayInfoProviderAndroid() = default;
+
+// static
+std::unique_ptr<DisplayInfoProvider> CreateChromeDisplayInfoProvider() {
+  return std::make_unique<DisplayInfoProviderAndroid>();
+}
+
+}  // namespace extensions
+
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.h
@@ -0,0 +1,24 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
+#include "base/macros.h"
+#include "extensions/browser/api/system_display/display_info_provider.h"
+
+namespace extensions {
+
+class DisplayInfoProviderAndroid : public DisplayInfoProvider {
+ public:
+  DisplayInfoProviderAndroid();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DisplayInfoProviderAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
--- a/chrome/browser/first_run/first_run_dialog.h
+++ b/chrome/browser/first_run/first_run_dialog.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 
 // Hide this function on platforms where the dialog does not exist.
-#if defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if true || defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 
 class Profile;
 
--- a/chrome/browser/first_run/upgrade_util.h
+++ b/chrome/browser/first_run/upgrade_util.h
@@ -10,10 +10,6 @@
 #include "base/callback_forward.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
-#error Not used on Android or ChromeOS
-#endif
-
 namespace base {
 class CommandLine;
 }
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2739,8 +2739,6 @@ const char kAndroidNightModeTabReparenti
 
 // Non-Android -----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
-
 const char kAppManagementName[] = "Enable App Management page";
 const char kAppManagementDescription[] =
     "Shows the new app management page at chrome://apps.";
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1581,8 +1581,6 @@ extern const char kAndroidNightModeTabRe
 
 // Non-Android ----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
-
 extern const char kAppManagementName[];
 extern const char kAppManagementDescription[];
 
--- a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
+++ b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
@@ -87,10 +87,12 @@ void ChromeWebViewPermissionHelperDelega
     const std::string& identifier,
     bool allow,
     const std::string& input) {
+#if 0
   if (allow) {
     ChromePluginServiceFilter::GetInstance()->AuthorizeAllPlugins(
         web_contents(), true, identifier);
   }
+#endif
 }
 
 #endif  // BUILDFLAG(ENABLE_PLUGINS)
--- a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
+++ b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
@@ -14,7 +14,7 @@
 #include "ppapi/buildflags/buildflags.h"
 #include "third_party/blink/public/mojom/permissions/permission_status.mojom-forward.h"
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 #include "chrome/common/plugin.mojom.h"
 #endif
 
@@ -51,7 +51,7 @@ class ChromeWebViewPermissionHelperDeleg
       const GURL& url,
       bool allowed_by_default,
       base::OnceCallback<void(bool)> callback) override;
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
   // content::WebContentsObserver implementation.
   bool OnMessageReceived(const IPC::Message& message,
                          content::RenderFrameHost* render_frame_host) override;
--- a/chrome/browser/media/router/BUILD.gn
+++ b/chrome/browser/media/router/BUILD.gn
@@ -213,7 +213,7 @@ static_library("test_support") {
     "test/test_helper.h",
   ]
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     deps += [
       "discovery",
       "//chrome/common/media_router/mojom:media_router",
--- a/chrome/browser/media/router/discovery/BUILD.gn
+++ b/chrome/browser/media/router/discovery/BUILD.gn
@@ -2,8 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android)
-
 static_library("discovery") {
   inputs = [ "$root_gen_dir/chrome/grit/generated_resources.h" ]
   deps = [
@@ -75,7 +73,7 @@ static_library("discovery") {
     sources += [ "discovery_network_list_wifi_linux.cc" ]
   }
 
-  if (is_posix) {
+  if (false && is_posix) {
     sources += [ "discovery_network_list_posix.cc" ]
   }
 
--- a/chrome/browser/media/router/media_router.h
+++ b/chrome/browser/media/router/media_router.h
@@ -27,7 +27,7 @@
 #include "media/base/flinging_controller.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
@@ -198,7 +198,7 @@ class MediaRouter : public KeyedService
   virtual std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) = 0;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Binds |controller| for sending media commands to a route. The controller
   // will notify |observer| whenever there is a change to the status of the
   // media. It may invalidate bindings from previous calls to this method.
--- a/chrome/browser/media/router/media_router_base.cc
+++ b/chrome/browser/media/router/media_router_base.cc
@@ -88,7 +88,7 @@ MediaRouterBase::GetFlingingController(c
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void MediaRouterBase::GetMediaController(
     const MediaRoute::Id& route_id,
     mojo::PendingReceiver<mojom::MediaController> controller,
--- a/chrome/browser/media/router/media_router_base.h
+++ b/chrome/browser/media/router/media_router_base.h
@@ -19,7 +19,7 @@
 #include "chrome/common/media_router/media_route.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
@@ -42,7 +42,7 @@ class MediaRouterBase : public MediaRout
   std::vector<MediaRoute> GetCurrentRoutes() const override;
   std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   void GetMediaController(
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
--- a/chrome/browser/media/router/media_router_feature.cc
+++ b/chrome/browser/media/router/media_router_feature.cc
@@ -23,13 +23,13 @@
 #include "components/user_prefs/user_prefs.h"
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "components/prefs/pref_registry_simple.h"
 #endif
 
 namespace media_router {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Controls if browser side DialMediaRouteProvider is enabled.
 const base::Feature kDialMediaRouteProvider{"DialMediaRouteProvider",
                                             base::FEATURE_ENABLED_BY_DEFAULT};
@@ -66,7 +66,7 @@ bool MediaRouterEnabled(content::Browser
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kMediaRouterCastAllowAllIPs, false,
                                 PrefRegistry::PUBLIC);
--- a/chrome/browser/media/router/media_router_feature.h
+++ b/chrome/browser/media/router/media_router_feature.h
@@ -19,7 +19,7 @@ namespace media_router {
 // Returns true if Media Router is enabled for |context|.
 bool MediaRouterEnabled(content::BrowserContext* context);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 // TODO(crbug.com/1028753): Remove default-enabled kDialMediaRouteProvider after
 // tests stop disabling it.
--- a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
+++ b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
@@ -114,13 +114,6 @@ MediaCaptureDevicesDispatcher::MediaCapt
 #endif
   media_access_handlers_.push_back(
       std::make_unique<DesktopCaptureAccessHandler>());
-#if defined(OS_CHROMEOS)
-  // Wrapper around TabCaptureAccessHandler used in Public Sessions.
-  media_access_handlers_.push_back(
-      std::make_unique<PublicSessionTabCaptureAccessHandler>());
-#else
-  media_access_handlers_.push_back(std::make_unique<TabCaptureAccessHandler>());
-#endif
 #endif
   media_access_handlers_.push_back(
       std::make_unique<PermissionBubbleMediaAccessHandler>());
--- a/chrome/browser/metrics/chrome_feature_list_creator.cc
+++ b/chrome/browser/metrics/chrome_feature_list_creator.cc
@@ -55,11 +55,17 @@ ChromeFeatureListCreator::ChromeFeatureL
 ChromeFeatureListCreator::~ChromeFeatureListCreator() = default;
 
 void ChromeFeatureListCreator::CreateFeatureList() {
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 1";
   CreatePrefService();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 2";
   ConvertFlagsToSwitches();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 3";
   CreateMetricsServices();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 4";
   SetupMasterPrefs();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 5";
   SetupFieldTrials();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 6";
 }
 
 void ChromeFeatureListCreator::SetApplicationLocale(const std::string& locale) {
--- a/chrome/browser/notifications/notification_display_service_impl.cc
+++ b/chrome/browser/notifications/notification_display_service_impl.cc
@@ -258,24 +258,6 @@ void NotificationDisplayServiceImpl::Dis
 void NotificationDisplayServiceImpl::Close(
     NotificationHandler::Type notification_type,
     const std::string& notification_id) {
-  CHECK(profile_ || notification_type == NotificationHandler::Type::TRANSIENT);
-
-  if (!bridge_initialized_) {
-    actions_.push(base::BindOnce(&NotificationDisplayServiceImpl::Close,
-                                 weak_factory_.GetWeakPtr(), notification_type,
-                                 notification_id));
-    return;
-  }
-
-#if BUILDFLAG(ENABLE_NATIVE_NOTIFICATIONS)
-  NotificationPlatformBridge* bridge =
-      NotificationPlatformBridge::CanHandleType(notification_type)
-          ? bridge_
-          : message_center_bridge_.get();
-  DCHECK(bridge);
-
-  bridge->Close(profile_, notification_id);
-#endif
 }
 
 void NotificationDisplayServiceImpl::GetDisplayed(
--- /dev/null
+++ b/chrome/browser/obsolete_system/obsolete_system_android.cc
@@ -0,0 +1,25 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/obsolete_system/obsolete_system.h"
+
+// static
+bool ObsoleteSystem::IsObsoleteNowOrSoon() {
+  return false;
+}
+
+// static
+base::string16 ObsoleteSystem::LocalizedObsoleteString() {
+  return base::string16();
+}
+
+// static
+bool ObsoleteSystem::IsEndOfTheLine() {
+  return false;
+}
+
+// static
+const char* ObsoleteSystem::GetLinkURL() {
+  return "";
+}
--- a/chrome/browser/permissions/attestation_permission_request.cc
+++ b/chrome/browser/permissions/attestation_permission_request.cc
@@ -26,7 +26,17 @@ class AttestationPermissionRequest : pub
       : origin_(origin), callback_(std::move(callback)) {}
 
   permissions::PermissionRequest::IconId GetIconId() const override {
-    return kUsbSecurityKeyIcon;
+    return 0;
+  }
+
+  base::string16 GetTitleText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
+  }
+
+  base::string16 GetMessageText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
   }
 
   base::string16 GetMessageTextFragment() const override {
--- a/chrome/browser/platform_util.cc
+++ b/chrome/browser/platform_util.cc
@@ -21,30 +21,6 @@ namespace {
 
 bool shell_operations_allowed = true;
 
-void VerifyAndOpenItemOnBlockingThread(const base::FilePath& path,
-                                       OpenItemType type,
-                                       const OpenOperationCallback& callback) {
-  base::File target_item(path, base::File::FLAG_OPEN | base::File::FLAG_READ);
-  if (!base::PathExists(path)) {
-    if (!callback.is_null())
-      base::PostTask(FROM_HERE, {BrowserThread::UI},
-                     base::BindOnce(callback, OPEN_FAILED_PATH_NOT_FOUND));
-    return;
-  }
-  if (base::DirectoryExists(path) != (type == OPEN_FOLDER)) {
-    if (!callback.is_null())
-      base::PostTask(FROM_HERE, {BrowserThread::UI},
-                     base::BindOnce(callback, OPEN_FAILED_INVALID_TYPE));
-    return;
-  }
-
-  if (shell_operations_allowed)
-    internal::PlatformOpenVerifiedItem(path, type);
-  if (!callback.is_null())
-    base::PostTask(FROM_HERE, {BrowserThread::UI},
-                   base::BindOnce(callback, OPEN_SUCCEEDED));
-}
-
 }  // namespace
 
 namespace internal {
@@ -55,24 +31,6 @@ void DisableShellOperationsForTesting()
 
 }  // namespace internal
 
-void OpenItem(Profile* profile,
-              const base::FilePath& full_path,
-              OpenItemType item_type,
-              const OpenOperationCallback& callback) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  // TaskPriority::USER_BLOCKING because this is usually opened as a result of a
-  // user action (e.g. open-downloaded-file or show-item-in-folder).
-  // TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN because this doesn't need global
-  // state and can hang shutdown without this trait as it may result in an
-  // interactive dialog.
-  base::PostTask(
-      FROM_HERE,
-      {base::ThreadPool(), base::MayBlock(), base::TaskPriority::USER_BLOCKING,
-       base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
-      base::BindOnce(&VerifyAndOpenItemOnBlockingThread, full_path, item_type,
-                     callback));
-}
-
 bool IsBrowserLockedFullscreen(const Browser* browser) {
   return false;
 }
--- a/chrome/browser/platform_util_android.cc
+++ b/chrome/browser/platform_util_android.cc
@@ -55,6 +55,10 @@ void ActivateWindow(gfx::NativeWindow wi
   NOTIMPLEMENTED();
 }
 
+gfx::NativeView GetViewForWindow(gfx::NativeWindow window) {
+  return nullptr;
+}
+
 bool IsVisible(gfx::NativeView view) {
   NOTIMPLEMENTED();
   return true;
--- a/chrome/browser/plugins/plugins_resource_service.cc
+++ b/chrome/browser/plugins/plugins_resource_service.cc
@@ -64,7 +64,7 @@ GURL GetPluginsServerURL() {
 #elif defined(OS_MACOSX)
   filename = "plugins_mac.json";
 #else
-#error Unknown platform
+  filename = "plugins_linux.json";
 #endif
 
   return GURL("about:blank");
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.cc
@@ -0,0 +1,191 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/policy/browser_dm_token_storage_android.h"
+
+#include <string>
+
+#include "base/base64url.h"
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/callback.h"
+#include "base/files/file_util.h"
+#include "base/files/important_file_writer.h"
+#include "base/hash/sha1.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/syslog_logging.h"
+#include "base/task/post_task.h"
+#include "base/task/task_traits.h"
+#include "base/task_runner_util.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/sequenced_task_runner_handle.h"
+#include "chrome/common/chrome_paths.h"
+
+namespace policy {
+
+namespace {
+
+const char kDmTokenBaseDir[] = FILE_PATH_LITERAL("Policy/Enrollment/");
+const char kEnrollmentTokenFilename[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentToken");
+// TODO(crbug.com/907589) : Remove once no longer in use.
+const char kEnrollmentTokenOldFilename[] =
+    FILE_PATH_LITERAL("enrollment/enrollment_token");
+const char kMachineIdFilename[] = FILE_PATH_LITERAL("/etc/machine-id");
+
+// Enrollment Mandatory Option.
+const char kEnrollmentOptionsFilePath[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentOptions");
+const char kEnrollmentMandatoryOption[] = "Mandatory";
+
+bool GetDmTokenFilePath(base::FilePath* token_file_path,
+                        const std::string& client_id,
+                        bool create_dir) {
+  if (!base::PathService::Get(chrome::DIR_USER_DATA, token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(kDmTokenBaseDir);
+
+  if (create_dir && !base::CreateDirectory(*token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(client_id);
+
+  return true;
+}
+
+bool StoreDMTokenInUserDataDir(const std::string& token,
+                               const std::string& client_id) {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, client_id, true)) {
+    NOTREACHED();
+    return false;
+  }
+
+  return base::ImportantFileWriter::WriteFileAtomically(token_file_path, token);
+}
+
+}  // namespace
+
+// static
+BrowserDMTokenStorage* BrowserDMTokenStorage::Get() {
+  if (storage_for_testing_)
+    return storage_for_testing_;
+
+  static base::NoDestructor<BrowserDMTokenStorageAndroid> storage;
+  return storage.get();
+}
+
+BrowserDMTokenStorageAndroid::BrowserDMTokenStorageAndroid()
+    : task_runner_(
+          base::CreateTaskRunner({base::ThreadPool(), base::MayBlock()})) {}
+
+BrowserDMTokenStorageAndroid::~BrowserDMTokenStorageAndroid() {}
+
+std::string BrowserDMTokenStorageAndroid::InitClientId() {
+  // The client ID is derived from /etc/machine-id
+  // (https://www.freedesktop.org/software/systemd/man/machine-id.html). As per
+  // guidelines, this ID must not be transmitted outside of the machine, which
+  // is why we hash it first and then encode it in base64 before transmitting
+  // it.
+  const int machine_id_size = 32;
+  std::string machine_id;
+  machine_id = ReadMachineIdFile();
+  base::StringPiece machine_id_trimmed =
+      base::TrimWhitespaceASCII(machine_id, base::TRIM_TRAILING);
+  if (machine_id_trimmed.size() != machine_id_size) {
+    SYSLOG(ERROR) << "Error: /etc/machine-id contains "
+                  << machine_id_trimmed.size() << " characters ("
+                  << machine_id_size << " were expected).";
+    return std::string();
+  }
+
+  std::string machine_id_base64;
+  base::Base64UrlEncode(base::SHA1HashString(std::string(machine_id_trimmed)),
+                        base::Base64UrlEncodePolicy::OMIT_PADDING,
+                        &machine_id_base64);
+  return machine_id_base64;
+}
+
+std::string BrowserDMTokenStorageAndroid::InitEnrollmentToken() {
+  std::string enrollment_token;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return std::string();
+  }
+
+  base::FilePath token_file_path =
+      dir_policy_files_path.Append(kEnrollmentTokenFilename);
+
+  // Read the enrollment token from the new location. If that fails, try the old
+  // location (which will be deprecated soon). If that also fails, bail as there
+  // is no token set.
+  if (!base::ReadFileToString(token_file_path, &enrollment_token)) {
+    // TODO(crbug.com/907589) : Remove once no longer in use.
+    token_file_path = dir_policy_files_path.Append(kEnrollmentTokenOldFilename);
+    if (!base::ReadFileToString(token_file_path, &enrollment_token))
+      return std::string();
+  }
+
+  return base::TrimWhitespaceASCII(enrollment_token, base::TRIM_ALL)
+      .as_string();
+}
+
+std::string BrowserDMTokenStorageAndroid::InitDMToken() {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, RetrieveClientId(), false))
+    return std::string();
+
+  std::string token;
+  if (!base::ReadFileToString(token_file_path, &token))
+    return std::string();
+
+  return base::TrimWhitespaceASCII(token, base::TRIM_ALL).as_string();
+}
+
+bool BrowserDMTokenStorageAndroid::InitEnrollmentErrorOption() {
+  std::string options;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return false;
+  }
+
+  base::FilePath options_file_path =
+      dir_policy_files_path.Append(kEnrollmentOptionsFilePath);
+
+  if (!base::ReadFileToString(options_file_path, &options))
+    return false;
+
+  return base::TrimWhitespaceASCII(options, base::TRIM_ALL).as_string() ==
+         kEnrollmentMandatoryOption;
+}
+
+BrowserDMTokenStorage::StoreTask BrowserDMTokenStorageAndroid::SaveDMTokenTask(
+    const std::string& token,
+    const std::string& client_id) {
+  return base::BindOnce(&StoreDMTokenInUserDataDir, token, client_id);
+}
+
+scoped_refptr<base::TaskRunner>
+BrowserDMTokenStorageAndroid::SaveDMTokenTaskRunner() {
+  return task_runner_;
+}
+
+std::string BrowserDMTokenStorageAndroid::ReadMachineIdFile() {
+  std::string machine_id;
+  if (!base::ReadFileToString(base::FilePath(kMachineIdFilename), &machine_id))
+    return std::string();
+  return machine_id;
+}
+
+}  // namespace policy
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.h
@@ -0,0 +1,58 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+
+#include "chrome/browser/policy/browser_dm_token_storage.h"
+
+#include <string>
+
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/sequence_checker.h"
+#include "base/single_thread_task_runner.h"
+
+namespace policy {
+
+// Implementation of BrowserDMTokenStorage for Android. The global singleton
+// instance can be retrieved by calling BrowserDMTokenStorage::Get().
+class BrowserDMTokenStorageAndroid : public BrowserDMTokenStorage {
+ public:
+  // Get the global singleton instance by calling BrowserDMTokenStorage::Get().
+  BrowserDMTokenStorageAndroid();
+  ~BrowserDMTokenStorageAndroid() override;
+
+ private:
+  // override BrowserDMTokenStorage
+  std::string InitClientId() override;
+  std::string InitEnrollmentToken() override;
+  std::string InitDMToken() override;
+  bool InitEnrollmentErrorOption() override;
+  StoreTask SaveDMTokenTask(const std::string& token,
+                            const std::string& client_id) override;
+  scoped_refptr<base::TaskRunner> SaveDMTokenTaskRunner() override;
+
+  // Returns the content of "/etc/machine-id". Virtual for tests.
+  virtual std::string ReadMachineIdFile();
+
+  scoped_refptr<base::TaskRunner> task_runner_;
+
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitClientId);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitEnrollmentToken);
+  // TODO(crbug.com/907589): Remove once no longer in use.
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitOldEnrollmentToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitDMToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitDMTokenWithoutDirectory);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, SaveDMToken);
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageAndroid);
+};
+
+}  // namespace policy
+#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
--- a/chrome/browser/policy/chrome_browser_policy_connector.cc
+++ b/chrome/browser/policy/chrome_browser_policy_connector.cc
@@ -47,7 +47,7 @@
 #include "components/policy/core/browser/android/android_combined_policy_provider.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 #include "chrome/browser/policy/chrome_browser_cloud_management_controller.h"
 #include "components/policy/core/common/cloud/machine_level_user_cloud_policy_manager.h"
 #endif
--- a/chrome/browser/policy/configuration_policy_handler_list_factory.cc
+++ b/chrome/browser/policy/configuration_policy_handler_list_factory.cc
@@ -1059,7 +1059,7 @@ const PolicyToPreferenceMapEntry kSimple
     base::Value::Type::BOOLEAN },
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   { key::kRelaunchNotification,
     prefs::kRelaunchNotification,
     base::Value::Type::INTEGER },
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -218,7 +218,6 @@
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
 #include "components/feed/core/common/pref_names.h"
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
 #include "chrome/browser/apps/app_service/app_service_proxy.h"
 #include "chrome/browser/enterprise_reporting/prefs.h"
 #include "chrome/browser/gcm/gcm_product_util.h"
@@ -358,12 +357,12 @@
 #include "components/os_crypt/os_crypt.h"
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || \
+#if true || defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 #include "chrome/browser/browser_switcher/browser_switcher_prefs.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/ui/startup/default_browser_prompt.h"
 #endif
 
@@ -447,7 +446,7 @@ const char kContentSuggestionsNotificati
 
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Deprecated 5/2019
 const char kSignInPromoShowOnFirstRunAllowed[] =
     "sync_promo.show_on_first_run_allowed";
@@ -469,7 +468,7 @@ const char kHasSeenWin10PromoPage[] = "b
 // Deprecated 7/2019
 const char kSignedInTime[] = "signin.signedin_time";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Deprecated 7/2019
 const char kNtpActivateHideShortcutsFieldTrial[] =
     "ntp.activate_hide_shortcuts_field_trial";
@@ -579,7 +578,7 @@ void RegisterProfilePrefsForMigration(
   registry->RegisterBooleanPref(kContentSuggestionsNotificationsEnabled, true);
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(kSignInPromoShowOnFirstRunAllowed, true);
   registry->RegisterBooleanPref(kSignInPromoShowNTPBubble, false);
 #endif  // !defined(OS_ANDROID)
@@ -671,9 +670,7 @@ void RegisterLocalState(PrefRegistrySimp
 
 #if defined(OS_ANDROID)
   ::android::RegisterPrefs(registry);
-#else
   enterprise_reporting::RegisterLocalStatePrefs(registry);
-  gcm::RegisterPrefs(registry);
   media_router::RegisterLocalStatePrefs(registry);
   metrics::TabStatsTracker::RegisterPrefs(registry);
   RegisterBrowserPrefs(registry);
@@ -777,7 +774,7 @@ void RegisterLocalState(PrefRegistrySimp
 
   // Obsolete. See MigrateObsoleteBrowserPrefs().
   registry->RegisterIntegerPref(metrics::prefs::kStabilityExecutionPhase, 0);
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(kNtpActivateHideShortcutsFieldTrial, false);
 #endif  // !defined(OS_ANDROID)
   registry->RegisterInt64Pref(kLastStartupTimestamp, 0);
@@ -797,6 +794,7 @@ void RegisterLocalState(PrefRegistrySimp
 // Register prefs applicable to all profiles.
 void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
                           const std::string& locale) {
+  LOG(ERROR) << "[Kiwi] prefs/browser_prefs.cc::RegisterProfilePrefs - Step 1";
   TRACE_EVENT0("browser", "chrome::RegisterProfilePrefs");
   // User prefs. Please keep this list alphabetized.
   AccessibilityLabelsService::RegisterProfilePrefs(registry);
@@ -890,8 +888,10 @@ void RegisterProfilePrefs(user_prefs::Pr
 #endif
 
 #if BUILDFLAG(ENABLE_PLUGINS)
+  #if 0
   DeviceIDFetcher::RegisterProfilePrefs(registry);
   PepperFlashSettingsManager::RegisterProfilePrefs(registry);
+  #endif
   PluginInfoHostImpl::RegisterUserPrefs(registry);
 #endif
 
@@ -932,7 +932,6 @@ void RegisterProfilePrefs(user_prefs::Pr
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
   feed::RegisterProfilePrefs(registry);
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
   apps::AppServiceProxy::RegisterProfilePrefs(registry);
   AppShortcutManager::RegisterProfilePrefs(registry);
   browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
@@ -1023,11 +1022,11 @@ void RegisterProfilePrefs(user_prefs::Pr
   browser_switcher::BrowserSwitcherPrefs::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   default_apps::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_CHROMEOS) && BUILDFLAG(ENABLE_EXTENSIONS)
+#if true || !defined(OS_CHROMEOS) && BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::enterprise_reporting::RegisterProfilePrefs(registry);
 #endif
 
@@ -1037,6 +1036,7 @@ void RegisterProfilePrefs(user_prefs::Pr
 #endif
 
   RegisterProfilePrefsForMigration(registry);
+  LOG(ERROR) << "[Kiwi] prefs/browser_prefs.cc::RegisterProfilePrefs - Step 2";
 }
 
 void RegisterUserProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
@@ -1092,7 +1092,7 @@ void MigrateObsoleteBrowserPrefs(Profile
   local_state->ClearPref(kHasSeenWin10PromoPage);
 #endif  // defined(OS_WIN)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Added 7/2019.
   local_state->ClearPref(kNtpActivateHideShortcutsFieldTrial);
 #endif  // !defined(OS_ANDROID)
@@ -1198,7 +1198,7 @@ void MigrateObsoleteProfilePrefs(Profile
   profile_prefs->ClearPref(kContentSuggestionsNotificationsEnabled);
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Deprecated 5/2019
   profile_prefs->ClearPref(kSignInPromoShowOnFirstRunAllowed);
   profile_prefs->ClearPref(kSignInPromoShowNTPBubble);
--- a/chrome/browser/prefs/chrome_pref_service_factory.cc
+++ b/chrome/browser/prefs/chrome_pref_service_factory.cc
@@ -120,7 +120,7 @@ const prefs::TrackedPreferenceMetadata k
 #endif
     {7, prefs::kSearchProviderOverrides, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     {11, prefs::kPinnedTabs, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #endif
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -100,7 +100,7 @@
 #include "chrome/browser/android/explore_sites/explore_sites_service_factory.h"
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
 #include "chrome/browser/media/android/cdm/media_drm_origin_id_manager_factory.h"
-#else
+
 #include "chrome/browser/apps/app_service/app_service_proxy_factory.h"
 #include "chrome/browser/feedback/feedback_uploader_factory_chrome.h"
 #include "chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.h"
@@ -191,14 +191,18 @@ ChromeBrowserMainExtraPartsProfiles::~Ch
 //
 // static
 void ChromeBrowserMainExtraPartsProfiles::
-    EnsureBrowserContextKeyedServiceFactoriesBuilt() {
+    EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init) {
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 1";
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   extensions::ExtensionManagementFactory::GetInstance();
   chrome_extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_apps::api::EnsureAPIBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 8";
+  }
 #endif
 
 #if defined(OS_CHROMEOS)
@@ -214,7 +218,10 @@ void ChromeBrowserMainExtraPartsProfiles
   AccountInvestigatorFactory::GetInstance();
   AccountReconcilorFactory::GetInstance();
   AdaptiveQuietNotificationPermissionUiEnabler::Factory::GetInstance();
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 16";
+  if (full_init)
   AutocompleteClassifierFactory::GetInstance();
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 17";
   autofill::PersonalDataManagerFactory::GetInstance();
 #if BUILDFLAG(ENABLE_BACKGROUND_CONTENTS)
   BackgroundContentsServiceFactory::GetInstance();
@@ -226,6 +233,8 @@ void ChromeBrowserMainExtraPartsProfiles
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 25";
+  if (full_init)
   ChromeBrowsingDataRemoverDelegateFactory::GetInstance();
   ChromeSigninClientFactory::GetInstance();
   ClientHintsFactory::GetInstance();
@@ -244,7 +253,10 @@ void ChromeBrowserMainExtraPartsProfiles
   explore_sites::ExploreSitesServiceFactory::GetInstance();
 #endif
   FaviconServiceFactory::GetInstance();
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 41";
+  if (full_init)
   HistoryUiFaviconRequestHandlerFactory::GetInstance();
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 42";
 #if BUILDFLAG(ENABLE_LEGACY_DESKTOP_IN_PRODUCT_HELP)
   feature_engagement::BookmarkTrackerFactory::GetInstance();
   feature_engagement::IncognitoWindowTrackerFactory::GetInstance();
@@ -265,14 +277,17 @@ void ChromeBrowserMainExtraPartsProfiles
   IdentityManagerFactory::EnsureFactoryAndDependeeFactoriesBuilt();
   InMemoryURLIndexFactory::GetInstance();
   invalidation::DeprecatedProfileInvalidationProviderFactory::GetInstance();
-#if !defined(OS_ANDROID)
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-5";
+#if true || !defined(OS_ANDROID)
   InstantServiceFactory::GetInstance();
 #endif
 #if BUILDFLAG(ENABLE_SERVICE_DISCOVERY)
   cloud_print::PrivetNotificationServiceFactory::GetInstance();
 #endif
   RendererUpdaterFactory::GetInstance();
+  LOG(DEBUG) << "[Kiwi-patch] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 48";
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  if (full_init)
   SupervisedUserServiceFactory::GetInstance();
 #endif
   LanguageModelManagerFactory::GetInstance();
@@ -302,10 +317,11 @@ void ChromeBrowserMainExtraPartsProfiles
   NTPResourceCacheFactory::GetInstance();
 #endif
   PasswordStoreFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   PinnedTabServiceFactory::GetInstance();
   ThemeServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 55";
 #if BUILDFLAG(ENABLE_PLUGINS)
   PluginPrefsFactory::GetInstance();
 #endif
@@ -313,34 +329,59 @@ void ChromeBrowserMainExtraPartsProfiles
 #if !defined(OS_CHROMEOS)
   policy::UserPolicySigninServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58";
   policy::UserCloudPolicyInvalidatorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-1";
+  if (full_init)
   predictors::AutocompleteActionPredictorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-2";
+  if (full_init)
   predictors::PredictorDatabaseFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-3";
+  if (full_init)
   predictors::LoadingPredictorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-4";
+  if (full_init)
   prerender::PrerenderLinkManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-5";
+  if (full_init)
   prerender::PrerenderManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-6";
+  if (full_init)
   prerender::PrerenderMessageFilter::EnsureShutdownNotifierFactoryBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-7";
   ProfileSyncServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-8";
   ProtocolHandlerRegistryFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 59";
 #if !defined(OS_ANDROID)
   resource_coordinator::LocalSiteCharacteristicsDataStoreFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 59-1";
 #if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::AdvancedProtectionStatusManagerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 60";
 #if defined(OS_ANDROID)
   SearchPermissionsService::Factory::GetInstance();
 #endif
   send_tab_to_self::SendTabToSelfClientServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 61";
 #if BUILDFLAG(ENABLE_SESSION_SERVICE)
   SessionServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62";
+  if (full_init)
   SharingServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-1";
   ShortcutsBackendFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-2";
   SigninProfileAttributesUpdaterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-3";
 
   if (SiteEngagementService::IsEnabled())
     SiteEngagementServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-4";
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
   SpellcheckServiceFactory::GetInstance();
@@ -349,25 +390,40 @@ void ChromeBrowserMainExtraPartsProfiles
   StorageNotificationServiceFactory::GetInstance();
 #endif
   suggestions::SuggestionsServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 63";
   TabRestoreServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-1";
   TemplateURLFetcherFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-2";
   TemplateURLServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-3";
   TopSitesFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-4";
   translate::TranslateRankerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65";
 #if defined(OS_WIN)
   TriggeredProfileResetterFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65-1";
   UnifiedConsentServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65-2";
   UrlLanguageHistogramFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 66";
 #if !defined(OS_ANDROID)
   UsbChooserContextFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 67";
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   web_app::WebAppProviderFactory::GetInstance();
   web_app::WebAppMetricsFactory::GetInstance();
+  }
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 68";
   WebDataServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 69";
   webrtc_event_logging::WebRtcEventLogManagerKeyedServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 70";
 }
 
 void ChromeBrowserMainExtraPartsProfiles::PreProfileInit() {
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
@@ -23,7 +23,7 @@ class ChromeBrowserMainExtraPartsProfile
   // Instantiates all chrome KeyedService factories, which is
   // especially important for services that should be created at profile
   // creation time as compared to lazily on first access.
-  static void EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  static void EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init = true);
 
   // Overridden from ChromeBrowserMainExtraParts:
   void PreProfileInit() override;
--- a/chrome/browser/profiles/off_the_record_profile_impl.cc
+++ b/chrome/browser/profiles/off_the_record_profile_impl.cc
@@ -75,7 +75,6 @@
 
 #if defined(OS_ANDROID)
 #include "components/prefs/scoped_user_pref_update.h"
-#else  // !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_otr_delegate.h"
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/browser/host_zoom_map.h"
@@ -109,7 +108,7 @@
 
 using content::BrowserThread;
 using content::DownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 using content::HostZoomMap;
 #endif
 
@@ -155,7 +154,7 @@ void OffTheRecordProfileImpl::Init() {
         IncognitoModePrefs::GetAvailability(profile_->GetPrefs()) !=
             IncognitoModePrefs::DISABLED);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   TrackZoomLevelsFromParent();
 #endif
 
@@ -219,7 +218,7 @@ OffTheRecordProfileImpl::~OffTheRecordPr
   }
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OffTheRecordProfileImpl::TrackZoomLevelsFromParent() {
   DCHECK(!profile_->IsIncognitoProfile());
 
@@ -273,7 +272,7 @@ base::Time OffTheRecordProfileImpl::GetC
   return start_time_;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 OffTheRecordProfileImpl::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
@@ -618,7 +617,7 @@ Profile* Profile::CreateOffTheRecordProf
   return profile;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OffTheRecordProfileImpl::OnParentZoomLevelChanged(
     const HostZoomMap::ZoomLevelChange& change) {
   HostZoomMap* host_zoom_map = HostZoomMap::GetDefaultForBrowserContext(this);
--- a/chrome/browser/profiles/off_the_record_profile_impl.h
+++ b/chrome/browser/profiles/off_the_record_profile_impl.h
@@ -17,7 +17,7 @@
 #include "components/domain_reliability/clear_mode.h"
 #include "content/public/browser/content_browser_client.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -93,7 +93,7 @@ class OffTheRecordProfileImpl : public P
   base::FilePath GetPath() override;
   base::FilePath GetPath() const override;
   base::Time GetCreationTime() const override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
@@ -127,12 +127,12 @@ class OffTheRecordProfileImpl : public P
   GetNativeFileSystemPermissionContext() override;
 
  private:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Allows a profile to track changes in zoom levels in its parent profile.
   void TrackZoomLevelsFromParent();
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Callback function for tracking parent's zoom level changes.
   void OnParentZoomLevelChanged(
       const content::HostZoomMap::ZoomLevelChange& change);
@@ -144,7 +144,7 @@ class OffTheRecordProfileImpl : public P
 
   std::unique_ptr<sync_preferences::PrefServiceSyncable> prefs_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::HostZoomMap::Subscription> track_zoom_subscription_;
   std::unique_ptr<ChromeZoomLevelPrefs::DefaultZoomLevelSubscription>
       parent_default_zoom_level_subscription_;
--- a/chrome/browser/profiles/profile.cc
+++ b/chrome/browser/profiles/profile.cc
@@ -38,7 +38,7 @@
 #include "chromeos/constants/chromeos_switches.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/first_run/first_run.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -128,7 +128,7 @@ TestingProfile* Profile::AsTestingProfil
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ChromeZoomLevelPrefs* Profile::GetZoomLevelPrefs() {
   return nullptr;
 }
--- a/chrome/browser/profiles/profile.h
+++ b/chrome/browser/profiles/profile.h
@@ -21,7 +21,7 @@
 #include "services/network/public/mojom/network_context.mojom-forward.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class ChromeZoomLevelPrefs;
 #endif
 
@@ -218,7 +218,7 @@ class Profile : public content::BrowserC
   virtual PrefService* GetPrefs() = 0;
   virtual const PrefService* GetPrefs() const = 0;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Retrieves a pointer to the PrefService that manages the default zoom
   // level and the per-host zoom levels for this user profile.
   // TODO(wjmaclean): Remove this when HostZoomMap migrates to StoragePartition.
@@ -421,7 +421,7 @@ class Profile : public content::BrowserC
   // correctly assigned to its owner.
   Profile* CreateOffTheRecordProfile();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Convenience method to retrieve the default zoom level for the default
   // storage partition.
   double GetDefaultZoomLevelForProfile();
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -186,7 +186,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/profile_key_startup_accessor.h"
-#else
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/common/page_zoom.h"
 #endif
@@ -368,12 +367,14 @@ const char ProfileImpl::kPrefExitTypeNor
 // static
 void ProfileImpl::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 1";
   registry->RegisterBooleanPref(prefs::kSavingBrowserHistoryDisabled, false);
   registry->RegisterBooleanPref(prefs::kAllowDeletingBrowserHistory, true);
   registry->RegisterBooleanPref(prefs::kForceGoogleSafeSearch, false);
   registry->RegisterIntegerPref(prefs::kForceYouTubeRestrict,
                                 safe_search_util::YOUTUBE_RESTRICT_OFF);
   registry->RegisterStringPref(prefs::kAllowedDomainsForApps, std::string());
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 2";
 
   registry->RegisterIntegerPref(prefs::kProfileAvatarIndex, -1);
   // Whether a profile is using an avatar without having explicitely chosen it
@@ -394,6 +395,7 @@ void ProfileImpl::RegisterProfilePrefs(
                                home_page_flags);
   registry->RegisterStringPref(prefs::kNewTabPageLocationOverride,
                                std::string());
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 3";
 
 #if BUILDFLAG(ENABLE_PRINTING)
   registry->RegisterBooleanPref(prefs::kPrintingEnabled, true);
@@ -408,9 +410,10 @@ void ProfileImpl::RegisterProfilePrefs(
       prefs::kOobeMarketingOptInScreenFinished, false,
       user_prefs::PrefRegistrySyncable::SYNCABLE_OS_PREF);
 #endif  // defined(OS_CHROMEOS)
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(prefs::kShowCastIconInToolbar, false);
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 4";
 }
 
 ProfileImpl::ProfileImpl(
@@ -796,7 +799,7 @@ Profile::ProfileType ProfileImpl::GetPro
   return REGULAR_PROFILE;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 ProfileImpl::CreateZoomLevelDelegate(const base::FilePath& partition_path) {
   return std::make_unique<ChromeZoomLevelPrefs>(
@@ -1051,7 +1054,7 @@ const PrefService* ProfileImpl::GetPrefs
   return prefs_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ChromeZoomLevelPrefs* ProfileImpl::GetZoomLevelPrefs() {
   return static_cast<ChromeZoomLevelPrefs*>(
       GetDefaultStoragePartition(this)->GetZoomLevelDelegate());
--- a/chrome/browser/profiles/profile_impl.h
+++ b/chrome/browser/profiles/profile_impl.h
@@ -27,7 +27,7 @@
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/identity/public/mojom/identity_service.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -76,7 +76,7 @@ class ProfileImpl : public Profile {
   static void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);
 
   // content::BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif
@@ -133,7 +133,7 @@ class ProfileImpl : public Profile {
   ExtensionSpecialStoragePolicy* GetExtensionSpecialStoragePolicy() override;
   PrefService* GetPrefs() override;
   const PrefService* GetPrefs() const override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   ChromeZoomLevelPrefs* GetZoomLevelPrefs() override;
 #endif
   PrefService* GetOffTheRecordPrefs() override;
--- a/chrome/browser/profiles/profile_manager.cc
+++ b/chrome/browser/profiles/profile_manager.cc
@@ -124,7 +124,7 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/metrics/android_profile_session_durations_service_factory.h"
 #include "chrome/browser/ntp_snippets/content_suggestions_service_factory.h"
-#else
+
 #include "chrome/browser/first_run/first_run.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -236,7 +236,7 @@ void ProfileSizeTask(const base::FilePat
     UMA_HISTOGRAM_COUNTS_10000("Profile.AppCount", enabled_app_count);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Schedule a profile for deletion if it isn't already scheduled.
 // Returns whether the profile has been newly scheduled.
 bool ScheduleProfileDirectoryForDeletion(const base::FilePath& path) {
@@ -804,7 +804,7 @@ ProfileShortcutManager* ProfileManager::
   return profile_shortcut_manager_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::MaybeScheduleProfileForDeletion(
     const base::FilePath& profile_dir,
     ProfileLoadedCallback callback,
@@ -1418,7 +1418,7 @@ Profile* ProfileManager::CreateAndInitia
   return profile_ptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::EnsureActiveProfileExistsBeforeDeletion(
     ProfileLoadedCallback callback,
     const base::FilePath& profile_dir) {
--- a/chrome/browser/profiles/profile_manager.h
+++ b/chrome/browser/profiles/profile_manager.h
@@ -201,7 +201,7 @@ class ProfileManager : public content::N
   // profile specfic desktop shortcuts.
   ProfileShortcutManager* profile_shortcut_manager();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Less strict version of ScheduleProfileForDeletion(), silently exits if
   // profile is either scheduling or marked for deletion.
   void MaybeScheduleProfileForDeletion(
@@ -317,7 +317,7 @@ class ProfileManager : public content::N
   // null if creation fails.
   Profile* CreateAndInitializeProfile(const base::FilePath& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Continues the scheduled profile deletion after closing all the profile's
   // browsers tabs. Creates a new profile if the profile to be deleted is the
   // last non-supervised profile. In the Mac, loads the next non-supervised
@@ -369,7 +369,7 @@ class ProfileManager : public content::N
 
   void SaveActiveProfiles();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   void OnBrowserOpened(Browser* browser);
   void OnBrowserClosed(Browser* browser);
 
--- a/chrome/browser/profiles/profile_metrics.cc
+++ b/chrome/browser/profiles/profile_metrics.cc
@@ -25,7 +25,7 @@
 #include "components/signin/core/browser/signin_header_helper.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #endif
 
@@ -33,7 +33,7 @@ namespace {
 
 const int kMaximumDaysOfDisuse = 4 * 7;  // Should be integral number of weeks.
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 size_t number_of_profile_switches_ = 0;
 #endif
 
@@ -47,7 +47,7 @@ enum ProfileOpenState {
   PROFILE_UNOPENED
 };
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ProfileOpenState GetProfileOpenState(
     ProfileManager* manager,
     const base::FilePath& path) {
@@ -436,7 +436,7 @@ void ProfileMetrics::LogProfileOpenMetho
                             NUM_PROFILE_OPEN_METRICS);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileMetrics::LogProfileSwitch(
     ProfileOpen metric,
     ProfileManager* manager,
--- a/chrome/browser/profiles/profile_metrics.h
+++ b/chrome/browser/profiles/profile_metrics.h
@@ -167,7 +167,7 @@ class ProfileMetrics {
   static void LogProfileAvatarSelection(size_t icon_index);
   static void LogProfileDeleteUser(ProfileDelete metric);
   static void LogProfileOpenMethod(ProfileOpen metric);
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   static void LogProfileSwitch(ProfileOpen metric,
                                ProfileManager* manager,
                                const base::FilePath& profile_path);
--- a/chrome/browser/profiles/profile_window.cc
+++ b/chrome/browser/profiles/profile_window.cc
@@ -53,7 +53,7 @@
 #include "extensions/browser/extension_system.h"
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_list_observer.h"
@@ -252,7 +252,7 @@ void OpenBrowserWindowForProfile(Profile
                                             is_first_run, true);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 void LoadProfileAsync(const base::FilePath& path,
                       ProfileManager::CreateCallback callback) {
--- a/chrome/browser/profiles/profile_window.h
+++ b/chrome/browser/profiles/profile_window.h
@@ -15,10 +15,6 @@
 #include "chrome/browser/ui/profile_chooser_constants.h"
 #include "chrome/browser/ui/startup/startup_types.h"
 
-#if defined(OS_ANDROID)
-#error "Not used on Android"
-#endif
-
 class Profile;
 
 namespace base { class FilePath; }
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -27,7 +27,7 @@
 #include "content/public/browser/browsing_data_remover.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -81,7 +81,7 @@ void SetLastUsedProfile(const std::strin
   local_state->SetString(prefs::kProfileLastUsed, profile_dir);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 base::string16 GetAvatarNameForProfile(const base::FilePath& profile_path) {
   if (profile_path == ProfileManager::GetGuestProfilePath()) {
     return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);
--- a/chrome/browser/profiles/profiles_state.h
+++ b/chrome/browser/profiles/profiles_state.h
@@ -43,7 +43,7 @@ void RegisterPrefs(PrefRegistrySimple* r
 // System Profile directory, which is an invalid last used profile.
 void SetLastUsedProfile(const std::string& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Returns the display name of the specified on-the-record profile (or guest),
 // specified by |profile_path|, used in the avatar button or user manager. If
 // |profile_path| is the guest path, it will return IDS_GUEST_PROFILE_NAME. If
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -156,7 +156,7 @@
 #include "ui/gfx/text_elider.h"
 #include "ui/strings/grit/ui_strings.h"
 
-#if BUILDFLAG(USE_RENDERER_SPELLCHECKER)
+#if true || BUILDFLAG(USE_RENDERER_SPELLCHECKER)
 #include "chrome/browser/renderer_context_menu/spelling_options_submenu_observer.h"
 #endif
 
@@ -1747,16 +1747,6 @@ void RenderViewContextMenu::AppendLangua
 #if defined(OS_MACOSX)
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_LANGUAGE_SETTINGS,
                                   IDS_CONTENT_CONTEXT_LANGUAGE_SETTINGS);
-#else
-  if (!spelling_options_submenu_observer_) {
-    const int kLanguageRadioGroup = 1;
-    spelling_options_submenu_observer_ =
-        std::make_unique<SpellingOptionsSubMenuObserver>(this, this,
-                                                         kLanguageRadioGroup);
-  }
-
-  spelling_options_submenu_observer_->InitMenu(params_);
-  observers_.AddObserver(spelling_options_submenu_observer_.get());
 #endif
 }
 
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.h
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.h
@@ -33,6 +33,8 @@
 #include "chrome/browser/extensions/menu_manager.h"
 #endif
 
+#include "chrome/browser/renderer_context_menu/spelling_options_submenu_observer.h"
+
 class AccessibilityLabelsMenuObserver;
 class ClickToCallContextMenuObserver;
 class PrintPreviewContextMenuObserver;
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
@@ -9,13 +9,13 @@
 namespace resource_coordinator {
 
 ResourceCoordinatorParts::ResourceCoordinatorParts()
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     : tab_manager_(&tab_load_tracker_),
       tab_lifecycle_unit_source_(tab_manager_.intervention_policy_database(),
                                  tab_manager_.usage_clock())
 #endif
 {
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   tab_lifecycle_unit_source_.AddObserver(&tab_manager_);
 #endif
 }
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.h
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
@@ -10,7 +10,7 @@
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
 #include "chrome/browser/resource_coordinator/tab_memory_metrics_reporter.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_source.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -39,19 +39,11 @@ class ResourceCoordinatorParts {
   TabLoadTracker* tab_load_tracker() { return &tab_load_tracker_; }
 
   TabManager* tab_manager() {
-#if defined(OS_ANDROID)
-    return nullptr;
-#else
     return &tab_manager_;
-#endif  // defined(OS_ANDROID)
   }
 
   TabLifecycleUnitSource* tab_lifecycle_unit_source() {
-#if defined(OS_ANDROID)
-    return nullptr;
-#else
     return &tab_lifecycle_unit_source_;
-#endif  // defined(OS_ANDROID)
   }
 
  private:
@@ -62,7 +54,7 @@ class ResourceCoordinatorParts {
   // Created on demand the first time it's being accessed.
   std::unique_ptr<TabMemoryMetricsReporter> tab_memory_metrics_reporter_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Any change to this #ifdef must be reflected as well in
   // chrome/browser/resource_coordinator/tab_manager_browsertest.cc
   //
--- a/chrome/browser/resource_coordinator/tab_helper.cc
+++ b/chrome/browser/resource_coordinator/tab_helper.cc
@@ -25,7 +25,7 @@
 #include "content/public/browser/render_process_host.h"
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/local_site_characteristics_webcontents_observer.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -43,7 +43,7 @@ ResourceCoordinatorTabHelper::ResourceCo
         TabLoadTracker::Get());
   }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   local_site_characteristics_wc_observer_ =
       std::make_unique<LocalSiteCharacteristicsWebContentsObserver>(
           web_contents);
--- a/chrome/browser/resource_coordinator/tab_helper.h
+++ b/chrome/browser/resource_coordinator/tab_helper.h
@@ -52,7 +52,7 @@ class ResourceCoordinatorTabHelper
   ukm::SourceId ukm_source_id() const { return ukm_source_id_; }
   void SetUkmSourceIdForTest(ukm::SourceId id) { ukm_source_id_ = id; }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   LocalSiteCharacteristicsWebContentsObserver*
   local_site_characteristics_wc_observer() {
     return local_site_characteristics_wc_observer_.get();
@@ -67,7 +67,7 @@ class ResourceCoordinatorTabHelper
 
   friend class content::WebContentsUserData<ResourceCoordinatorTabHelper>;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<LocalSiteCharacteristicsWebContentsObserver>
       local_site_characteristics_wc_observer_;
 #endif
--- a/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
+++ b/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
@@ -41,6 +41,9 @@ void TabManager::WebContentsData::DidSta
 void TabManager::WebContentsData::DidFinishNavigation(
     content::NavigationHandle* navigation_handle) {
   SetIsInSessionRestore(false);
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation A: " << g_browser_process;
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation B: " << g_browser_process->GetTabManager();
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation C: " << navigation_handle;
   g_browser_process->GetTabManager()->OnDidFinishNavigation(navigation_handle);
 }
 
--- a/chrome/browser/resources/BUILD.gn
+++ b/chrome/browser/resources/BUILD.gn
@@ -18,7 +18,7 @@ if (closure_compile) {
       "interventions_internals:closure_compile",
       "reset_password:closure_compile",
     ]
-    if (is_linux || is_win || is_mac) {
+    if (true || is_linux || is_win || is_mac) {
       deps += [
         "bluetooth_internals:closure_compile",
         "bookmarks:closure_compile",
@@ -82,7 +82,7 @@ if (closure_compile) {
   }
 }
 
-if (!is_android) {
+if (true || !is_android) {
   grit("bookmarks_resources") {
     # The .grd contains references to generated files.
     source_is_generated = true
@@ -292,7 +292,7 @@ if (is_chromeos) {
   }
 }
 
-if (!is_android && !is_chromeos) {
+if (true || (!is_android && !is_chromeos)) {
   grit("welcome_resources") {
     source = "welcome/welcome_resources.grd"
 
--- /dev/null
+++ b/chrome/browser/resources/md_extensions/extensions.html
@@ -0,0 +1,47 @@
+<!doctype html>
+<html dir="$i18n{textdirection}" lang="$i18n{language}"
+    class="loading $i18n{loadTimeClasses}">
+<head>
+  <meta charset="utf8">
+  <title>$i18n{title}</title>
+  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
+<if expr="not optimize_webui">
+  <base href="chrome://extensions">
+</if>
+  <style>
+    html {
+      /* --md-background-color in disguise. Not using the var for increased
+       * performance. */
+      background-color: rgb(248, 249, 250);
+
+      /* Remove 300ms delay for 'click' event, when using touch interface. */
+      touch-action: manipulation;
+    }
+
+    .loading {
+      /* --google-blue-700 in disguise. Replaced when manager.html loads. */
+      border-top: 56px solid rgb(51, 103, 214);
+    }
+
+    /* Note: .in-dev-mode is applied by i18n{loadTimeClasses}. */
+    .loading.in-dev-mode {
+      border-top-width: 96px;
+    }
+
+    html,
+    body {
+      height: 100%;
+      line-height: 154%;
+      margin: 0;
+      overflow: hidden;
+      width: 100%;
+    }
+  </style>
+</head>
+<body>
+  <extensions-manager></extensions-manager>
+  <link rel="stylesheet" href="chrome://resources/css/md_colors.css">
+  <link rel="stylesheet" href="chrome://resources/css/text_defaults_md.css">
+  <link rel="import" href="chrome://extensions/manager.html">
+</body>
+</html>
--- a/chrome/browser/resources/unpack_pak.py
+++ b/chrome/browser/resources/unpack_pak.py
@@ -50,6 +50,10 @@ def Unpack(pak_path, out_path):
       res = re.match('^#define (\S*).* (\d+)\)?$', line)
       if res:
         resource_ids[int(res.group(2))] = res.group(1)
+      else:
+        res = re.match('#define ([^ ]+) ([^ ]+) (\d+)', line)
+        if res:
+          resource_ids[int(res.group(3))] = res.group(1)
   assert resource_ids
 
   # Associate numerical string IDs to files.
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -33,10 +33,6 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class InstantIOContext;
 class InstantServiceObserver;
 class Profile;
--- a/chrome/browser/search/instant_service_factory.h
+++ b/chrome/browser/search/instant_service_factory.h
@@ -10,10 +10,6 @@
 #include "build/build_config.h"
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class InstantService;
 class Profile;
 
--- a/chrome/browser/search/instant_service_observer.h
+++ b/chrome/browser/search/instant_service_observer.h
@@ -9,10 +9,6 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 struct InstantMostVisitedInfo;
 struct NtpTheme;
 
--- a/chrome/browser/search/local_ntp_source.h
+++ b/chrome/browser/search/local_ntp_source.h
@@ -26,10 +26,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 struct OneGoogleBarData;
 struct PromoData;
 class Profile;
--- a/chrome/browser/search/most_visited_iframe_source.h
+++ b/chrome/browser/search/most_visited_iframe_source.h
@@ -9,10 +9,6 @@
 #include "build/build_config.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 // Serves HTML for displaying suggestions using iframes, e.g.
 // chrome-search://most-visited/single.html
 class MostVisitedIframeSource : public content::URLDataSource {
--- a/chrome/browser/sharing/click_to_call/feature.cc
+++ b/chrome/browser/sharing/click_to_call/feature.cc
@@ -9,7 +9,7 @@ const base::Feature kClickToCallReceiver
                                          base::FEATURE_ENABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 const base::Feature kClickToCallUI{"ClickToCallUI",
                                    base::FEATURE_ENABLED_BY_DEFAULT};
 
--- a/chrome/browser/sharing/click_to_call/feature.h
+++ b/chrome/browser/sharing/click_to_call/feature.h
@@ -14,7 +14,7 @@
 extern const base::Feature kClickToCallReceiver;
 #endif  // defined(OS_ANDROID)
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 // Feature to allow click to call gets processed on desktop.
 extern const base::Feature kClickToCallUI;
 
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.cc
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
@@ -11,7 +11,7 @@ const base::Feature kSharedClipboardUI{"
                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const base::Feature kRemoteCopyReceiver{"RemoteCopyReceiver",
                                         base::FEATURE_DISABLED_BY_DEFAULT};
 
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.h
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.h
@@ -18,7 +18,7 @@ extern const base::Feature kSharedClipbo
 extern const base::Feature kSharedClipboardUI;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 // Feature to enable handling remote copy messages.
 extern const base::Feature kRemoteCopyReceiver;
 
--- a/chrome/browser/signin/account_consistency_mode_manager.cc
+++ b/chrome/browser/signin/account_consistency_mode_manager.cc
@@ -32,7 +32,9 @@ namespace {
 // Preference indicating that the Dice migraton has happened.
 const char kDiceMigrationCompletePref[] = "signin.DiceMigrationComplete";
 
+#if 0
 const char kDiceMigrationStatusHistogram[] = "Signin.DiceMigrationStatus";
+#endif
 
 const char kAllowBrowserSigninArgument[] = "allow-browser-signin";
 
@@ -48,6 +50,7 @@ enum class DiceMigrationStatus {
   kDiceMigrationStatusCount
 };
 
+#if 0
 DiceMigrationStatus GetDiceMigrationStatus(
     AccountConsistencyMethod account_consistency) {
   switch (account_consistency) {
@@ -74,6 +77,7 @@ bool IsBrowserSigninAllowedByCommandLine
   return !command_line->HasSwitch("disallow-signin");
 }
 #endif
+#endif
 
 }  // namespace
 
@@ -105,7 +109,7 @@ AccountConsistencyModeManager::AccountCo
 
   account_consistency_ = ComputeAccountConsistencyMethod(profile_);
 
-#if BUILDFLAG(ENABLE_DICE_SUPPORT)
+#if false && BUILDFLAG(ENABLE_DICE_SUPPORT)
   // New profiles don't need Dice migration. Old profiles may need it if they
   // were created before Dice.
   if (profile_->IsNewProfile())
--- a/chrome/browser/signin/chrome_signin_helper.cc
+++ b/chrome/browser/signin/chrome_signin_helper.cc
@@ -48,7 +48,7 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/signin/signin_utils.h"
 #include "ui/android/view_android.h"
-#else
+
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_window.h"
--- a/chrome/browser/startup_data.cc
+++ b/chrome/browser/startup_data.cc
@@ -98,12 +98,18 @@ void StartupData::RecordCoreSystemProfil
 
 #if defined(OS_ANDROID)
 void StartupData::CreateProfilePrefService() {
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 1";
   key_ = std::make_unique<ProfileKey>(GetProfilePath());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 2";
   PreProfilePrefServiceInit();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 3";
   CreateServicesInternal();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 4";
   key_->SetPrefs(prefs_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 5";
 
   ProfileKeyStartupAccessor::GetInstance()->SetProfileKey(key_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 6";
 }
 
 bool StartupData::HasBuiltProfilePrefService() {
@@ -149,12 +155,16 @@ StartupData::TakeProtoDatabaseProvider()
 }
 
 void StartupData::PreProfilePrefServiceInit() {
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 1";
   pref_registry_ = base::MakeRefCounted<user_prefs::PrefRegistrySyncable>();
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 2";
   ChromeBrowserMainExtraPartsProfiles::
-      EnsureBrowserContextKeyedServiceFactoriesBuilt();
+      EnsureBrowserContextKeyedServiceFactoriesBuilt(false);
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 3";
 }
 
 void StartupData::CreateServicesInternal() {
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 1";
   const base::FilePath& path = key_->GetPath();
   if (!base::PathExists(path)) {
     // TODO(rogerta): http://crbug/160553 - Bad things happen if we can't
@@ -164,25 +174,32 @@ void StartupData::CreateServicesInternal
       return;
 
     CreateProfileReadme(path);
+    LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 2";
   }
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 3";
   scoped_refptr<base::SequencedTaskRunner> io_task_runner =
       base::CreateSequencedTaskRunner(
           {base::ThreadPool(), base::TaskShutdownBehavior::BLOCK_SHUTDOWN,
            base::MayBlock()});
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 4";
   policy::ChromeBrowserPolicyConnector* browser_policy_connector =
       chrome_feature_list_creator_->browser_policy_connector();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 5";
   std::unique_ptr<policy::SchemaRegistry> schema_registry =
       std::make_unique<policy::SchemaRegistry>();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 6";
   schema_registry_service_ = BuildSchemaRegistryService(
       std::move(schema_registry), browser_policy_connector->GetChromeSchema(),
       browser_policy_connector->GetSchemaRegistry());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 7";
 
   user_cloud_policy_manager_ = CreateUserCloudPolicyManager(
       path, schema_registry_service_->registry(),
       true /* force_immediate_policy_load */, io_task_runner);
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 8";
   profile_policy_connector_ = policy::CreateAndInitProfilePolicyConnector(
       schema_registry_service_->registry(),
       static_cast<policy::ChromeBrowserPolicyConnector*>(
@@ -190,26 +207,32 @@ void StartupData::CreateServicesInternal
       user_cloud_policy_manager_.get(),
       user_cloud_policy_manager_->core()->store(),
       true /* force_immediate_policy_load*/, nullptr /* user */);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 9";
 
   // StoragePartitionImplMap uses profile directory as default storage
   // partition, see StoragePartitionImplMap::GetStoragePartitionPath().
   proto_db_provider_ =
       std::make_unique<leveldb_proto::ProtoDatabaseProvider>(path);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 10";
   key_->SetProtoDatabaseProvider(proto_db_provider_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 11";
 
   RegisterProfilePrefs(false /* is_signin_profile */,
                        chrome_feature_list_creator_->actual_locale(),
                        pref_registry_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 12";
 
   mojo::PendingRemote<prefs::mojom::TrackedPreferenceValidationDelegate>
       pref_validation_delegate;
   // The preference tracking and protection is not required on Android.
   DCHECK(!ProfilePrefStoreManager::kPlatformSupportsPreferenceTracking);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 14";
 
   prefs_ = CreatePrefService(
       pref_registry_, nullptr /* extension_pref_store */,
       profile_policy_connector_->policy_service(), browser_policy_connector,
       std::move(pref_validation_delegate), io_task_runner, key_.get(), path,
       false /* async_prefs*/);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 15";
 }
 #endif
--- a/chrome/browser/supervised_user/supervised_user_service.cc
+++ b/chrome/browser/supervised_user/supervised_user_service.cc
@@ -656,6 +656,8 @@ void SupervisedUserService::OnBlacklistL
 }
 
 void SupervisedUserService::UpdateBlacklist() {
+  if (true)
+    return;
   bool use_blacklist = supervised_users::IsSafeSitesBlacklistEnabled(profile_);
   url_filter_.SetBlacklist(use_blacklist ? &blacklist_ : nullptr);
   for (SupervisedUserServiceObserver& observer : observer_list_)
--- a/chrome/browser/sync/profile_sync_service_factory.cc
+++ b/chrome/browser/sync/profile_sync_service_factory.cc
@@ -160,22 +160,28 @@ ProfileSyncServiceFactory::ProfileSyncSe
   DependsOn(SendTabToSelfSyncServiceFactory::GetInstance());
   DependsOn(SharingMessageBridgeFactory::GetInstance());
   DependsOn(SpellcheckServiceFactory::GetInstance());
-#if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  LOG(DEBUG) << "[Kiwi-patch] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 21";
+#if false && BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SupervisedUserServiceFactory::GetInstance());
+  LOG(DEBUG) << "[Kiwi-patch] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 22";
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
 #endif  // BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SessionSyncServiceFactory::GetInstance());
+  LOG(DEBUG) << "[Kiwi-patch] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 24";
   DependsOn(TemplateURLServiceFactory::GetInstance());
 #if !defined(OS_ANDROID)
   DependsOn(ThemeServiceFactory::GetInstance());
 #endif  // !defined(OS_ANDROID)
   DependsOn(WebDataServiceFactory::GetInstance());
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+  LOG(DEBUG) << "[Kiwi-patch] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 27";
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
+  LOG(DEBUG) << "[Kiwi-patch] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 27-1";
   DependsOn(extensions::StorageFrontend::GetFactoryInstance());
   DependsOn(web_app::WebAppProviderFactory::GetInstance());
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
+  LOG(DEBUG) << "[Kiwi-patch] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 28";
 #if defined(OS_CHROMEOS)
   DependsOn(chromeos::SyncedPrintersManagerFactory::GetInstance());
   DependsOn(WifiConfigurationSyncServiceFactory::GetInstance());
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -603,7 +603,7 @@ jumbo_static_library("ui") {
   allow_circular_includes_from +=
       [ "//chrome/browser/ui/webui/bluetooth_internals" ]
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
     deps += [ "//chrome/browser/ui/webui/discards:mojo_bindings" ]
   }
 
@@ -825,7 +825,9 @@ jumbo_static_library("ui") {
       "//services/device/public/mojom:usb",
       "//ui/android",
     ]
-  } else {
+  }
+  if (true)
+  {
     # !is_android
     sources += [
       "apps/app_info_dialog.h",
@@ -1039,6 +1041,8 @@ jumbo_static_library("ui") {
       "media_router/ui_media_sink.cc",
       "media_router/ui_media_sink.h",
       "native_window_tracker.h",
+      "native_window_tracker_android.cc",
+      "native_window_tracker_android.h",
       "omnibox/alternate_nav_infobar_delegate.cc",
       "omnibox/alternate_nav_infobar_delegate.h",
       "omnibox/chrome_omnibox_client.cc",
@@ -2090,7 +2094,7 @@ jumbo_static_library("ui") {
     }
   }
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (is_win || is_mac || is_desktop_linux || is_chromeos || true) {
     sources += [
       "autofill/payments/virtual_card_selection_dialog_controller.h",
       "autofill/payments/virtual_card_selection_dialog_controller_impl.cc",
@@ -2145,13 +2149,17 @@ jumbo_static_library("ui") {
     deps += [ "//ui/webui" ]
   }
 
-  if (is_win || is_mac || is_desktop_linux) {
+  if (is_win || is_mac || is_desktop_linux || is_android) {
     sources += [
       "avatar_button_error_controller.cc",
       "avatar_button_error_controller.h",
       "avatar_button_error_controller_delegate.h",
       "bookmarks/bookmark_bubble_sign_in_delegate.cc",
       "bookmarks/bookmark_bubble_sign_in_delegate.h",
+#      "signin_view_controller.cc",
+#      "signin_view_controller.h",
+#      "signin_view_controller_delegate.cc",
+#      "signin_view_controller_delegate.h",
       "startup/default_browser_infobar_delegate.cc",
       "startup/default_browser_infobar_delegate.h",
       "startup/default_browser_prompt.cc",
@@ -2161,8 +2169,6 @@ jumbo_static_library("ui") {
       "sync/one_click_signin_links_delegate_impl.h",
       "user_manager.cc",
       "user_manager.h",
-      "views/external_protocol_dialog.cc",
-      "views/external_protocol_dialog.h",
       "views/profiles/badged_profile_photo.cc",
       "views/profiles/badged_profile_photo.h",
       "views/profiles/profile_menu_view.cc",
@@ -2547,6 +2553,11 @@ jumbo_static_library("ui") {
     }
   }
 
+  sources += [
+    "views/chrome_views_delegate_android.cc",
+    "views/frame/native_browser_frame_factory_android.cc",
+  ]
+
   if (is_desktop_linux) {
     sources += [
       "views/apps/chrome_app_window_client_views_linux.cc",
@@ -2650,8 +2661,9 @@ jumbo_static_library("ui") {
       sources += [ "views/tabs/window_finder_ozone.cc" ]
     }
   }
+  sources += [ "views/tabs/window_finder_android.cc" ]
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     sources += [
       "autofill/payments/local_card_migration_bubble.h",
       "autofill/payments/local_card_migration_bubble_controller_impl.cc",
@@ -2717,10 +2729,6 @@ jumbo_static_library("ui") {
       "views/autofill/autofill_bubble_handler_impl.h",
       "views/autofill/autofill_popup_base_view.cc",
       "views/autofill/autofill_popup_base_view.h",
-      "views/autofill/autofill_popup_view_native_views.cc",
-      "views/autofill/autofill_popup_view_native_views.h",
-      "views/autofill/payments/card_unmask_prompt_views.cc",
-      "views/autofill/payments/card_unmask_prompt_views.h",
       "views/autofill/payments/dialog_view_ids.h",
       "views/autofill/payments/local_card_migration_bubble_views.cc",
       "views/autofill/payments/local_card_migration_bubble_views.h",
@@ -2825,6 +2833,7 @@ jumbo_static_library("ui") {
       "views/download/download_started_animation_views.cc",
       "views/dropdown_bar_host.cc",
       "views/dropdown_bar_host.h",
+      "views/dropdown_bar_host_android.cc",
       "views/dropdown_bar_host_delegate.h",
       "views/elevation_icon_setter.cc",
       "views/elevation_icon_setter.h",
@@ -2959,8 +2968,6 @@ jumbo_static_library("ui") {
       "views/importer/import_lock_dialog_view.h",
       "views/infobars/alternate_nav_infobar_view.cc",
       "views/infobars/alternate_nav_infobar_view.h",
-      "views/infobars/confirm_infobar.cc",
-      "views/infobars/confirm_infobar.h",
       "views/infobars/infobar_container_view.cc",
       "views/infobars/infobar_container_view.h",
       "views/infobars/infobar_view.cc",
@@ -3016,12 +3023,8 @@ jumbo_static_library("ui") {
       "views/media_router/cast_dialog_view.h",
       "views/media_router/cast_toolbar_button.cc",
       "views/media_router/cast_toolbar_button.h",
-      "views/media_router/cloud_services_dialog_view.cc",
-      "views/media_router/cloud_services_dialog_view.h",
       "views/media_router/media_remoting_dialog_view.cc",
       "views/media_router/media_remoting_dialog_view.h",
-      "views/media_router/media_router_dialog_controller_views.cc",
-      "views/media_router/media_router_dialog_controller_views.h",
       "views/media_router/media_router_views_ui.cc",
       "views/media_router/media_router_views_ui.h",
       "views/media_router/presentation_receiver_window_factory.cc",
@@ -3065,8 +3068,6 @@ jumbo_static_library("ui") {
       "views/overlay/back_to_tab_image_button.h",
       "views/overlay/close_image_button.cc",
       "views/overlay/close_image_button.h",
-      "views/overlay/overlay_window_views.cc",
-      "views/overlay/overlay_window_views.h",
       "views/overlay/playback_image_button.cc",
       "views/overlay/playback_image_button.h",
       "views/overlay/resize_handle_button.cc",
@@ -3101,8 +3102,6 @@ jumbo_static_library("ui") {
       "views/page_info/permission_selector_row.cc",
       "views/page_info/permission_selector_row.h",
       "views/page_info/permission_selector_row_observer.h",
-      "views/page_info/safety_tip_page_info_bubble_view.cc",
-      "views/page_info/safety_tip_page_info_bubble_view.h",
       "views/passwords/account_chooser_dialog_view.cc",
       "views/passwords/account_chooser_dialog_view.h",
       "views/passwords/auto_signin_first_run_dialog_view.cc",
@@ -3119,8 +3118,6 @@ jumbo_static_library("ui") {
       "views/passwords/password_bubble_view_base.h",
       "views/passwords/password_generation_confirmation_view.cc",
       "views/passwords/password_generation_confirmation_view.h",
-      "views/passwords/password_generation_popup_view_views.cc",
-      "views/passwords/password_generation_popup_view_views.h",
       "views/passwords/password_items_view.cc",
       "views/passwords/password_items_view.h",
       "views/passwords/password_pending_view.cc",
@@ -3445,8 +3442,6 @@ jumbo_static_library("ui") {
       sources += [
         "views/create_application_shortcut_view.cc",
         "views/create_application_shortcut_view.h",
-        "views/ssl_client_certificate_selector.cc",
-        "views/ssl_client_certificate_selector.h",
       ]
     }
 
@@ -3532,6 +3527,14 @@ jumbo_static_library("ui") {
     }
   }
 
+  sources += [
+      "views/accelerator_utils_android.cc",
+      "window_sizer/window_sizer_android.cc",
+      "views/frame/browser_non_client_frame_view_factory_views.cc",
+      "views/frame/desktop_browser_frame_android.cc",
+      "views/frame/desktop_browser_frame_android.h",
+  ]
+
   if (use_aura) {
     sources += [
       "aura/accessibility/automation_manager_aura.cc",
--- a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
@@ -63,7 +63,7 @@ std::vector<GURL> GetURLsToOpen(
   return urls;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool ShouldOpenAll(gfx::NativeWindow parent,
                    const std::vector<const BookmarkNode*>& nodes) {
   size_t child_count = GetURLsToOpen(nodes).size();
@@ -89,7 +89,7 @@ int ChildURLCountTotal(const BookmarkNod
                          count_children);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Returns in |urls|, the url and title pairs for each open tab in browser.
 void GetURLsForOpenTabs(Browser* browser,
                         std::vector<std::pair<GURL, base::string16>>* urls) {
@@ -104,7 +104,7 @@ void GetURLsForOpenTabs(Browser* browser
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OpenAll(gfx::NativeWindow parent,
              content::PageNavigator* navigator,
              const std::vector<const BookmarkNode*>& nodes,
@@ -188,9 +188,6 @@ void ShowBookmarkAllTabsDialog(Browser*
       BookmarkEditor::EditDetails::AddFolder(parent, parent->children().size());
   GetURLsForOpenTabs(browser, &(details.urls));
   DCHECK(!details.urls.empty());
-
-  BookmarkEditor::Show(browser->window()->GetNativeWindow(), profile, details,
-                       BookmarkEditor::SHOW_TREE);
 }
 
 bool HasBookmarkURLs(const std::vector<const BookmarkNode*>& selection) {
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -283,6 +283,7 @@ constexpr TimeDelta kUIUpdateCoalescingT
 
 BrowserWindow* CreateBrowserWindow(std::unique_ptr<Browser> browser,
                                    bool user_gesture) {
+  LOG(ERROR) << "[Kiwi] BrowserWindow* CreateBrowserWindow";
   return BrowserWindow::CreateBrowserWindow(std::move(browser), user_gesture);
 }
 
@@ -2012,6 +2013,7 @@ void Browser::RequestPpapiBrokerPermissi
     return;
   }
 
+#if 0
   TabSpecificContentSettings* tab_content_settings =
       TabSpecificContentSettings::FromWebContents(web_contents);
 
@@ -2045,6 +2047,7 @@ void Browser::RequestPpapiBrokerPermissi
   tab_content_settings->SetPepperBrokerAllowed(allowed);
   std::move(callback).Run(allowed);
 #endif
+
 }
 
 #if BUILDFLAG(ENABLE_PRINTING)
@@ -2651,6 +2654,7 @@ void Browser::SetAsDelegate(WebContents*
   web_contents->SetDelegate(delegate);
 
   // ...and all the helpers.
+#if 0
   WebContentsModalDialogManager::FromWebContents(web_contents)
       ->SetDelegate(delegate);
   translate::ContentTranslateDriver* content_translate_driver =
@@ -2664,6 +2668,7 @@ void Browser::SetAsDelegate(WebContents*
     content_translate_driver->RemoveObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
   }
+#endif
 }
 
 void Browser::CloseFrame() {
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -55,9 +55,11 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
+#if 0
 #if defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
+#endif
 
 class BackgroundContents;
 class BrowserContentSettingBubbleModelDelegate;
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -644,19 +644,15 @@ bool BrowserCommandController::ExecuteCo
           browser_, false /* force_shortcut_app */);
       break;
     case IDC_DEV_TOOLS:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Show());
       break;
     case IDC_DEV_TOOLS_CONSOLE:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::ShowConsolePanel());
       break;
     case IDC_DEV_TOOLS_DEVICES:
       InspectUI::InspectDevices(browser_);
       break;
     case IDC_DEV_TOOLS_INSPECT:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Inspect());
       break;
     case IDC_DEV_TOOLS_TOGGLE:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Toggle());
       break;
     case IDC_TASK_MANAGER:
       OpenTaskManager(browser_);
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1286,7 +1286,6 @@ void ToggleDevToolsWindow(Browser* brows
     base::RecordAction(UserMetricsAction("DevTools_ToggleConsole"));
   else
     base::RecordAction(UserMetricsAction("DevTools_ToggleWindow"));
-  DevToolsWindow::ToggleDevToolsWindow(browser, action);
 }
 
 bool CanOpenTaskManager() {
--- a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
+++ b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
@@ -49,7 +49,7 @@ void BrowserContentSettingBubbleModelDel
   GURL learn_more_url;
   switch (type) {
     case ContentSettingsType::PLUGINS:
-      learn_more_url = GURL(chrome::kBlockedPluginLearnMoreURL);
+      learn_more_url = GURL("https://www.kiwibrowser.com/");
       break;
     case ContentSettingsType::ADS:
       learn_more_url = GURL(subresource_filter::kLearnMoreLink);
--- a/chrome/browser/ui/browser_instant_controller.h
+++ b/chrome/browser/ui/browser_instant_controller.h
@@ -13,10 +13,6 @@
 #include "chrome/browser/search/search_engine_base_url_tracker.h"
 #include "chrome/browser/ui/search/instant_controller.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class Browser;
 class Profile;
 
--- a/chrome/browser/ui/browser_list.cc
+++ b/chrome/browser/ui/browser_list.cc
@@ -129,13 +129,14 @@ void BrowserList::RemoveBrowser(Browser*
     // shutdown, because Browser::WindowClosing() already makes sure that the
     // SessionService is created and notified.
     browser_shutdown::NotifyAppTerminating();
-    chrome::OnAppExiting();
   }
 }
 
 // static
 void BrowserList::AddObserver(BrowserListObserver* observer) {
+  LOG(ERROR) << "[Kiwi] BrowserList::AddObserver - Step 1";
   observers_.Get().AddObserver(observer);
+  LOG(ERROR) << "[Kiwi] BrowserList::AddObserver - Step 2";
 }
 
 // static
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -13,7 +13,7 @@
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -24,7 +24,7 @@ using content::WebContents;
 #if defined(OS_ANDROID)
 NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
-#else
+
 NavigateParams::NavigateParams(Browser* a_browser,
                                const GURL& a_url,
                                ui::PageTransition a_transition)
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -25,7 +25,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "components/tab_groups/tab_group_id.h"
 #endif
@@ -66,7 +66,7 @@ struct NavigateParams {
 #if defined(OS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
-#else
+
   NavigateParams(Browser* browser,
                  const GURL& a_url,
                  ui::PageTransition a_transition);
@@ -211,7 +211,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // [in]  Specifies a Browser object where the navigation could occur or the
   //       tab could be added. Navigate() is not obliged to use this Browser if
   //       it is not compatible with the operation being performed. This can be
--- a/chrome/browser/ui/browser_otr_state.cc
+++ b/chrome/browser/ui/browser_otr_state.cc
@@ -8,8 +8,4 @@
 
 namespace chrome {
 
-bool IsIncognitoSessionActive() {
-  return BrowserList::IsIncognitoSessionActive();
-}
-
 }  // namespace chrome
--- a/chrome/browser/ui/browser_ui_prefs.cc
+++ b/chrome/browser/ui/browser_ui_prefs.cc
@@ -40,7 +40,7 @@ uint32_t GetHomeButtonAndHomePageIsNewTa
 void RegisterBrowserPrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kAllowFileSelectionDialogs, true);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterIntegerPref(prefs::kRelaunchNotification, 0);
   registry->RegisterIntegerPref(
       prefs::kRelaunchNotificationPeriod,
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -31,10 +31,6 @@
 #include "ui/gfx/native_widget_types.h"
 #include "url/origin.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 class SharingDialog;
 class DownloadShelf;
--- a/chrome/browser/ui/chrome_pages.cc
+++ b/chrome/browser/ui/chrome_pages.cc
@@ -69,7 +69,7 @@
 #include "chrome/browser/ui/signin_view_controller.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #endif
@@ -488,7 +488,7 @@ GURL GetOSSettingsUrl(const std::string&
 }
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point) {
 }
--- a/chrome/browser/ui/chrome_pages.h
+++ b/chrome/browser/ui/chrome_pages.h
@@ -13,7 +13,7 @@
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/signin/signin_promo.h"
 #endif
 
@@ -135,7 +135,7 @@ void ShowEnterpriseManagementPageInTabbe
 GURL GetOSSettingsUrl(const std::string& sub_page);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 // Initiates signin in a new browser tab.
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point);
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
@@ -685,10 +685,13 @@ ContentSettingPluginBubbleModel::Content
   const GURL& url = web_contents->GetURL();
   bool managed_by_user =
       GetSettingManagedByUser(url, content_type(), GetProfile(), nullptr);
+#if 0
   HostContentSettingsMap* map =
       HostContentSettingsMapFactory::GetForProfile(GetProfile());
   ContentSetting setting = PluginUtils::GetFlashPluginContentSetting(
       map, url::Origin::Create(url), url, nullptr);
+#endif
+  ContentSetting setting = CONTENT_SETTING_BLOCK;
 
   // If the setting is not managed by the user, hide the "Manage" button.
   if (!managed_by_user)
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.h
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
@@ -505,7 +505,7 @@ class ContentSettingSingleRadioGroup : p
   DISALLOW_COPY_AND_ASSIGN(ContentSettingSingleRadioGroup);
 };
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The model for the blocked Framebust bubble.
 class ContentSettingFramebustBlockBubbleModel
     : public ContentSettingSingleRadioGroup,
--- /dev/null
+++ b/chrome/browser/ui/fast_unload_controller.cc
@@ -0,0 +1,487 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/fast_unload_controller.h"
+
+#include "base/location.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/tab_contents/core_tab_helper.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/tabs/tab_strip_model_delegate.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_source.h"
+#include "content/public/browser/notification_types.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/buildflags/buildflags.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#endif  // (ENABLE_EXTENSIONS)
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, public:
+
+FastUnloadController::FastUnloadController(Browser* browser)
+    : browser_(browser),
+      tab_needing_before_unload_ack_(NULL),
+      is_attempting_to_close_browser_(false),
+      weak_factory_(this) {
+  browser_->tab_strip_model()->AddObserver(this);
+}
+
+FastUnloadController::~FastUnloadController() {
+  browser_->tab_strip_model()->RemoveObserver(this);
+  web_contents_waiting_for_deletion_.clear();
+}
+
+bool FastUnloadController::CanCloseContents(content::WebContents* contents) {
+  // Don't try to close the tab when the whole browser is being closed, since
+  // that avoids the fast shutdown path where we just kill all the renderers.
+  return !is_attempting_to_close_browser_ ||
+      is_calling_before_unload_handlers();
+}
+
+bool FastUnloadController::ShouldRunUnloadEventsHelper(
+    content::WebContents* contents) {
+  // If |contents| is being inspected, devtools needs to intercept beforeunload
+  // events.
+  return false;
+}
+
+bool FastUnloadController::RunUnloadEventsHelper(
+    content::WebContents* contents) {
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  // Don't run for extensions that are disabled or uninstalled; the tabs will
+  // be killed if they make any network requests, and the extension shouldn't
+  // be doing any work if it's removed.
+  GURL url = contents->GetLastCommittedURL();
+  if (url.SchemeIs(extensions::kExtensionScheme) &&
+      !extensions::ExtensionRegistry::Get(browser_->profile())
+           ->enabled_extensions()
+           .GetExtensionOrAppByURL(url)) {
+    return false;
+  }
+#endif  // (ENABLE_EXTENSIONS)
+
+  // Special case for when we quit an application. The Devtools window can
+  // close if it's beforeunload event has already fired which will happen due
+  // to the interception of it's content's beforeunload.
+
+  // If there's a devtools window attached to |contents|,
+  // we would like devtools to call its own beforeunload handlers first,
+  // and then call beforeunload handlers for |contents|.
+  // See DevToolsWindow::InterceptPageBeforeUnload for details.
+  // If the WebContents is not connected yet, then there's no unload
+  // handler we can fire even if the WebContents has an unload listener.
+  // One case where we hit this is in a tab that has an infinite loop
+  // before load.
+  if (contents->NeedToFireBeforeUnload()) {
+    // If the page has unload listeners, then we tell the renderer to fire
+    // them. Once they have fired, we'll get a message back saying whether
+    // to proceed closing the page or not, which sends us back to this method
+    // with the NeedToFireBeforeUnload bit cleared.
+    contents->DispatchBeforeUnload();
+    return true;
+  }
+  return false;
+}
+
+bool FastUnloadController::BeforeUnloadFiredForContents(
+    content::WebContents* contents,
+    bool proceed) {
+
+  if (!is_attempting_to_close_browser_) {
+    if (!proceed) {
+      contents->SetClosedByUserGesture(false);
+    } else {
+      // No more dialogs are possible, so remove the tab and finish
+      // running unload listeners asynchrounously.
+      browser_->tab_strip_model()->delegate()->CreateHistoricalTab(contents);
+      DetachWebContents(contents);
+    }
+    return proceed;
+  }
+
+  if (!proceed) {
+    CancelWindowClose();
+    contents->SetClosedByUserGesture(false);
+    return false;
+  }
+
+  if (tab_needing_before_unload_ack_ == contents) {
+    // Now that beforeunload has fired, queue the tab to fire unload.
+    tab_needing_before_unload_ack_ = NULL;
+    tabs_needing_unload_.insert(contents);
+    ProcessPendingTabs(false);
+    // We want to handle firing the unload event ourselves since we want to
+    // fire all the beforeunload events before attempting to fire the unload
+    // events should the user cancel closing the browser.
+    return false;
+  }
+
+  return true;
+}
+
+bool FastUnloadController::ShouldCloseWindow() {
+  if (HasCompletedUnloadProcessing())
+    return true;
+
+  // Special case for when we quit an application. The Devtools window can
+  // close if it's beforeunload event has already fired which will happen due
+  // to the interception of it's content's beforeunload.
+
+  // The behavior followed here varies based on the current phase of the
+  // operation and whether a batched shutdown is in progress.
+  //
+  // If there are tabs with outstanding beforeunload handlers:
+  // 1. If a batched shutdown is in progress: return false.
+  //    This is to prevent interference with batched shutdown already in
+  //    progress.
+  // 2. Otherwise: start sending beforeunload events and return false.
+  //
+  // Otherwise, If there are no tabs with outstanding beforeunload handlers:
+  // 3. If a batched shutdown is in progress: start sending unload events and
+  //    return false.
+  // 4. Otherwise: return true.
+  is_attempting_to_close_browser_ = true;
+  // Cases 1 and 4.
+  bool need_beforeunload_fired = TabsNeedBeforeUnloadFired();
+  if (need_beforeunload_fired == is_calling_before_unload_handlers())
+    return !need_beforeunload_fired;
+
+  // Cases 2 and 3.
+  on_close_confirmed_.Reset();
+  ProcessPendingTabs(false);
+  return false;
+}
+
+bool FastUnloadController::TryToCloseWindow(
+    bool skip_beforeunload,
+    const base::Callback<void(bool)>& on_close_confirmed) {
+  // The devtools browser gets its beforeunload events as the results of
+  // intercepting events from the inspected tab, so don't send them here as
+  // well.
+  if (browser_->is_devtools() || !TabsNeedBeforeUnloadFired())
+    return false;
+
+  on_close_confirmed_ = on_close_confirmed;
+  is_attempting_to_close_browser_ = true;
+  ProcessPendingTabs(skip_beforeunload);
+  return !skip_beforeunload;
+}
+
+void FastUnloadController::ResetTryToCloseWindow() {
+  if (!is_calling_before_unload_handlers())
+    return;
+  CancelWindowClose();
+}
+
+bool FastUnloadController::TabsNeedBeforeUnloadFired() {
+  if (!tabs_needing_before_unload_.empty() ||
+      tab_needing_before_unload_ack_ != NULL)
+    return true;
+
+  if (!is_calling_before_unload_handlers() && !tabs_needing_unload_.empty())
+    return false;
+
+  return !tabs_needing_before_unload_.empty();
+}
+
+bool FastUnloadController::HasCompletedUnloadProcessing() const {
+  return is_attempting_to_close_browser_ &&
+      tabs_needing_before_unload_.empty() &&
+      tab_needing_before_unload_ack_ == NULL &&
+      tabs_needing_unload_.empty() &&
+      tabs_needing_unload_ack_.empty();
+}
+
+void FastUnloadController::CancelTabNeedingBeforeUnloadAck() {
+  if (tab_needing_before_unload_ack_ != NULL) {
+    CoreTabHelper* core_tab_helper =
+        CoreTabHelper::FromWebContents(tab_needing_before_unload_ack_);
+    core_tab_helper->OnCloseCanceled();
+    tab_needing_before_unload_ack_ = NULL;
+  }
+}
+
+void FastUnloadController::CancelWindowClose() {
+  // Closing of window can be canceled from a beforeunload handler.
+  DCHECK(is_attempting_to_close_browser_);
+  tabs_needing_before_unload_.clear();
+  CancelTabNeedingBeforeUnloadAck();
+  for (WebContentsSet::iterator it = tabs_needing_unload_.begin();
+       it != tabs_needing_unload_.end(); it++) {
+    content::WebContents* contents = *it;
+
+    CoreTabHelper* core_tab_helper = CoreTabHelper::FromWebContents(contents);
+    core_tab_helper->OnCloseCanceled();
+  }
+  tabs_needing_unload_.clear();
+
+  // No need to clear tabs_needing_unload_ack_. Those tabs are already detached.
+
+  if (is_calling_before_unload_handlers()) {
+    base::Callback<void(bool)> on_close_confirmed = on_close_confirmed_;
+    on_close_confirmed_.Reset();
+    on_close_confirmed.Run(false);
+  }
+
+  is_attempting_to_close_browser_ = false;
+
+  content::NotificationService::current()->Notify(
+      chrome::NOTIFICATION_BROWSER_CLOSE_CANCELLED,
+      content::Source<Browser>(browser_),
+      content::NotificationService::NoDetails());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, content::WebContentsDelegate implementation:
+
+bool FastUnloadController::ShouldSuppressDialogs(content::WebContents* source) {
+  return true;
+}
+
+void FastUnloadController::CloseContents(content::WebContents* source) {
+  auto it = web_contents_waiting_for_deletion_.find(source);
+  DCHECK(it != web_contents_waiting_for_deletion_.end());
+  web_contents_waiting_for_deletion_.erase(it);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, content::NotificationObserver implementation:
+
+void FastUnloadController::Observe(
+      int type,
+      const content::NotificationSource& source,
+      const content::NotificationDetails& details) {
+  DCHECK_EQ(content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED, type);
+
+  registrar_.Remove(this, content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                    source);
+  ClearUnloadState(content::Source<content::WebContents>(source).ptr());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, TabStripModelObserver implementation:
+
+void FastUnloadController::TabInsertedAt(TabStripModel* tab_strip_model,
+                                         content::WebContents* contents,
+                                         int index,
+                                         bool foreground) {
+  TabAttachedImpl(contents);
+}
+
+void FastUnloadController::TabDetachedAt(content::WebContents* contents,
+                                         int index,
+                                         bool was_active) {
+  TabDetachedImpl(contents);
+}
+
+void FastUnloadController::TabReplacedAt(TabStripModel* tab_strip_model,
+                                         content::WebContents* old_contents,
+                                         content::WebContents* new_contents,
+                                         int index) {
+  TabDetachedImpl(old_contents);
+  TabAttachedImpl(new_contents);
+}
+
+void FastUnloadController::TabStripEmpty() {
+  // Set is_attempting_to_close_browser_ here, so that extensions, etc, do not
+  // attempt to add tabs to the browser before it closes.
+  is_attempting_to_close_browser_ = true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, private:
+
+void FastUnloadController::TabAttachedImpl(content::WebContents* contents) {
+  // If the tab crashes in the beforeunload or unload handler, it won't be
+  // able to ack. But we know we can close it.
+  registrar_.Add(
+      this,
+      content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+      content::Source<content::WebContents>(contents));
+}
+
+void FastUnloadController::TabDetachedImpl(content::WebContents* contents) {
+  if (tabs_needing_unload_ack_.find(contents) !=
+      tabs_needing_unload_ack_.end()) {
+    // Tab needs unload to complete.
+    // It will send |NOTIFICATION_WEB_CONTENTS_DISCONNECTED| when done.
+    return;
+  }
+
+  // If WEB_CONTENTS_DISCONNECTED was received then the notification may have
+  // already been unregistered.
+  const content::NotificationSource& source =
+      content::Source<content::WebContents>(contents);
+  if (registrar_.IsRegistered(this,
+                              content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                              source)) {
+    registrar_.Remove(this,
+                      content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                      source);
+  }
+
+  if (is_attempting_to_close_browser_)
+    ClearUnloadState(contents);
+}
+
+bool FastUnloadController::DetachWebContents(content::WebContents* contents) {
+  int index = browser_->tab_strip_model()->GetIndexOfWebContents(contents);
+  if (index != TabStripModel::kNoTab &&
+      contents->NeedToFireBeforeUnload()) {
+    tabs_needing_unload_ack_.insert(contents);
+    web_contents_waiting_for_deletion_[contents] =
+        browser_->tab_strip_model()->DetachWebContentsAt(index);
+    contents->SetDelegate(this);
+    CoreTabHelper* core_tab_helper = CoreTabHelper::FromWebContents(contents);
+    core_tab_helper->OnUnloadDetachedStarted();
+    return true;
+  }
+  return false;
+}
+
+void FastUnloadController::ProcessPendingTabs(bool skip_beforeunload) {
+  if (!is_attempting_to_close_browser_) {
+    // Because we might invoke this after a delay it's possible for the value of
+    // is_attempting_to_close_browser_ to have changed since we scheduled the
+    // task.
+    return;
+  }
+
+  if (tab_needing_before_unload_ack_ != NULL) {
+    if (skip_beforeunload) {
+      // Cancel and skip the ongoing before unload event.
+      tabs_needing_before_unload_.insert(tab_needing_before_unload_ack_);
+      CancelTabNeedingBeforeUnloadAck();
+    } else {
+      // Wait for |BeforeUnloadFiredForContents| before proceeding.
+      return;
+    }
+  }
+
+  // Process a beforeunload handler.
+  if (!tabs_needing_before_unload_.empty()) {
+    if (skip_beforeunload) {
+      tabs_needing_unload_.insert(tabs_needing_before_unload_.begin(),
+                                  tabs_needing_before_unload_.end());
+      tabs_needing_before_unload_.clear();
+    } else {
+      WebContentsSet::iterator it = tabs_needing_before_unload_.begin();
+      content::WebContents* contents = *it;
+      tabs_needing_before_unload_.erase(it);
+      // Null check render_view_host here as this gets called on a PostTask and
+      // the tab's render_view_host may have been nulled out.
+      if (contents->GetRenderViewHost()) {
+        tab_needing_before_unload_ack_ = contents;
+
+        CoreTabHelper* core_tab_helper =
+            CoreTabHelper::FromWebContents(contents);
+        core_tab_helper->OnCloseStarted();
+
+        // If there's a devtools window attached to |contents|,
+        // we would like devtools to call its own beforeunload handlers first,
+        // and then call beforeunload handlers for |contents|.
+        // See DevToolsWindow::InterceptPageBeforeUnload for details.
+      } else {
+        ProcessPendingTabs(skip_beforeunload);
+      }
+      return;
+    }
+  }
+
+  if (is_calling_before_unload_handlers()) {
+    base::OnceCallback<void(bool)> on_close_confirmed = on_close_confirmed_;
+    // Reset |on_close_confirmed_| in case the callback tests
+    // |is_calling_before_unload_handlers()|, we want to return that calling
+    // is complete.
+    if (tabs_needing_unload_.empty())
+      on_close_confirmed_.Reset();
+    if (!skip_beforeunload)
+      std::move(on_close_confirmed).Run(true);
+    return;
+  }
+
+  // Process all the unload handlers. (The beforeunload handlers have finished.)
+  if (!tabs_needing_unload_.empty()) {
+    browser_->OnWindowClosing();
+
+    // Run unload handlers detached since no more interaction is possible.
+    WebContentsSet::iterator it = tabs_needing_unload_.begin();
+    while (it != tabs_needing_unload_.end()) {
+      WebContentsSet::iterator current = it++;
+      content::WebContents* contents = *current;
+      tabs_needing_unload_.erase(current);
+      // Null check render_view_host here as this gets called on a PostTask
+      // and the tab's render_view_host may have been nulled out.
+      if (contents->GetRenderViewHost()) {
+        CoreTabHelper* core_tab_helper =
+            CoreTabHelper::FromWebContents(contents);
+        core_tab_helper->OnUnloadStarted();
+        DetachWebContents(contents);
+        contents->ClosePage();
+      }
+    }
+
+    // Get the browser hidden.
+    if (browser_->tab_strip_model()->empty()) {
+      browser_->TabStripEmpty();
+    } else {
+      browser_->tab_strip_model()->CloseAllTabs();  // tabs not needing unload
+    }
+    return;
+  }
+
+  if (HasCompletedUnloadProcessing()) {
+    browser_->OnWindowClosing();
+
+    // Get the browser closed.
+    if (browser_->tab_strip_model()->empty()) {
+      browser_->TabStripEmpty();
+    } else {
+      // There may be tabs if the last tab needing beforeunload crashed.
+      browser_->tab_strip_model()->CloseAllTabs();
+    }
+    return;
+  }
+}
+
+void FastUnloadController::ClearUnloadState(content::WebContents* contents) {
+  if (tabs_needing_unload_ack_.erase(contents) > 0) {
+    if (HasCompletedUnloadProcessing())
+      PostTaskForProcessPendingTabs();
+    return;
+  }
+
+  if (!is_attempting_to_close_browser_)
+    return;
+
+  if (tab_needing_before_unload_ack_ == contents) {
+    tab_needing_before_unload_ack_ = NULL;
+    PostTaskForProcessPendingTabs();
+    return;
+  }
+
+  if (tabs_needing_before_unload_.erase(contents) > 0 ||
+      tabs_needing_unload_.erase(contents) > 0) {
+    if (tab_needing_before_unload_ack_ == NULL)
+      PostTaskForProcessPendingTabs();
+  }
+}
+
+void FastUnloadController::PostTaskForProcessPendingTabs() {
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE, base::BindOnce(&FastUnloadController::ProcessPendingTabs,
+                                weak_factory_.GetWeakPtr(), false));
+}
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.cc
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/native_window_tracker_android.h"
+
+#include "ui/android/window_android.h"
+
+NativeWindowTrackerAndroid::NativeWindowTrackerAndroid(
+    gfx::NativeWindow window)
+    : window_(window) {
+}
+
+NativeWindowTrackerAndroid::~NativeWindowTrackerAndroid() {
+}
+
+bool NativeWindowTrackerAndroid::WasNativeWindowClosed() const {
+  return window_ == nullptr;
+}
+
+// static
+std::unique_ptr<NativeWindowTracker> NativeWindowTracker::Create(
+    gfx::NativeWindow window) {
+  return std::unique_ptr<NativeWindowTracker>(
+      new NativeWindowTrackerAndroid(window));
+}
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.h
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+#define CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/ui/native_window_tracker.h"
+#include "ui/android/window_android.h"
+
+class NativeWindowTrackerAndroid : public NativeWindowTracker {
+ public:
+  explicit NativeWindowTrackerAndroid(gfx::NativeWindow window);
+  ~NativeWindowTrackerAndroid() override;
+
+  bool WasNativeWindowClosed() const override;
+
+ private:
+
+  gfx::NativeWindow window_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowTrackerAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_AURA_NATIVE_WINDOW_TRACKER_AURA_H_
--- a/chrome/browser/ui/page_info/page_info_ui.cc
+++ b/chrome/browser/ui/page_info/page_info_ui.cc
@@ -31,7 +31,7 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/android_theme_resources.h"
-#else
+
 #include "chrome/app/vector_icons/vector_icons.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/pref_names.h"
@@ -50,7 +50,7 @@ namespace {
 
 const int kInvalidResourceID = -1;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The icon size is actually 16, but the vector icons being used generally all
 // have additional internal padding. Account for this difference by asking for
 // the vectors in 18x18dip sizes.
@@ -110,7 +110,7 @@ static_assert(base::size(kPermissionButt
                   CONTENT_SETTING_NUM_SETTINGS,
               "kPermissionButtonTextIDDefaultSetting array size is incorrect");
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The resource IDs for the strings that are displayed on the sound permission
 // button if the sound permission setting is managed by the user.
 const int kSoundPermissionButtonTextIDUserManaged[] = {
@@ -176,7 +176,7 @@ base::span<const PermissionsUIInfo> GetC
          ? IDS_PAGE_INFO_TYPE_SENSORS
          : IDS_PAGE_INFO_TYPE_MOTION_SENSORS},
     {ContentSettingsType::USB_GUARD, IDS_PAGE_INFO_TYPE_USB},
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     {ContentSettingsType::SERIAL_GUARD, IDS_PAGE_INFO_TYPE_SERIAL},
 #endif
     {ContentSettingsType::NATIVE_FILE_SYSTEM_WRITE_GUARD,
@@ -554,7 +554,7 @@ int PageInfoUI::GetConnectionIconID(Page
   }
   return resource_id;
 }
-#else  // !defined(OS_ANDROID)
+
 // static
 const gfx::ImageSkia PageInfoUI::GetPermissionIcon(const PermissionInfo& info,
                                                    SkColor related_text_color) {
--- a/chrome/browser/ui/page_info/page_info_ui.h
+++ b/chrome/browser/ui/page_info/page_info_ui.h
@@ -18,7 +18,7 @@
 #include "components/safe_browsing/buildflags.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "ui/gfx/image/image_skia.h"
 #endif
 
@@ -204,7 +204,7 @@ class PageInfoUI {
 
   // Returns the connection icon ID for the given connection |status|.
   static int GetConnectionIconID(PageInfo::SiteConnectionStatus status);
-#else  // !defined(OS_ANDROID)
+
   // Returns icons for the given PermissionInfo |info|. If |info|'s current
   // setting is CONTENT_SETTING_DEFAULT, it will return the icon for |info|'s
   // default setting.
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
@@ -44,7 +44,7 @@
 #include "components/undo/undo_operation.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/extensions/api/passwords_private/passwords_private_utils.h"
 #endif
 
@@ -342,7 +342,7 @@ void PasswordManagerPresenter::UndoRemov
   undo_manager_.Undo();
 }
 
-#if !defined(OS_ANDROID)  // This is never called on Android.
+#if true || !defined(OS_ANDROID)  // This is never called on Android.
 void PasswordManagerPresenter::RequestShowPassword(
     const std::string& sort_key,
     base::OnceCallback<void(base::Optional<base::string16>)> callback) const {
--- a/chrome/browser/ui/screen_capture_notification_ui_stub.cc
+++ b/chrome/browser/ui/screen_capture_notification_ui_stub.cc
@@ -20,8 +20,10 @@ class ScreenCaptureNotificationUIStub :
 };
 
 // static
+#if 0
 std::unique_ptr<ScreenCaptureNotificationUI>
 ScreenCaptureNotificationUI::Create(const base::string16& title) {
   return std::unique_ptr<ScreenCaptureNotificationUI>(
       new ScreenCaptureNotificationUIStub());
 }
+#endif
--- a/chrome/browser/ui/search/instant_controller.h
+++ b/chrome/browser/ui/search/instant_controller.h
@@ -12,10 +12,6 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class Profile;
 class TabStripModel;
 
--- a/chrome/browser/ui/search/ntp_user_data_logger.h
+++ b/chrome/browser/ui/search/ntp_user_data_logger.h
@@ -21,10 +21,6 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 }
--- a/chrome/browser/ui/search/search_ipc_router.h
+++ b/chrome/browser/ui/search/search_ipc_router.h
@@ -21,10 +21,6 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/associated_receiver.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class GURL;
 
 namespace content {
--- a/chrome/browser/ui/search/search_ipc_router_policy_impl.h
+++ b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
@@ -9,10 +9,6 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/search/search_ipc_router.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 }
--- a/chrome/browser/ui/search/search_tab_helper.h
+++ b/chrome/browser/ui/search/search_tab_helper.h
@@ -29,10 +29,6 @@
 #include "content/public/browser/web_contents_user_data.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 struct LoadCommittedDetails;
--- a/chrome/browser/ui/signin_view_controller.h
+++ b/chrome/browser/ui/signin_view_controller.h
@@ -13,9 +13,11 @@
 #include "components/signin/public/base/signin_buildflags.h"
 #include "url/gurl.h"
 
+#if 0
 #if defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
+#endif
 
 class Browser;
 class SigninViewControllerDelegate;
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -366,8 +366,10 @@ void TabHelpers::AttachTabHelpers(WebCon
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::TabHelper::CreateForWebContents(web_contents);
+#if 0
   if (web_app::AreWebAppsEnabled(profile))
     web_app::WebAppTabHelper::CreateForWebContents(web_contents);
+#endif
   if (SiteEngagementService::IsEnabled())
     web_app::WebAppMetrics::Get(profile);
 #endif
--- a/chrome/browser/ui/tabs/tab_strip_model.cc
+++ b/chrome/browser/ui/tabs/tab_strip_model.cc
@@ -1005,11 +1005,15 @@ void TabStripModel::CloseSelectedTabs()
 }
 
 void TabStripModel::SelectNextTab(UserGestureDetails detail) {
+#if 0
   SelectRelativeTab(true, detail);
+#endif
 }
 
 void TabStripModel::SelectPreviousTab(UserGestureDetails detail) {
+#if 0
   SelectRelativeTab(false, detail);
+#endif
 }
 
 void TabStripModel::SelectLastTab(UserGestureDetails detail) {
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -31,10 +31,6 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/page_transition_types.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Profile;
 class TabGroupModel;
 class TabStripModelDelegate;
--- /dev/null
+++ b/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
@@ -0,0 +1,59 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/toolbar/component_toolbar_actions_factory.h"
+
+#include "base/command_line.h"
+#include "base/lazy_instance.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/media/router/media_router_feature.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/toolbar/media_router_action.h"
+#include "chrome/browser/ui/toolbar/media_router_action_controller.h"
+#include "chrome/browser/ui/toolbar/toolbar_action_view_controller.h"
+#include "chrome/browser/ui/toolbar/toolbar_actions_bar.h"
+#include "extensions/browser/extension_registry.h"
+
+// static
+const char ComponentToolbarActionsFactory::kMediaRouterActionId[] =
+    "media_router_action";
+
+ComponentToolbarActionsFactory::ComponentToolbarActionsFactory(
+    Profile* profile) {
+}
+
+ComponentToolbarActionsFactory::~ComponentToolbarActionsFactory() {}
+
+std::set<std::string> ComponentToolbarActionsFactory::GetInitialComponentIds() {
+  // TODO(takumif): Instead of keeping track of |initial_ids_|, simplify by
+  // checking here whether MediaRouterAction should be visible.
+  return initial_ids_;
+}
+
+void ComponentToolbarActionsFactory::OnAddComponentActionBeforeInit(
+    const std::string& action_id) {
+  initial_ids_.insert(action_id);
+}
+
+void ComponentToolbarActionsFactory::OnRemoveComponentActionBeforeInit(
+    const std::string& action_id) {
+  initial_ids_.erase(action_id);
+}
+
+std::unique_ptr<ToolbarActionViewController>
+ComponentToolbarActionsFactory::GetComponentToolbarActionForId(
+    const std::string& action_id,
+    Browser* browser,
+    ToolbarActionsBar* bar) {
+  // Add component toolbar actions here.
+  // This current design means that the ComponentToolbarActionsFactory is aware
+  // of all actions. Since we should *not* have an excessive amount of these
+  // (since each will have an action in the toolbar or overflow menu), this
+  // should be okay. If this changes, we should rethink this design to have,
+  // e.g., RegisterChromeAction().
+
+  NOTREACHED();
+  return std::unique_ptr<ToolbarActionViewController>();
+}
--- a/chrome/browser/ui/unload_controller.cc
+++ b/chrome/browser/ui/unload_controller.cc
@@ -50,7 +50,7 @@ bool UnloadController::ShouldRunUnloadEv
     content::WebContents* contents) {
   // If |contents| is being inspected, devtools needs to intercept beforeunload
   // events.
-  return DevToolsWindow::GetInstanceForInspectedWebContents(contents) != NULL;
+  return false;
 }
 
 bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
@@ -67,20 +67,6 @@ bool UnloadController::RunUnloadEventsHe
   }
 #endif  // (ENABLE_EXTENSIONS)
 
-  // Special case for when we quit an application. The devtools window can
-  // close if it's beforeunload event has already fired which will happen due
-  // to the interception of it's content's beforeunload.
-  if (browser_->is_type_devtools() &&
-      DevToolsWindow::HasFiredBeforeUnloadEventForDevToolsBrowser(browser_))
-    return false;
-
-  // If there's a devtools window attached to |contents|,
-  // we would like devtools to call its own beforeunload handlers first,
-  // and then call beforeunload handlers for |contents|.
-  // See DevToolsWindow::InterceptPageBeforeUnload for details.
-  if (DevToolsWindow::InterceptPageBeforeUnload(contents)) {
-    return true;
-  }
   // If the WebContents is not connected yet, then there's no unload
   // handler we can fire even if the WebContents has an unload listener.
   // One case where we hit this is in a tab that has an infinite loop
@@ -98,9 +84,6 @@ bool UnloadController::RunUnloadEventsHe
 
 bool UnloadController::BeforeUnloadFired(content::WebContents* contents,
                                          bool proceed) {
-  if (!proceed)
-    DevToolsWindow::OnPageCloseCanceled(contents);
-
   if (!is_attempting_to_close_browser_) {
     if (!proceed)
       contents->SetClosedByUserGesture(false);
@@ -131,14 +114,6 @@ bool UnloadController::ShouldCloseWindow
   if (HasCompletedUnloadProcessing())
     return true;
 
-  // Special case for when we quit an application. The devtools window can
-  // close if it's beforeunload event has already fired which will happen due
-  // to the interception of it's content's beforeunload.
-  if (browser_->is_type_devtools() &&
-      DevToolsWindow::HasFiredBeforeUnloadEventForDevToolsBrowser(browser_)) {
-    return true;
-  }
-
   // The behavior followed here varies based on the current phase of the
   // operation and whether a batched shutdown is in progress.
   //
@@ -188,6 +163,7 @@ void UnloadController::ResetTryToCloseWi
 }
 
 bool UnloadController::TabsNeedBeforeUnloadFired() {
+#if 0
   if (tabs_needing_before_unload_fired_.empty()) {
     for (int i = 0; i < browser_->tab_strip_model()->count(); ++i) {
       content::WebContents* contents =
@@ -201,6 +177,7 @@ bool UnloadController::TabsNeedBeforeUnl
       }
     }
   }
+#endif
   return !tabs_needing_before_unload_fired_.empty();
 }
 
@@ -210,10 +187,6 @@ void UnloadController::CancelWindowClose
   // case some of this code might not have an effect, but it's still useful to,
   // for example, call the notification(s).
   tabs_needing_before_unload_fired_.clear();
-  for (auto it = tabs_needing_unload_fired_.begin();
-       it != tabs_needing_unload_fired_.end(); ++it) {
-    DevToolsWindow::OnPageCloseCanceled(*it);
-  }
   tabs_needing_unload_fired_.clear();
   if (is_calling_before_unload_handlers()) {
     base::Callback<void(bool)> on_close_confirmed = on_close_confirmed_;
@@ -328,8 +301,6 @@ void UnloadController::ProcessPendingTab
       // we would like devtools to call its own beforeunload handlers first,
       // and then call beforeunload handlers for |web_contents|.
       // See DevToolsWindow::InterceptPageBeforeUnload for details.
-      if (!DevToolsWindow::InterceptPageBeforeUnload(web_contents))
-        web_contents->DispatchBeforeUnload(false /* auto_cancel */);
     } else {
       ClearUnloadState(web_contents, true);
     }
--- a/chrome/browser/ui/views/BUILD.gn
+++ b/chrome/browser/ui/views/BUILD.gn
@@ -5,8 +5,6 @@
 import("//build/config/ui.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
-
 component("views") {
   output_name = "browser_ui_views"
   sources = [
--- /dev/null
+++ b/chrome/browser/ui/views/accelerator_utils_android.cc
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/views/accelerator_table.h"
+#include "ui/base/accelerators/accelerator.h"
+
+#if defined(OS_CHROMEOS)
+#include "ash/public/cpp/accelerators.h"
+#endif
+
+namespace chrome {
+
+bool IsChromeAccelerator(const ui::Accelerator& accelerator, Profile* profile) {
+  return false;
+}
+
+ui::Accelerator GetPrimaryChromeAcceleratorForBookmarkPage() {
+  return ui::Accelerator();
+}
+
+ui::Accelerator GetPrimaryChromeAcceleratorForBookmarkTab() {
+  return ui::Accelerator();
+}
+
+}  // namespace chrome
--- a/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
+++ b/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
@@ -407,7 +407,9 @@ void AutofillPopupItemView::OnGestureEve
 }
 
 void AutofillPopupItemView::CreateContent() {
+#if 0
   AutofillPopupController* controller = popup_view()->controller();
+#endif
 
   auto* layout_manager = SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::Orientation::kHorizontal,
@@ -416,8 +418,7 @@ void AutofillPopupItemView::CreateConten
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::kCenter);
 
-  const gfx::ImageSkia icon =
-      controller->layout_model().GetIconImage(line_number());
+  const gfx::ImageSkia icon = gfx::ImageSkia();
 
   if (!icon.isNull()) {
     AddIcon(icon);
@@ -681,7 +682,9 @@ void AutofillPopupFooterView::CreateCont
       /*right=*/0,
       /*color=*/popup_view()->GetSeparatorColor()));
 
+#if 0
   AutofillPopupController* controller = popup_view()->controller();
+#endif
 
   views::BoxLayout* layout_manager =
       SetLayoutManager(std::make_unique<views::BoxLayout>(
@@ -691,8 +694,7 @@ void AutofillPopupFooterView::CreateCont
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::kStretch);
 
-  const gfx::ImageSkia icon =
-      controller->layout_model().GetIconImage(line_number());
+  const gfx::ImageSkia icon = gfx::ImageSkia();
 
   // A FooterView shows an icon, if any, on the trailing (right in LTR) side,
   // but the Show Account Cards context is an anomaly. Its icon is on the
--- a/chrome/browser/ui/views/browser_dialogs_views.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views.cc
@@ -15,17 +15,6 @@
 #include "chrome/browser/ui/views/bookmarks/bookmark_editor_view.h"
 #include "chrome/browser/ui/views/task_manager_view.h"
 
-// This file provides definitions of desktop browser dialog-creation methods for
-// all toolkit-views platforms.
-// static
-std::unique_ptr<LoginHandler> LoginHandler::Create(
-    const net::AuthChallengeInfo& auth_info,
-    content::WebContents* web_contents,
-    LoginAuthRequiredCallback auth_required_callback) {
-  return chrome::CreateLoginHandlerViews(auth_info, web_contents,
-                                         std::move(auth_required_callback));
-}
-
 // static
 void BookmarkEditor::Show(gfx::NativeWindow parent_window,
                           Profile* profile,
--- /dev/null
+++ b/chrome/browser/ui/views/chrome_views_delegate_android.cc
@@ -0,0 +1,15 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/chrome_views_delegate.h"
+
+#include "base/feature_list.h"
+#include "chrome/common/chrome_features.h"
+
+views::NativeWidget* ChromeViewsDelegate::CreateNativeWidget(
+    views::Widget::InitParams* params,
+    views::internal::NativeWidgetDelegate* delegate) {
+  // By returning null Widget creates the default NativeWidget implementation.
+  return nullptr;
+}
--- a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
+++ b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
@@ -171,7 +171,7 @@ void DesktopMediaListView::OnSourceAdded
   source_view->SetName(source.name);
   source_view->SetGroup(kDesktopMediaSourceViewGroupId);
   if (source.id.type == DesktopMediaID::TYPE_WINDOW) {
-    gfx::ImageSkia icon_image = GetWindowIcon(source.id);
+    gfx::ImageSkia icon_image = gfx::ImageSkia();
 #if defined(OS_CHROMEOS)
     // Empty icons are used to represent default icon for aura windows. By
     // detecting this, we load the default icon from resource.
--- /dev/null
+++ b/chrome/browser/ui/views/dropdown_bar_host_android.cc
@@ -0,0 +1,10 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/dropdown_bar_host.h"
+
+#include "ui/views/widget/widget.h"
+
+void DropdownBarHost::SetHostViewNative(views::View* host_view) {
+}
--- a/chrome/browser/ui/views/find_bar_host.cc
+++ b/chrome/browser/ui/views/find_bar_host.cc
@@ -115,10 +115,6 @@ bool FindBarHost::MaybeForwardKeyEventTo
   // Make sure we don't have a text field element interfering with keyboard
   // input. Otherwise Up and Down arrow key strokes get eaten. "Nom Nom Nom".
   contents->ClearFocusedElement();
-  NativeWebKeyboardEvent event(key_event);
-  contents->GetRenderViewHost()
-      ->GetWidget()
-      ->ForwardKeyboardEventWithLatencyInfo(event, *key_event.latency());
   return true;
 }
 
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -32,6 +32,7 @@
 #include "ui/events/event_handler.h"
 #include "ui/gfx/font_list.h"
 #include "ui/native_theme/native_theme_dark_aura.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/controls/menu/menu_runner.h"
 #include "ui/views/widget/native_widget.h"
 
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
@@ -61,7 +61,6 @@ BrowserNonClientFrameView* CreateBrowser
 #endif
   OpaqueBrowserFrameView* view =
       CreateOpaqueBrowserFrameView(frame, browser_view);
-  view->InitViews();
   return view;
 }
 
--- a/chrome/browser/ui/views/frame/browser_root_view.cc
+++ b/chrome/browser/ui/views/frame/browser_root_view.cc
@@ -73,13 +73,6 @@ void OnFindURLMimeType(const GURL& url,
   // to do disk access.
   bool result = mime_type.empty() || blink::IsSupportedMimeType(mime_type);
 
-#if BUILDFLAG(ENABLE_PLUGINS)
-  content::WebPluginInfo plugin;
-  result = result || content::PluginService::GetInstance()->GetPluginInfo(
-                         process_id, routing_id, url, url::Origin(), mime_type,
-                         false, nullptr, &plugin, nullptr);
-#endif
-
   std::move(callback).Run(url, result);
 }
 
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -917,6 +917,7 @@ void BrowserView::OnActiveTabChanged(con
                                      content::WebContents* new_contents,
                                      int index,
                                      int reason) {
+#if 0
   DCHECK(new_contents);
   TRACE_EVENT0("ui", "BrowserView::OnActiveTabChanged");
 
@@ -1025,10 +1026,12 @@ void BrowserView::OnActiveTabChanged(con
   UpdateTitleBar();
 
   TranslateBubbleView::CloseCurrentBubble();
+#endif
 }
 
 void BrowserView::OnTabDetached(content::WebContents* contents,
                                 bool was_active) {
+#if 0
   if (was_active) {
     // We need to reset the current tab contents to null before it gets
     // freed. This is because the focus manager performs some operations
@@ -1041,6 +1044,7 @@ void BrowserView::OnTabDetached(content:
     app_banner_manager_observer_.RemoveAll();
     UpdateDevToolsForContents(nullptr, true);
   }
+#endif
 }
 
 void BrowserView::OnTabRestored(int command_id) {
@@ -1172,11 +1176,14 @@ void BrowserView::OnExclusiveAccessUserI
 }
 
 bool BrowserView::ShouldHideUIForFullscreen() const {
+#if 0
   // Immersive mode needs UI for the slide-down top panel.
   if (immersive_mode_controller_->IsEnabled())
+#endif
     return false;
-
+#if 0
   return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+#endif
 }
 
 bool BrowserView::IsFullscreen() const {
@@ -1253,28 +1260,36 @@ void BrowserView::SetFocusToLocationBar(
 }
 
 void BrowserView::UpdateReloadStopState(bool is_loading, bool force) {
+#if 0
   if (toolbar_button_provider_->GetReloadButton()) {
     toolbar_button_provider_->GetReloadButton()->ChangeMode(
         is_loading ? ReloadButton::Mode::kStop : ReloadButton::Mode::kReload,
         force);
   }
+#endif
 }
 
 void BrowserView::UpdateToolbar(content::WebContents* contents) {
+#if 0
   // We may end up here during destruction.
   if (toolbar_)
     toolbar_->Update(contents);
+#endif
 }
 
 void BrowserView::UpdateCustomTabBarVisibility(bool visible, bool animate) {
+#if 0
   if (toolbar_)
     toolbar_->UpdateCustomTabBarVisibility(visible, animate);
+#endif
 }
 
 void BrowserView::ResetToolbarTabState(content::WebContents* contents) {
+#if 0
   // We may end up here during destruction.
   if (toolbar_)
     toolbar_->ResetTabState(contents);
+#endif
 }
 
 void BrowserView::FocusToolbar() {
@@ -1294,13 +1309,7 @@ void BrowserView::FocusToolbar() {
 ExtensionsContainer* BrowserView::GetExtensionsContainer() {
   ExtensionsToolbarContainer* const extensions_toolbar_container =
       toolbar_button_provider_->GetExtensionsToolbarContainer();
-  if (extensions_toolbar_container)
-    return extensions_toolbar_container;
-
-  CHECK(!base::FeatureList::IsEnabled(features::kExtensionsToolbarMenu));
-  BrowserActionsContainer* container =
-      toolbar_button_provider_->GetBrowserActionsContainer();
-  return container ? container->toolbar_actions_bar() : nullptr;
+  return extensions_toolbar_container ? extensions_toolbar_container : nullptr;
 }
 
 void BrowserView::ToolbarSizeChanged(bool is_animating) {
@@ -1354,6 +1363,7 @@ void BrowserView::FocusBookmarksToolbar(
 }
 
 void BrowserView::FocusInactivePopupForAccessibility() {
+#if 0
   if (GetLocationBarView()->ActivateFirstInactiveBubbleForAccessibility())
     return;
 
@@ -1366,6 +1376,7 @@ void BrowserView::FocusInactivePopupForA
 
   if (!infobar_container_->children().empty())
     infobar_container_->SetPaneFocusAndFocusDefault();
+#endif
 }
 
 void BrowserView::FocusAppMenu() {
--- a/chrome/browser/ui/views/frame/browser_window_factory.cc
+++ b/chrome/browser/ui/views/frame/browser_window_factory.cc
@@ -20,18 +20,8 @@
 BrowserWindow* BrowserWindow::CreateBrowserWindow(
     std::unique_ptr<Browser> browser,
     bool user_gesture) {
-  // Create the view and the frame. The frame will attach itself via the view
-  // so we don't need to do anything with the pointer.
   BrowserView* view = new BrowserView(std::move(browser));
   (new BrowserFrame(view))->InitBrowserFrame();
-  view->GetWidget()->non_client_view()->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_PRODUCT_NAME));
 
-#if defined(USE_AURA)
-  // For now, all browser windows are true. This only works when USE_AURA
-  // because it requires gfx::NativeWindow to be an aura::Window*.
-  view->GetWidget()->GetNativeWindow()->SetProperty(
-      aura::client::kCreatedByUserGesture, user_gesture);
-#endif
   return view;
 }
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
@@ -0,0 +1,75 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/ui/views/frame/browser_desktop_window_tree_host.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "ui/base/hit_test.h"
+#include "ui/base/models/simple_menu_model.h"
+#include "ui/gfx/font.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/visibility_controller.h"
+
+using aura::Window;
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAura, public:
+
+DesktopBrowserFrameAndroid::DesktopBrowserFrameAndroid(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view)
+    : browser_view_(browser_view),
+      browser_frame_(browser_frame) {
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, protected:
+
+DesktopBrowserFrameAndroid::~DesktopBrowserFrameAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, NativeBrowserFrame implementation:
+
+views::Widget::InitParams DesktopBrowserFrameAndroid::GetWidgetParams() {
+  views::Widget::InitParams params;
+  return params;
+}
+
+bool DesktopBrowserFrameAndroid::UseCustomFrame() const {
+  return true;
+}
+
+bool DesktopBrowserFrameAndroid::UsesNativeSystemMenu() const {
+  return true;
+}
+
+int DesktopBrowserFrameAndroid::GetMinimizeButtonOffset() const {
+  return 0;
+}
+
+bool DesktopBrowserFrameAndroid::ShouldSaveWindowPlacement() const {
+  // The placement can always be stored.
+  return true;
+}
+
+void DesktopBrowserFrameAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+  *show_state = ui::SHOW_STATE_NORMAL;
+}
+
+content::KeyboardEventProcessingResult
+DesktopBrowserFrameAndroid::PreHandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return content::KeyboardEventProcessingResult::NOT_HANDLED;
+}
+
+bool DesktopBrowserFrameAndroid::HandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return false;
+}
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/ui/views/frame/native_browser_frame.h"
+#include "ui/views/context_menu_controller.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+
+class BrowserDesktopWindowTreeHost;
+class BrowserFrame;
+class BrowserView;
+
+namespace wm {
+class VisibilityController;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid
+//
+//  DesktopBrowserFrameAndroid is a DesktopNativeWidgetAndroid subclass that provides
+//  the window frame for the Chrome browser window.
+//
+class DesktopBrowserFrameAndroid : public NativeBrowserFrame {
+ public:
+  DesktopBrowserFrameAndroid(BrowserFrame* browser_frame,
+                          BrowserView* browser_view);
+
+  BrowserView* browser_view() const { return browser_view_; }
+  BrowserFrame* browser_frame() const { return browser_frame_; }
+
+ protected:
+  ~DesktopBrowserFrameAndroid() override;
+
+  // Overridden from NativeBrowserFrame:
+  views::Widget::InitParams GetWidgetParams() override;
+  bool UseCustomFrame() const override;
+  bool UsesNativeSystemMenu() const override;
+  int GetMinimizeButtonOffset() const override;
+  bool ShouldSaveWindowPlacement() const override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* show_state) const override;
+  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+  bool HandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+
+ private:
+  // The BrowserView is our ClientView. This is a pointer to it.
+  BrowserView* browser_view_;
+  BrowserFrame* browser_frame_;
+
+  std::unique_ptr<wm::VisibilityController> visibility_controller_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopBrowserFrameAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_Android_H_
--- /dev/null
+++ b/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/native_browser_frame_factory.h"
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+NativeBrowserFrame* NativeBrowserFrameFactory::Create(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view) {
+  return new DesktopBrowserFrameAndroid(browser_frame, browser_view);
+}
--- a/chrome/browser/ui/views/javascript_dialog_views.cc
+++ b/chrome/browser/ui/views/javascript_dialog_views.cc
@@ -110,6 +110,7 @@ JavaScriptDialogViews::JavaScriptDialogV
 // Creates a new JS dialog. Note the two callbacks; |dialog_callback| is for
 // user responses, while |dialog_force_closed_callback| is for when Views
 // forces the dialog closed without a user reply.
+#if 0
 base::WeakPtr<JavaScriptDialog>
 JavaScriptDialogTabHelperDelegateDesktop::CreateNewDialog(
     content::WebContents* alerting_web_contents,
@@ -125,3 +126,4 @@ JavaScriptDialogTabHelperDelegateDesktop
               std::move(dialog_force_closed_callback)))
       ->weak_factory_.GetWeakPtr();
 }
+#endif
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -357,7 +357,7 @@ void LocationBarView::SelectAll() {
 void LocationBarView::FocusLocation(bool is_user_initiated) {
   const bool omnibox_already_focused = omnibox_view_->HasFocus();
 
-  omnibox_view_->SetFocus(is_user_initiated);
+  // omnibox_view_->SetFocus(is_user_initiated);
 
   if (omnibox_already_focused)
     omnibox_view()->model()->ClearKeyword();
@@ -373,7 +373,7 @@ void LocationBarView::FocusLocation(bool
 }
 
 void LocationBarView::Revert() {
-  omnibox_view_->RevertAll();
+  // omnibox_view_->RevertAll();
 }
 
 OmniboxView* LocationBarView::GetOmniboxView() {
@@ -381,7 +381,7 @@ OmniboxView* LocationBarView::GetOmnibox
 }
 
 bool LocationBarView::HasFocus() const {
-  return omnibox_view_ && omnibox_view_->model()->has_focus();
+  return false;
 }
 
 void LocationBarView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
@@ -390,9 +390,12 @@ void LocationBarView::GetAccessibleNodeD
 
 gfx::Size LocationBarView::GetMinimumSize() const {
   const int height = GetLayoutConstant(LOCATION_BAR_HEIGHT);
+#if 0
   if (!IsInitialized())
+#endif
     return gfx::Size(0, height);
 
+#if 0
   const int inset_width = GetInsets().width();
   const int padding = GetLayoutConstant(LOCATION_BAR_ELEMENT_PADDING);
   const int leading_width = GetMinimumLeadingWidth();
@@ -439,14 +442,16 @@ gfx::Size LocationBarView::CalculatePref
     width += trailing_width + padding;
 
   return gfx::Size(width, height);
+#endif
 }
 
 void LocationBarView::OnKeywordFaviconFetched(const gfx::Image& icon) {
-  DCHECK(!icon.IsEmpty());
-  selected_keyword_view_->SetCustomImage(icon);
+  //DCHECK(!icon.IsEmpty());
+  //selected_keyword_view_->SetCustomImage(icon);
 }
 
 void LocationBarView::Layout() {
+#if 0
   if (!IsInitialized())
     return;
 
@@ -608,9 +613,11 @@ void LocationBarView::Layout() {
   }
   omnibox_view_->SetBoundsRect(location_bounds);
   View::Layout();
+#endif
 }
 
 void LocationBarView::OnThemeChanged() {
+#if 0
   // ToolbarView::Init() adds |this| to the view hierarchy before initializing,
   // which will trigger an early theme change.
   if (!IsInitialized())
@@ -623,14 +630,18 @@ void LocationBarView::OnThemeChanged() {
 
   RefreshBackground();
   RefreshClearAllButtonIcon();
+#endif
 }
 
 void LocationBarView::ChildPreferredSizeChanged(views::View* child) {
+#if 0
   Layout();
   SchedulePaint();
+#endif
 }
 
 void LocationBarView::Update(const WebContents* contents) {
+#if 0
   RefreshContentSettingViews();
 
   RefreshPageActionIconViews();
@@ -648,15 +659,15 @@ void LocationBarView::Update(const WebCo
     send_tab_to_self_icon->SetVisible(false);
 
   OnChanged();  // NOTE: Calls Layout().
+#endif
 }
 
 void LocationBarView::ResetTabState(WebContents* contents) {
-  omnibox_view_->ResetTabState(contents);
+  // omnibox_view_->ResetTabState(contents);
 }
 
 bool LocationBarView::ActivateFirstInactiveBubbleForAccessibility() {
-  return page_action_icon_controller_
-      ->ActivateFirstInactiveBubbleForAccessibility();
+  return false;
 }
 
 void LocationBarView::UpdateWithoutTabRestore() {
--- a/chrome/browser/ui/views/location_bar/location_bar_view.h
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.h
@@ -177,7 +177,9 @@ class LocationBarView : public LocationB
   bool HasFocus() const override;
   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
   gfx::Size GetMinimumSize() const override;
+#if 0
   gfx::Size CalculatePreferredSize() const override;
+#endif
   void Layout() override;
   void OnThemeChanged() override;
   void ChildPreferredSizeChanged(views::View* child) override;
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
@@ -171,7 +171,7 @@ void OmniboxPopupContentsView::OpenMatch
 gfx::Image OmniboxPopupContentsView::GetMatchIcon(
     const AutocompleteMatch& match,
     SkColor vector_icon_color) const {
-  return model_->GetMatchIcon(match, vector_icon_color);
+  return gfx::Image();
 }
 
 void OmniboxPopupContentsView::SetSelectedLine(size_t index) {
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
@@ -70,6 +70,7 @@ void PermissionPromptBubbleView::AddPerm
                          DISTANCE_SUBSECTION_HORIZONTAL_INDENT)),
       provider->GetDistanceMetric(views::DISTANCE_RELATED_LABEL_HORIZONTAL)));
 
+#if 0
   auto* icon =
       line_container->AddChildView(std::make_unique<views::ImageView>());
   const gfx::VectorIcon& vector_id = request->GetIconId();
@@ -78,6 +79,7 @@ void PermissionPromptBubbleView::AddPerm
   constexpr int kPermissionIconSize = 18;
   icon->SetImage(
       gfx::CreateVectorIcon(vector_id, kPermissionIconSize, icon_color));
+#endif
 
   auto* label = line_container->AddChildView(
       std::make_unique<views::Label>(request->GetMessageTextFragment()));
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
@@ -15,6 +15,7 @@
 #include "ui/views/bubble/bubble_frame_view.h"
 
 // static
+#if 0
 std::unique_ptr<PermissionPrompt> PermissionPrompt::Create(
     content::WebContents* web_contents,
     Delegate* delegate) {
@@ -27,6 +28,7 @@ std::unique_ptr<PermissionPrompt> Permis
   return std::make_unique<PermissionPromptImpl>(browser, web_contents,
                                                 delegate);
 }
+#endif
 
 PermissionPromptImpl::PermissionPromptImpl(Browser* browser,
                                            content::WebContents* web_contents,
--- /dev/null
+++ b/chrome/browser/ui/views/profiles/avatar_button.cc
@@ -0,0 +1,559 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/profiles/avatar_button.h"
+
+#include <memory>
+#include <utility>
+
+#include "build/build_config.h"
+#include "chrome/app/vector_icons/vector_icons.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/profiles/profiles_state.h"
+#include "chrome/browser/signin/account_consistency_mode_manager.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/browser/themes/theme_properties.h"
+#include "chrome/browser/themes/theme_service.h"
+#include "chrome/browser/themes/theme_service_factory.h"
+#include "chrome/browser/ui/views/frame/avatar_button_manager.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/browser/ui/views/profiles/profile_chooser_view.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/grit/theme_resources.h"
+#include "components/keyed_service/content/browser_context_keyed_service_shutdown_notifier_factory.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/base/theme_provider.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/color_palette.h"
+#include "ui/gfx/color_utils.h"
+#include "ui/gfx/paint_vector_icon.h"
+#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
+#include "ui/views/animation/ink_drop_impl.h"
+#include "ui/views/animation/ink_drop_mask.h"
+#include "ui/views/controls/button/label_button_border.h"
+
+#if defined(OS_WIN)
+#include "base/win/windows_version.h"
+#include "chrome/browser/ui/views/frame/minimize_button_metrics_win.h"
+#endif
+
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+#include "chrome/browser/ui/views/nav_button_provider.h"
+#endif
+
+namespace {
+
+#if 0
+constexpr int kGenericAvatarIconSize = 16;
+#endif
+
+// TODO(emx): Calculate width based on caption button [http://crbug.com/716365]
+constexpr int kCondensibleButtonMinWidth = 46;
+// TODO(emx): Should this be calculated based on average character width?
+constexpr int kCondensibleButtonMaxWidth = 98;
+
+#if defined(OS_WIN)
+constexpr gfx::Insets kBorderInsets(2, 8, 4, 8);
+
+std::unique_ptr<views::Border> CreateThemedBorder(
+    const int normal_image_set[],
+    const int hot_image_set[],
+    const int pushed_image_set[]) {
+  std::unique_ptr<views::LabelButtonAssetBorder> border(
+      new views::LabelButtonAssetBorder(views::Button::STYLE_TEXTBUTTON));
+
+  border->SetPainter(false, views::Button::STATE_NORMAL,
+                     views::Painter::CreateImageGridPainter(normal_image_set));
+  border->SetPainter(false, views::Button::STATE_HOVERED,
+                     views::Painter::CreateImageGridPainter(hot_image_set));
+  border->SetPainter(false, views::Button::STATE_PRESSED,
+                     views::Painter::CreateImageGridPainter(pushed_image_set));
+
+  border->set_insets(kBorderInsets);
+
+  return std::move(border);
+}
+#endif
+
+#if defined(OS_MACOSX)
+constexpr int kMacButtonHeight = 24;
+#endif
+
+// This class draws the border (and background) of the avatar button for
+// "themed" browser windows, i.e. OpaqueBrowserFrameView. Currently it's only
+// used on Linux as the shape specifically matches the Linux caption buttons.
+// TODO(estade): make this look nice on Windows and use it there as well.
+class AvatarButtonThemedBorder : public views::Border {
+ public:
+  AvatarButtonThemedBorder() {}
+  ~AvatarButtonThemedBorder() override {}
+
+  void Paint(const views::View& view, gfx::Canvas* canvas) override {
+    // Fill the color/background image from the theme.
+    cc::PaintFlags fill_flags;
+    fill_flags.setAntiAlias(true);
+    const ui::ThemeProvider* theme = view.GetThemeProvider();
+    fill_flags.setColor(
+        theme->GetColor(ThemeProperties::COLOR_BUTTON_BACKGROUND));
+    SkPath fill_path;
+    gfx::Rect fill_bounds = view.GetLocalBounds();
+    // The fill should overlap the inner stroke but not the outer stroke. But we
+    // don't inset the top because as it stands, the asset-based window controls
+    // fill one pixel higher due to how the background masking works out. Not
+    // matching that is very noticeable. TODO(estade): when the window
+    // controls use this same code, inset all sides equally.
+    fill_bounds.Inset(gfx::Insets(0, kStrokeWidth, kStrokeWidth, kStrokeWidth));
+    fill_path.addRoundRect(gfx::RectToSkRect(fill_bounds), kCornerRadius,
+                           kCornerRadius);
+    canvas->DrawPath(fill_path, fill_flags);
+    fill_flags.setColor(SK_ColorBLACK);
+    canvas->DrawImageInPath(
+        *theme->GetImageSkiaNamed(IDR_THEME_WINDOW_CONTROL_BACKGROUND), 0, 0,
+        fill_path, fill_flags);
+
+    // Paint an outer dark stroke.
+    cc::PaintFlags stroke_flags;
+    stroke_flags.setStyle(cc::PaintFlags::kStroke_Style);
+    // The colors are chosen to match the assets we use for Linux.
+    stroke_flags.setColor(SkColorSetA(SK_ColorBLACK, 0x2B));
+    stroke_flags.setStrokeWidth(kStrokeWidth);
+    stroke_flags.setAntiAlias(true);
+    gfx::RectF stroke_bounds(view.GetLocalBounds());
+    stroke_bounds.Inset(gfx::InsetsF(0.5f));
+    canvas->DrawRoundRect(stroke_bounds, kCornerRadius, stroke_flags);
+
+    // There's a second, light stroke that matches the fill bounds.
+    stroke_bounds.Inset(gfx::InsetsF(kStrokeWidth));
+    stroke_flags.setColor(SkColorSetA(SK_ColorWHITE, 0x3F));
+    canvas->DrawRoundRect(stroke_bounds, kCornerRadius, stroke_flags);
+  }
+
+  gfx::Insets GetInsets() const override {
+    auto insets = views::LabelButtonAssetBorder::GetDefaultInsetsForStyle(
+        views::Button::STYLE_TEXTBUTTON);
+    return kBorderStrokeInsets +
+           gfx::Insets(0, insets.left(), 0, insets.right());
+  }
+
+  gfx::Size GetMinimumSize() const override {
+    return gfx::Size(GetInsets().width(), GetInsets().height());
+  }
+
+  static std::unique_ptr<views::InkDropMask> CreateInkDropMask(
+      const gfx::Size& size) {
+    return std::make_unique<views::RoundRectInkDropMask>(
+        size, kBorderStrokeInsets, kCornerRadius);
+  }
+
+ private:
+  static constexpr int kStrokeWidth = 1;
+
+  // Insets between view bounds and the interior of the strokes.
+  static constexpr gfx::Insets kBorderStrokeInsets{kStrokeWidth * 2};
+
+  // Corner radius of the roundrect.
+  static constexpr float kCornerRadius = 1;
+
+  DISALLOW_COPY_AND_ASSIGN(AvatarButtonThemedBorder);
+};
+
+constexpr int AvatarButtonThemedBorder::kStrokeWidth;
+constexpr gfx::Insets AvatarButtonThemedBorder::kBorderStrokeInsets;
+constexpr float AvatarButtonThemedBorder::kCornerRadius;
+
+class AvatarButtonShutdownNotifierFactory
+    : public BrowserContextKeyedServiceShutdownNotifierFactory {
+ public:
+  static AvatarButtonShutdownNotifierFactory* GetInstance() {
+    return base::Singleton<AvatarButtonShutdownNotifierFactory>::get();
+  }
+
+ private:
+  friend struct base::DefaultSingletonTraits<
+      AvatarButtonShutdownNotifierFactory>;
+
+  AvatarButtonShutdownNotifierFactory()
+      : BrowserContextKeyedServiceShutdownNotifierFactory(
+            "AvatarButtonShutdownNotifierFactory") {
+    DependsOn(SigninManagerFactory::GetInstance());
+  }
+  ~AvatarButtonShutdownNotifierFactory() override {}
+
+  DISALLOW_COPY_AND_ASSIGN(AvatarButtonShutdownNotifierFactory);
+};
+
+#if defined(OS_WIN) || defined(OS_MACOSX)
+SkColor BaseColorForButton(const ui::ThemeProvider* theme_provider) {
+  return color_utils::IsDark(
+             theme_provider->GetColor(ThemeProperties::COLOR_FRAME))
+             ? SK_ColorWHITE
+             : SK_ColorBLACK;
+}
+
+gfx::ImageSkia AvatarIconWithBaseColor(const SkColor base_color) {
+  const SkColor icon_color =
+      SkColorSetA(base_color, static_cast<SkAlpha>(0.54 * 0xFF));
+  return gfx::CreateVectorIcon(kAccountCircleIcon, kGenericAvatarIconSize,
+                               icon_color);
+}
+#endif
+
+}  // namespace
+
+AvatarButton::AvatarButton(views::MenuButtonListener* listener,
+                           AvatarButtonStyle button_style,
+                           Profile* profile,
+                           AvatarButtonManager* manager)
+    : MenuButton(base::string16(), listener, false),
+      error_controller_(this, profile),
+      profile_(profile),
+      profile_observer_(this),
+      button_style_(button_style),
+      widget_observer_(this) {
+  DCHECK_NE(button_style, AvatarButtonStyle::NONE);
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+  views::NavButtonProvider* nav_button_provider =
+      manager->get_nav_button_provider();
+  render_native_nav_buttons_ = nav_button_provider != nullptr;
+#endif
+  set_notify_action(Button::NOTIFY_ON_PRESS);
+  set_triggerable_event_flags(ui::EF_LEFT_MOUSE_BUTTON |
+                              ui::EF_RIGHT_MOUSE_BUTTON);
+  set_animate_on_state_change(false);
+#if !defined(OS_MACOSX)
+  SetEnabledTextColors(SK_ColorWHITE);
+  SetTextSubpixelRenderingEnabled(false);
+#endif
+  SetHorizontalAlignment(gfx::ALIGN_CENTER);
+
+  profile_observer_.Add(
+      &g_browser_process->profile_manager()->GetProfileAttributesStorage());
+
+  // The largest text height that fits in the button. If the font list height
+  // is larger than this, it will be shrunk to match it.
+  // TODO(noms): Calculate this constant algorithmically from the button's size.
+  const int kDisplayFontHeight = 16;
+  label()->SetFontList(
+      label()->font_list().DeriveWithHeightUpperBound(kDisplayFontHeight));
+
+  bool apply_ink_drop = ShouldApplyInkDrop();
+  if (render_native_nav_buttons_) {
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+    SetBackground(nav_button_provider->CreateAvatarButtonBackground(this));
+    SetBorder(nullptr);
+    generic_avatar_ =
+        gfx::CreateVectorIcon(kProfileSwitcherOutlineIcon,
+                              kGenericAvatarIconSize, gfx::kChromeIconGrey);
+#endif
+  } else if (apply_ink_drop) {
+    SetInkDropMode(InkDropMode::ON);
+    SetFocusPainter(nullptr);
+#if defined(OS_LINUX)
+    set_ink_drop_base_color(SK_ColorWHITE);
+    SetBorder(std::make_unique<AvatarButtonThemedBorder>());
+    generic_avatar_ =
+        gfx::CreateVectorIcon(kProfileSwitcherOutlineIcon,
+                              kGenericAvatarIconSize, gfx::kChromeIconGrey);
+#elif defined(OS_WIN)
+    DCHECK_EQ(AvatarButtonStyle::NATIVE, button_style);
+    SetBorder(views::CreateEmptyBorder(kBorderInsets));
+  } else if (button_style == AvatarButtonStyle::THEMED) {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_THEMED_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+  } else if (base::win::GetVersion() < base::win::VERSION_WIN8) {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_GLASS_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+  } else {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_NATIVE_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+#endif
+  }
+
+  profile_shutdown_notifier_ =
+      AvatarButtonShutdownNotifierFactory::GetInstance()
+          ->Get(profile_)
+          ->Subscribe(base::Bind(&AvatarButton::OnProfileShutdown,
+                                 base::Unretained(this)));
+}
+
+AvatarButton::~AvatarButton() {}
+
+void AvatarButton::SetupThemeColorButton() {
+#if defined(OS_WIN)
+  if (IsCondensible()) {
+    // TODO(bsep): This needs to also be called when the Windows accent color
+    // updates, but there is currently no signal for that.
+    const SkColor base_color = BaseColorForButton(GetThemeProvider());
+    set_ink_drop_base_color(base_color);
+    generic_avatar_ = AvatarIconWithBaseColor(base_color);
+  }
+#elif defined(OS_MACOSX)
+  const SkColor base_color = BaseColorForButton(GetThemeProvider());
+  SetEnabledTextColors(base_color);
+  generic_avatar_ = AvatarIconWithBaseColor(base_color);
+#endif
+}
+
+void AvatarButton::OnAvatarButtonPressed(const ui::Event* event) {
+  views::Widget* bubble_widget = ProfileChooserView::GetCurrentBubbleWidget();
+  if (bubble_widget && !widget_observer_.IsObserving(bubble_widget)) {
+    widget_observer_.Add(bubble_widget);
+    pressed_lock_ = std::make_unique<PressedLock>(
+        this, false, ui::LocatedEvent::FromIfValid(event));
+  }
+}
+
+void AvatarButton::AddedToWidget() {
+  SetupThemeColorButton();
+  Update();
+}
+
+void AvatarButton::OnGestureEvent(ui::GestureEvent* event) {
+  // TODO(wjmaclean): The check for ET_GESTURE_LONG_PRESS is done here since
+  // no other UI button based on Button appears to handle mouse
+  // right-click. If other cases are identified, it may make sense to move this
+  // check to Button.
+  if (event->type() == ui::ET_GESTURE_LONG_PRESS)
+    NotifyClick(*event);
+  else
+    MenuButton::OnGestureEvent(event);
+}
+
+gfx::Size AvatarButton::GetMinimumSize() const {
+  if (IsCondensible()) {
+    // Returns the size of the button when it is atop the tabstrip. Called by
+    // GlassBrowserFrameView::LayoutProfileSwitcher().
+    // TODO(emx): Calculate the height based on the top of the new tab button.
+    return gfx::Size(kCondensibleButtonMinWidth, 20);
+  }
+
+  return MenuButton::GetMinimumSize();
+}
+
+gfx::Size AvatarButton::CalculatePreferredSize() const {
+  if (render_native_nav_buttons_)
+    return MenuButton::CalculatePreferredSize();
+
+  // TODO(estade): Calculate the height instead of hardcoding to 20 for the
+  // not-condensible case.
+  gfx::Size size(MenuButton::CalculatePreferredSize().width(), 20);
+
+  if (IsCondensible()) {
+    // Returns the normal size of the button (when it does not overlap the
+    // tabstrip).
+    size.set_width(std::min(std::max(size.width(), kCondensibleButtonMinWidth),
+                            kCondensibleButtonMaxWidth));
+#if defined(OS_WIN)
+    size.set_height(MinimizeButtonMetrics::GetCaptionButtonHeightInDIPs());
+#endif
+  }
+#if defined(OS_MACOSX)
+  size.set_height(kMacButtonHeight);
+#endif
+  return size;
+}
+
+std::unique_ptr<views::InkDropMask> AvatarButton::CreateInkDropMask() const {
+#if defined(OS_MACOSX)
+  // On Mac, this looks and behaves like a regular MD button, so we need a hover
+  // background.
+  // TODO (lgrey): Determine and set the correct insets.
+  constexpr int kHoverCornerRadius = 2;
+  return std::make_unique<views::RoundRectInkDropMask>(size(), gfx::Insets(),
+                                                       kHoverCornerRadius);
+#else
+  if (button_style_ == AvatarButtonStyle::THEMED)
+    return AvatarButtonThemedBorder::CreateInkDropMask(size());
+  return MenuButton::CreateInkDropMask();
+#endif
+}
+
+std::unique_ptr<views::InkDropHighlight> AvatarButton::CreateInkDropHighlight()
+    const {
+  if (button_style_ == AvatarButtonStyle::THEMED)
+    return MenuButton::CreateInkDropHighlight();
+
+  auto ink_drop_highlight = std::make_unique<views::InkDropHighlight>(
+      size(), 0, gfx::RectF(GetLocalBounds()).CenterPoint(),
+      GetInkDropBaseColor());
+  constexpr float kInkDropHighlightOpacity = 0.08f;
+  ink_drop_highlight->set_visible_opacity(kInkDropHighlightOpacity);
+  return ink_drop_highlight;
+}
+
+SkColor AvatarButton::GetInkDropBaseColor() const {
+#if defined(OS_MACOSX)
+  return GetThemeProvider()->GetColor(
+      ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON);
+#else
+  return MenuButton::GetInkDropBaseColor();
+#endif
+}
+
+bool AvatarButton::ShouldEnterPushedState(const ui::Event& event) {
+  if (ProfileChooserView::IsShowing())
+    return false;
+
+  return MenuButton::ShouldEnterPushedState(event);
+}
+
+bool AvatarButton::ShouldUseFloodFillInkDrop() const {
+  return true;
+}
+
+void AvatarButton::OnAvatarErrorChanged() {
+  Update();
+}
+
+void AvatarButton::OnProfileAdded(const base::FilePath& profile_path) {
+  Update();
+}
+
+void AvatarButton::OnProfileWasRemoved(const base::FilePath& profile_path,
+                                       const base::string16& profile_name) {
+  // If deleting the active profile, don't bother updating the avatar
+  // button, as the browser window is being closed anyway.
+  if (profile_->GetPath() != profile_path)
+    Update();
+}
+
+void AvatarButton::OnProfileNameChanged(
+    const base::FilePath& profile_path,
+    const base::string16& old_profile_name) {
+  if (profile_->GetPath() == profile_path)
+    Update();
+}
+
+void AvatarButton::OnProfileSupervisedUserIdChanged(
+    const base::FilePath& profile_path) {
+  if (profile_->GetPath() == profile_path)
+    Update();
+}
+
+void AvatarButton::OnWidgetDestroying(views::Widget* widget) {
+  pressed_lock_.reset();
+  if (render_native_nav_buttons_)
+    SchedulePaint();
+  widget_observer_.Remove(widget);
+}
+
+void AvatarButton::OnProfileShutdown() {
+  // It looks like in some mysterious cases, the AvatarButton outlives the
+  // profile (see http://crbug.com/id=579690). The avatar button is owned by
+  // the browser frame (which is owned by the BrowserWindow), and there is an
+  // expectation for the UI to be destroyed before the profile is destroyed.
+  CHECK(false) << "Avatar button must not outlive the profile.";
+}
+
+void AvatarButton::Update() {
+  // It looks like in some mysterious cases, the AvatarButton outlives the
+  // profile manager (see http://crbug.com/id=579690). The avatar button is
+  // owned by the browser frame (which is owned by the BrowserWindow), and
+  // there is an expectation for the UI to be destroyed before the profile
+  // manager is destroyed.
+  CHECK(g_browser_process->profile_manager())
+      << "Avatar button must not outlive the profile manager";
+
+  ProfileAttributesStorage& storage =
+      g_browser_process->profile_manager()->GetProfileAttributesStorage();
+
+  // If we have a single local profile, then use the generic avatar
+  // button instead of the profile name. Never use the generic button if
+  // the active profile is Guest.
+  const bool use_generic_button =
+      !profile_->IsGuestSession() && storage.GetNumberOfProfiles() == 1 &&
+      !SigninManagerFactory::GetForProfile(profile_)->IsAuthenticated();
+
+  // Always set the accessible name as accessible text, but don't display it if
+  // is just a generic button.
+  base::string16 name =
+      use_generic_button
+          ? l10n_util::GetStringUTF16(IDS_GENERIC_USER_AVATAR_LABEL)
+          : profiles::GetAvatarButtonTextForProfile(profile_);
+  if (use_generic_button) {
+    SetText(base::string16());
+    SetAccessibleName(name);  // Must be set after setting text to override it.
+  } else {
+    SetText(name);
+  }
+
+#if !defined(OS_MACOSX)
+  // If the button has no text, clear the text shadows to make sure the
+  // image is centered correctly. macOS doesn't use a shadow.
+  SetTextShadows(
+      use_generic_button
+          ? gfx::ShadowValues()
+          : gfx::ShadowValues(
+                10, gfx::ShadowValue(gfx::Vector2d(), 2.0f, SK_ColorDKGRAY)));
+#endif
+
+  if (use_generic_button) {
+    SetImage(views::Button::STATE_NORMAL, generic_avatar_);
+  } else if (profile_->IsSyncAllowed() && error_controller_.HasAvatarError()) {
+    // When DICE is enabled and the error is an auth error, the sync-paused icon
+    // is shown.
+    int dummy;
+    const bool should_show_sync_paused_ui =
+        AccountConsistencyModeManager::IsDiceEnabledForProfile(profile_) &&
+        sync_ui_util::GetMessagesForAvatarSyncError(
+            profile_, *SigninManagerFactory::GetForProfile(profile_), &dummy,
+            &dummy) == sync_ui_util::AUTH_ERROR;
+    SetImage(
+        views::Button::STATE_NORMAL,
+        should_show_sync_paused_ui
+            ? gfx::CreateVectorIcon(kSyncPausedIcon, 16, gfx::kGoogleBlue500)
+            : gfx::CreateVectorIcon(kSyncProblemIcon, 16, gfx::kGoogleRed700));
+  } else {
+    SetImage(views::Button::STATE_NORMAL, gfx::ImageSkia());
+  }
+
+  // If we are not using the generic button, then reset the spacing between
+  // the text and the possible authentication error icon.
+  const int kDefaultImageTextSpacing = 5;
+  SetImageLabelSpacing(use_generic_button ? 0 : kDefaultImageTextSpacing);
+
+  PreferredSizeChanged();
+}
+
+void AvatarButton::SetButtonAvatar(int avatar_idr) {
+  ui::ResourceBundle* rb = &ui::ResourceBundle::GetSharedInstance();
+  generic_avatar_ = *rb->GetImageNamed(avatar_idr).ToImageSkia();
+}
+
+// TODO(estade): all versions of this button should condense.
+bool AvatarButton::IsCondensible() const {
+#if defined(OS_WIN)
+  return (base::win::GetVersion() >= base::win::VERSION_WIN10) &&
+         button_style_ == AvatarButtonStyle::NATIVE;
+#else
+  return false;
+#endif
+}
+bool AvatarButton::ShouldApplyInkDrop() const {
+#if defined(OS_LINUX)
+  DCHECK_EQ(AvatarButtonStyle::THEMED, button_style_);
+  return true;
+#elif defined(OS_MACOSX)
+  return true;
+#else
+  if (render_native_nav_buttons_)
+    return false;
+  return IsCondensible();
+#endif
+}
--- a/chrome/browser/ui/views/profiles/profile_menu_view.cc
+++ b/chrome/browser/ui/views/profiles/profile_menu_view.cc
@@ -173,8 +173,10 @@ void ProfileMenuView::OnPasswordsButtonC
   // TODO(crbug.com/995757): Remove user action.
   base::RecordAction(
       base::UserMetricsAction("ProfileChooser_PasswordsClicked"));
+#if 0
   NavigateToManagePasswordsPage(
       browser(), password_manager::ManagePasswordsReferrer::kProfileChooser);
+#endif
 }
 
 void ProfileMenuView::OnCreditCardsButtonClicked() {
--- a/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
+++ b/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
@@ -305,5 +305,7 @@ void RelaunchNotificationController::Clo
 }
 
 void RelaunchNotificationController::OnRelaunchDeadlineExpired() {
+#if 0
   chrome::RelaunchIgnoreUnloadHandlers();
+#endif
 }
--- a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
+++ b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
@@ -31,6 +31,7 @@ using views::BoxLayout;
 namespace {
 
 // Fixed height of the illustration shown on the top of the dialog.
+#if 0
 constexpr int kSafeBrowsingIllustrationHeight = 148;
 
 // Fixed background color of the illustration shown on the top of the dialog in
@@ -109,6 +110,7 @@ base::string16 GetOkButtonLabel(
       return l10n_util::GetStringUTF16(IDS_PAGE_INFO_PROTECT_ACCOUNT_BUTTON);
   }
 }
+#endif
 
 }  // namespace
 
@@ -137,6 +139,7 @@ PasswordReuseModalWarningDialog::Passwor
       done_callback_(std::move(done_callback)),
       url_(web_contents->GetLastCommittedURL()),
       password_type_(password_type) {
+#if 0
   DialogDelegate::set_buttons(
       password_type_.account_type() == ReusedPasswordAccountType::SAVED_PASSWORD
           ? ui::DIALOG_BUTTON_OK
@@ -170,12 +173,14 @@ PasswordReuseModalWarningDialog::Passwor
       l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
   CreateGaiaPasswordReuseModalWarningDialog(message_body_label);
   modal_construction_start_time_ = base::TimeTicks::Now();
+#endif
 }
 
 PasswordReuseModalWarningDialog::~PasswordReuseModalWarningDialog() {
-  LogModalWarningDialogLifetime(modal_construction_start_time_);
+  // LogModalWarningDialogLifetime(modal_construction_start_time_);
 }
 
+#if 0
 void PasswordReuseModalWarningDialog::
     CreateSavedPasswordReuseModalWarningDialog(
         const base::string16 message_body,
@@ -225,6 +230,7 @@ void PasswordReuseModalWarningDialog::Cr
   }
   AddChildView(message_body_label);
 }
+#endif
 
 gfx::Size PasswordReuseModalWarningDialog::CalculatePreferredSize() const {
   constexpr int kDialogWidth = 400;
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -136,21 +136,9 @@ class TabHoverCardEventSniffer : public
       : hover_card_(hover_card),
         tab_strip_(tab_strip),
         widget_(tab_strip->GetWidget()) {
-#if defined(OS_MACOSX)
-    if (widget_->GetRootView())
-      widget_->GetRootView()->AddPreTargetHandler(this);
-#else
-    if (widget_->GetNativeWindow())
-      widget_->GetNativeWindow()->AddPreTargetHandler(this);
-#endif
   }
 
   ~TabHoverCardEventSniffer() override {
-#if defined(OS_MACOSX)
-    widget_->GetRootView()->RemovePreTargetHandler(this);
-#else
-    widget_->GetNativeWindow()->RemovePreTargetHandler(this);
-#endif
   }
 
  protected:
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/window_finder_android.cc
@@ -0,0 +1,15 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/tabs/window_finder.h"
+
+#include "base/stl_util.h"
+#include "ui/display/screen.h"
+#include "ui/views/widget/widget.h"
+
+gfx::NativeWindow WindowFinder::GetLocalProcessWindowAtPoint(
+    const gfx::Point& screen_point,
+    const std::set<gfx::NativeWindow>& ignore) {
+  return nullptr;
+}
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -439,6 +439,8 @@ WebUIFactoryFunction GetWebUIFactoryFunc
     return &NewWebUI<UserActionsUI>;
   if (url.host_piece() == chrome::kChromeUIVersionHost)
     return &NewWebUI<VersionUI>;
+  if (url.host_piece() == chrome::kChromeUIExtensionsHost)
+    return &NewWebUI<extensions::ExtensionsUI>;
 
 #if !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
--- a/chrome/browser/ui/webui/discards/BUILD.gn
+++ b/chrome/browser/ui/webui/discards/BUILD.gn
@@ -4,7 +4,7 @@
 
 import("//mojo/public/tools/bindings/mojom.gni")
 
-if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
   mojom("mojo_bindings") {
     sources = [ "discards.mojom" ]
 
--- /dev/null
+++ b/chrome/browser/ui/webui/media_router/media_router_ui.cc
@@ -0,0 +1,716 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/webui/media_router/media_router_ui.h"
+
+#include <algorithm>
+#include <string>
+#include <unordered_map>
+#include <utility>
+
+#include "base/guid.h"
+#include "base/macros.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/trace_event/trace_event.h"
+#include "build/build_config.h"
+#include "chrome/browser/media/router/issue_manager.h"
+#include "chrome/browser/media/router/issues_observer.h"
+#include "chrome/browser/media/router/media_router.h"
+#include "chrome/browser/media/router/media_router_factory.h"
+#include "chrome/browser/media/router/media_router_metrics.h"
+#include "chrome/browser/media/router/media_sinks_observer.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/sessions/session_tab_helper.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/browser_navigator.h"
+#include "chrome/browser/ui/browser_navigator_params.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/media_router/media_router_ui_helper.h"
+#include "chrome/browser/ui/webui/media_router/media_router_localized_strings_provider.h"
+#include "chrome/browser/ui/webui/media_router/media_router_resources_provider.h"
+#include "chrome/browser/ui/webui/media_router/media_router_webui_message_handler.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/media_router/issue.h"
+#include "chrome/common/media_router/media_route.h"
+#include "chrome/common/media_router/media_sink.h"
+#include "chrome/common/media_router/media_source.h"
+#include "chrome/common/media_router/media_source_helper.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/prefs/pref_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "content/public/browser/navigation_handle.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/web_ui.h"
+#include "content/public/browser/web_ui_data_source.h"
+#include "content/public/common/fullscreen_video_element.mojom.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "third_party/blink/public/common/associated_interfaces/associated_interface_provider.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/web_dialogs/web_dialog_delegate.h"
+#include "url/origin.h"
+
+#if !defined(OS_MACOSX) || BUILDFLAG(MAC_VIEWS_BROWSER)
+#include "chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.h"
+#include "ui/display/display.h"
+#endif
+
+namespace media_router {
+
+// This class calls to refresh the UI when the highest priority issue is
+// updated.
+class MediaRouterUI::UIIssuesObserver : public IssuesObserver {
+ public:
+  UIIssuesObserver(IssueManager* issue_manager, MediaRouterUI* ui)
+      : IssuesObserver(issue_manager), ui_(ui) {
+    DCHECK(ui);
+  }
+
+  ~UIIssuesObserver() override {}
+
+  // IssuesObserver implementation.
+  void OnIssue(const Issue& issue) override { ui_->SetIssue(issue); }
+  void OnIssuesCleared() override { ui_->ClearIssue(); }
+
+ private:
+  // Reference back to the owning MediaRouterUI instance.
+  MediaRouterUI* ui_;
+
+  DISALLOW_COPY_AND_ASSIGN(UIIssuesObserver);
+};
+
+// Observes a WebContents and requests fullscreening of its first
+// video element.  The request is sent after the WebContents is loaded and tab
+// capture has begun. Marked final to prevent inheritance so delete calls are
+// contained to scenarios documented below.
+class MediaRouterUI::WebContentsFullscreenOnLoadedObserver final
+    : public content::WebContentsObserver {
+ public:
+  WebContentsFullscreenOnLoadedObserver(const GURL& file_url,
+                                        content::WebContents* web_contents)
+      : file_url_(file_url), capture_poll_timer_(false, false) {
+    DCHECK(file_url_.SchemeIsFile());
+    DCHECK(fullscreen_request_time_.is_null());
+
+    // If the WebContents is loading, start listening, otherwise just call the
+    // fullscreen function.
+
+    // This class destroys itself in the following situations (at least one of
+    // which will occur):
+    //   * after loading is complete and,
+    //   ** capture has begun and fullscreen requested,
+    //   ** kMaxSecondsToWaitForCapture seconds have passed without capture,
+    //   * another navigation is started,
+    //   * the WebContents is destroyed.
+    if (web_contents->IsLoading()) {
+      Observe(web_contents);
+    } else {
+      FullScreenFirstVideoElement(web_contents);
+    }
+  }
+  ~WebContentsFullscreenOnLoadedObserver() override {}
+
+  // content::WebContentsObserver implementation.
+  void DidStopLoading() override {
+    FullScreenFirstVideoElement(web_contents());
+  }
+
+  void DidStartNavigation(
+      content::NavigationHandle* navigation_handle) override {
+    // If the user takes over and navigates away from the file, stop listening.
+    // (It is possible however for this listener to be created before the
+    // navigation to the requested file triggers, so provided we're still on the
+    // same URL, go ahead and keep listening).
+    if (file_url_ != navigation_handle->GetURL()) {
+      delete this;
+    }
+  }
+
+  void WebContentsDestroyed() override {
+    // If the WebContents is destroyed we will never trigger and need to clean
+    // up.
+    delete this;
+  }
+
+ private:
+  const GURL file_url_;
+
+  // Time intervals used by the logic that detects if capture has started.
+  const int kMaxSecondsToWaitForCapture = 10;
+  const int kPollIntervalInSeconds = 1;
+
+  // The time at which fullscreen was requested.
+  base::TimeTicks fullscreen_request_time_;
+
+  // Poll timer to monitor the capturer count when fullscreening local files.
+  //
+  // TODO(crbug.com/540965): Add a method to WebContentsObserver to report
+  // capturer count changes and get rid of this polling-based approach.
+  base::Timer capture_poll_timer_;
+
+  // Sends a request for full screen to the WebContents targeted at the first
+  // video element.  The request is only sent after capture has begun.
+  void FullScreenFirstVideoElement(content::WebContents* web_contents) {
+    if (file_url_ != web_contents->GetLastCommittedURL()) {
+      // The user has navigated before the casting started. Do not attempt to
+      // fullscreen and cleanup.
+      return;
+    }
+
+    fullscreen_request_time_ = base::TimeTicks::Now();
+    FullscreenIfContentCaptured(web_contents);
+  }
+
+  void FullscreenIfContentCaptured(content::WebContents* web_contents) {
+    if (web_contents->IsBeingCaptured()) {
+      content::mojom::FullscreenVideoElementHandlerAssociatedPtr client;
+      web_contents->GetMainFrame()
+          ->GetRemoteAssociatedInterfaces()
+          ->GetInterface(&client);
+      client->RequestFullscreenVideoElement();
+      delete this;
+      return;
+    } else if (base::TimeTicks::Now() - fullscreen_request_time_ >
+               base::TimeDelta::FromSeconds(kMaxSecondsToWaitForCapture)) {
+      // If content capture hasn't started within the timeout skip fullscreen.
+      DLOG(WARNING) << "Capture of local content did not start within timeout";
+      delete this;
+      return;
+    }
+
+    capture_poll_timer_.Start(
+        FROM_HERE, base::TimeDelta::FromSeconds(kPollIntervalInSeconds),
+        base::BindRepeating(
+            &WebContentsFullscreenOnLoadedObserver::FullscreenIfContentCaptured,
+            base::Unretained(this), web_contents));
+  }
+};
+
+MediaRouterUI::MediaRouterUI(content::WebUI* web_ui)
+    : ConstrainedWebDialogUI(web_ui),
+      ui_initialized_(false),
+      weak_factory_(this) {
+  auto handler = std::make_unique<MediaRouterWebUIMessageHandler>(this);
+  handler_ = handler.get();
+
+  // Create a WebUIDataSource containing the chrome://media-router page's
+  // content.
+  std::unique_ptr<content::WebUIDataSource> html_source(
+      content::WebUIDataSource::Create(chrome::kChromeUIMediaRouterHost));
+
+  AddLocalizedStrings(html_source.get());
+  AddMediaRouterUIResources(html_source.get());
+  // Ownership of |html_source| is transferred to the BrowserContext.
+  content::WebUIDataSource::Add(Profile::FromWebUI(web_ui),
+                                html_source.release());
+
+  web_ui->AddMessageHandler(std::move(handler));
+}
+
+MediaRouterUI::~MediaRouterUI() = default;
+
+void MediaRouterUI::Close() {
+  ConstrainedWebDialogDelegate* delegate = GetConstrainedDelegate();
+  if (delegate) {
+    delegate->GetWebDialogDelegate()->OnDialogClosed(std::string());
+    delegate->OnDialogCloseFromWebUI();
+  }
+}
+
+void MediaRouterUI::OnUIInitialized() {
+  TRACE_EVENT_NESTABLE_ASYNC_END0("media_router", "UI", initiator());
+
+  ui_initialized_ = true;
+
+  // TODO(imcheng): We should be able to instantiate |issue_observer_| during
+  // InitCommon by storing an initial Issue in this class.
+  // Register for Issue updates.
+  issues_observer_ =
+      std::make_unique<UIIssuesObserver>(GetIssueManager(), this);
+  issues_observer_->Init();
+}
+
+bool MediaRouterUI::CreateRoute(const MediaSink::Id& sink_id,
+                                MediaCastMode cast_mode) {
+  // Default the tab casting the content to the initiator, and change if
+  // necessary.
+  content::WebContents* tab_contents = initiator();
+
+  base::Optional<RouteParameters> params;
+  if (cast_mode == MediaCastMode::LOCAL_FILE) {
+    GURL url = media_router_file_dialog_->GetLastSelectedFileUrl();
+    tab_contents = OpenTabWithUrl(url);
+    params = GetLocalFileRouteParameters(sink_id, url, tab_contents);
+  } else {
+    params = GetRouteParameters(sink_id, cast_mode);
+  }
+  if (!params) {
+    SendIssueForUnableToCast(cast_mode);
+    return false;
+  }
+
+  GetIssueManager()->ClearNonBlockingIssues();
+  GetMediaRouter()->CreateRoute(params->source_id, sink_id, params->origin,
+                                tab_contents,
+                                std::move(params->route_response_callbacks),
+                                params->timeout, params->incognito);
+  return true;
+}
+
+bool MediaRouterUI::ConnectRoute(const MediaSink::Id& sink_id,
+                                 const MediaRoute::Id& route_id) {
+  base::Optional<RouteParameters> params =
+      GetRouteParameters(sink_id, MediaCastMode::PRESENTATION);
+  if (!params) {
+    SendIssueForUnableToCast(MediaCastMode::PRESENTATION);
+    return false;
+  }
+  GetIssueManager()->ClearNonBlockingIssues();
+  GetMediaRouter()->ConnectRouteByRouteId(
+      params->source_id, route_id, params->origin, initiator(),
+      std::move(params->route_response_callbacks), params->timeout,
+      params->incognito);
+  return true;
+}
+
+void MediaRouterUI::AddIssue(const IssueInfo& issue) {
+  GetIssueManager()->AddIssue(issue);
+}
+
+void MediaRouterUI::ClearIssue(const Issue::Id& issue_id) {
+  GetIssueManager()->ClearIssue(issue_id);
+}
+
+void MediaRouterUI::OpenFileDialog() {
+  if (!media_router_file_dialog_) {
+    media_router_file_dialog_ = std::make_unique<MediaRouterFileDialog>(this);
+  }
+
+  media_router_file_dialog_->OpenFileDialog(GetBrowser());
+}
+
+void MediaRouterUI::SearchSinksAndCreateRoute(
+    const MediaSink::Id& sink_id,
+    const std::string& search_criteria,
+    const std::string& domain,
+    MediaCastMode cast_mode) {
+  std::unique_ptr<MediaSource> source =
+      query_result_manager()->GetSourceForCastModeAndSink(cast_mode, sink_id);
+  const std::string source_id = source ? source->id() : "";
+
+  // The CreateRoute() part of the function is accomplished in the callback
+  // OnSearchSinkResponseReceived().
+  GetMediaRouter()->SearchSinks(
+      sink_id, source_id, search_criteria, domain,
+      base::BindRepeating(&MediaRouterUI::OnSearchSinkResponseReceived,
+                          weak_factory_.GetWeakPtr(), cast_mode));
+}
+
+bool MediaRouterUI::UserSelectedTabMirroringForCurrentOrigin() const {
+  const base::ListValue* origins =
+      Profile::FromWebUI(web_ui())->GetPrefs()->GetList(
+          ::prefs::kMediaRouterTabMirroringSources);
+  return origins->Find(base::Value(GetSerializedInitiatorOrigin())) !=
+         origins->end();
+}
+
+void MediaRouterUI::RecordCastModeSelection(MediaCastMode cast_mode) {
+  ListPrefUpdate update(Profile::FromWebUI(web_ui())->GetPrefs(),
+                        ::prefs::kMediaRouterTabMirroringSources);
+
+  switch (cast_mode) {
+    case MediaCastMode::PRESENTATION:
+      update->Remove(base::Value(GetSerializedInitiatorOrigin()), nullptr);
+      break;
+    case MediaCastMode::TAB_MIRROR:
+      update->AppendIfNotPresent(
+          std::make_unique<base::Value>(GetSerializedInitiatorOrigin()));
+      break;
+    case MediaCastMode::DESKTOP_MIRROR:
+      // Desktop mirroring isn't domain-specific, so we don't record the
+      // selection.
+      break;
+    case MediaCastMode::LOCAL_FILE:
+      // Local media isn't domain-specific, so we don't record the selection.
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+std::string MediaRouterUI::GetPresentationRequestSourceName() const {
+  GURL gurl = GetFrameURL();
+  return gurl.SchemeIs(extensions::kExtensionScheme)
+             ? GetExtensionName(gurl, extensions::ExtensionRegistry::Get(
+                                          Profile::FromWebUI(web_ui())))
+             : GetHostFromURL(gurl);
+}
+
+const std::set<MediaCastMode>& MediaRouterUI::cast_modes() const {
+  return cast_modes_;
+}
+
+void MediaRouterUI::SetUIInitializationTimer(const base::Time& start_time) {
+  DCHECK(!start_time.is_null());
+  start_time_ = start_time;
+}
+
+void MediaRouterUI::OnUIInitiallyLoaded() {
+  if (!start_time_.is_null()) {
+    MediaRouterMetrics::RecordMediaRouterDialogPaint(base::Time::Now() -
+                                                     start_time_);
+  }
+}
+
+void MediaRouterUI::OnUIInitialDataReceived() {
+  if (!start_time_.is_null()) {
+    MediaRouterMetrics::RecordMediaRouterDialogLoaded(base::Time::Now() -
+                                                      start_time_);
+    start_time_ = base::Time();
+  }
+}
+
+void MediaRouterUI::UpdateMaxDialogHeight(int height) {
+  if (ui_initialized_) {
+    handler_->UpdateMaxDialogHeight(height);
+  }
+}
+
+MediaRouteController* MediaRouterUI::GetMediaRouteController() const {
+  return route_controller_observer_
+             ? route_controller_observer_->controller().get()
+             : nullptr;
+}
+
+void MediaRouterUI::OnMediaControllerUIAvailable(
+    const MediaRoute::Id& route_id) {
+#if 0
+  scoped_refptr<MediaRouteController> controller =
+      GetMediaRouter()->GetRouteController(route_id);
+  if (!controller) {
+    DVLOG(1) << "Requested a route controller with an invalid route ID.";
+    return;
+  }
+  DVLOG_IF(1, route_controller_observer_)
+      << "Route controller observer unexpectedly exists.";
+  route_controller_observer_ =
+      std::make_unique<UIMediaRouteControllerObserver>(this, controller);
+#endif
+}
+
+void MediaRouterUI::OnMediaControllerUIClosed() {
+  route_controller_observer_.reset();
+}
+
+void MediaRouterUI::InitForTest(
+    MediaRouter* router,
+    content::WebContents* initiator,
+    MediaRouterWebUIMessageHandler* handler,
+    std::unique_ptr<StartPresentationContext> context,
+    std::unique_ptr<MediaRouterFileDialog> file_dialog) {
+  handler_ = handler;
+  set_start_presentation_context_for_test(std::move(context));
+  InitForTest(std::move(file_dialog));
+  InitCommon(initiator);
+  if (start_presentation_context()) {
+    OnDefaultPresentationChanged(
+        start_presentation_context()->presentation_request());
+  }
+
+  OnUIInitialized();
+}
+
+void MediaRouterUI::InitForTest(
+    std::unique_ptr<MediaRouterFileDialog> file_dialog) {
+  media_router_file_dialog_ = std::move(file_dialog);
+}
+
+MediaRouterUI::UIMediaRouteControllerObserver::UIMediaRouteControllerObserver(
+    MediaRouterUI* ui,
+    scoped_refptr<MediaRouteController> controller)
+    : MediaRouteController::Observer(std::move(controller)), ui_(ui) {
+  if (controller_->current_media_status())
+    OnMediaStatusUpdated(controller_->current_media_status().value());
+}
+
+MediaRouterUI::UIMediaRouteControllerObserver::
+    ~UIMediaRouteControllerObserver() {}
+
+void MediaRouterUI::UIMediaRouteControllerObserver::OnMediaStatusUpdated(
+    const MediaStatus& status) {
+  ui_->UpdateMediaRouteStatus(status);
+}
+
+void MediaRouterUI::UIMediaRouteControllerObserver::OnControllerInvalidated() {
+  ui_->OnRouteControllerInvalidated();
+}
+
+Browser* MediaRouterUI::GetBrowser() {
+  CHECK(initiator());
+  return chrome::FindBrowserWithWebContents(initiator());
+}
+
+content::WebContents* MediaRouterUI::OpenTabWithUrl(const GURL url) {
+  // Check if the current page is a new tab. If so open file in current page.
+  // If not then open a new page.
+  if (initiator()->GetVisibleURL() == chrome::kChromeUINewTabURL) {
+    content::NavigationController::LoadURLParams load_params(url);
+    load_params.transition_type = ui::PAGE_TRANSITION_GENERATED;
+    initiator()->GetController().LoadURLWithParams(load_params);
+    return initiator();
+  } else {
+    return chrome::AddSelectedTabWithURL(GetBrowser(), url,
+                                         ui::PAGE_TRANSITION_LINK);
+  }
+}
+
+void MediaRouterUI::FileDialogFileSelected(
+    const ui::SelectedFileInfo& file_info) {
+  handler_->UserSelectedLocalMediaFile(file_info.display_name);
+}
+
+void MediaRouterUI::FileDialogSelectionFailed(const IssueInfo& issue) {
+  AddIssue(issue);
+}
+
+void MediaRouterUI::SetIssue(const Issue& issue) {
+  if (ui_initialized_)
+    handler_->UpdateIssue(issue);
+}
+
+void MediaRouterUI::ClearIssue() {
+  if (ui_initialized_)
+    handler_->ClearIssue();
+}
+
+void MediaRouterUI::OnRoutesUpdated(
+    const std::vector<MediaRoute>& routes,
+    const std::vector<MediaRoute::Id>& joinable_route_ids) {
+  MediaRouterUIBase::OnRoutesUpdated(routes, joinable_route_ids);
+  joinable_route_ids_.clear();
+
+  for (const MediaRoute& route : routes) {
+    if (route.for_display() &&
+        base::ContainsValue(joinable_route_ids, route.media_route_id())) {
+      joinable_route_ids_.push_back(route.media_route_id());
+    }
+  }
+
+  if (ui_initialized_) {
+    handler_->UpdateRoutes(MediaRouterUIBase::routes(), joinable_route_ids_,
+                           routes_and_cast_modes());
+  }
+  UpdateRoutesToCastModesMapping();
+}
+
+void MediaRouterUI::OnRouteResponseReceived(
+    int route_request_id,
+    const MediaSink::Id& sink_id,
+    MediaCastMode cast_mode,
+    const base::string16& presentation_request_source_name,
+    const RouteRequestResult& result) {
+  MediaRouterUIBase::OnRouteResponseReceived(
+      route_request_id, sink_id, cast_mode, presentation_request_source_name,
+      result);
+  handler_->OnCreateRouteResponseReceived(sink_id, result.route());
+  if (result.result_code() == RouteRequestResult::TIMED_OUT)
+    SendIssueForRouteTimeout(cast_mode, presentation_request_source_name);
+}
+
+void MediaRouterUI::MaybeReportFileInformation(
+    const RouteRequestResult& result) {
+  if (result.result_code() == RouteRequestResult::OK)
+    media_router_file_dialog_->MaybeReportLastSelectedFileInformation();
+}
+
+void MediaRouterUI::HandleCreateSessionRequestRouteResponse(
+    const RouteRequestResult&) {
+  Close();
+}
+
+void MediaRouterUI::OnSearchSinkResponseReceived(
+    MediaCastMode cast_mode,
+    const MediaSink::Id& found_sink_id) {
+  DVLOG(1) << "OnSearchSinkResponseReceived";
+  handler_->ReturnSearchResult(found_sink_id);
+
+  CreateRoute(found_sink_id, cast_mode);
+}
+
+void MediaRouterUI::SendIssueForRouteTimeout(
+    MediaCastMode cast_mode,
+    const base::string16& presentation_request_source_name) {
+  std::string issue_title;
+  switch (cast_mode) {
+    case PRESENTATION:
+      DLOG_IF(ERROR, presentation_request_source_name.empty())
+          << "Empty presentation request source name.";
+      issue_title =
+          l10n_util::GetStringFUTF8(IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT,
+                                    presentation_request_source_name);
+      break;
+    case TAB_MIRROR:
+      issue_title = l10n_util::GetStringUTF8(
+          IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_TAB);
+      break;
+    case DESKTOP_MIRROR:
+      issue_title = l10n_util::GetStringUTF8(
+          IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_DESKTOP);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  AddIssue(IssueInfo(issue_title, IssueInfo::Action::DISMISS,
+                     IssueInfo::Severity::NOTIFICATION));
+}
+
+void MediaRouterUI::SendIssueForUnableToCast(MediaCastMode cast_mode) {
+  // For a generic error, claim a tab error unless it was specifically desktop
+  // mirroring.
+  std::string issue_title =
+      (cast_mode == MediaCastMode::DESKTOP_MIRROR)
+          ? l10n_util::GetStringUTF8(
+                IDS_MEDIA_ROUTER_ISSUE_UNABLE_TO_CAST_DESKTOP)
+          : l10n_util::GetStringUTF8(
+                IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_TAB);
+  AddIssue(IssueInfo(issue_title, IssueInfo::Action::DISMISS,
+                     IssueInfo::Severity::WARNING));
+}
+
+void MediaRouterUI::InitCommon(content::WebContents* initiator) {
+  MediaRouterUIBase::InitCommon(initiator);
+  UpdateCastModes();
+  // Presentation requests from content must show the origin requesting
+  // presentation: crbug.com/704964
+  if (start_presentation_context())
+    forced_cast_mode_ = MediaCastMode::PRESENTATION;
+}
+
+void MediaRouterUI::OnDefaultPresentationChanged(
+    const content::PresentationRequest& presentation_request) {
+  MediaRouterUIBase::OnDefaultPresentationChanged(presentation_request);
+  UpdateCastModes();
+}
+
+void MediaRouterUI::OnDefaultPresentationRemoved() {
+  MediaRouterUIBase::OnDefaultPresentationRemoved();
+
+  // This should not be set if the dialog was initiated with a default
+  // presentation request from the top level frame.  However, clear it just to
+  // be safe.
+  forced_cast_mode_ = base::nullopt;
+  UpdateCastModes();
+}
+
+base::Optional<RouteParameters> MediaRouterUI::GetLocalFileRouteParameters(
+    const MediaSink::Id& sink_id,
+    const GURL& file_url,
+    content::WebContents* tab_contents) {
+  RouteParameters params;
+  SessionID::id_type tab_id = SessionTabHelper::IdForTab(tab_contents).id();
+  params.source_id = MediaSourceForTab(tab_id).id();
+
+  // Use a placeholder URL as origin for local file casting, which is
+  // essentially mirroring.
+  params.origin = url::Origin::Create(GURL(chrome::kChromeUIMediaRouterURL));
+
+  params.route_response_callbacks.push_back(base::BindOnce(
+      &MediaRouterUI::OnRouteResponseReceived, weak_factory_.GetWeakPtr(),
+      current_route_request_id(), sink_id, MediaCastMode::LOCAL_FILE,
+      base::UTF8ToUTF16(GetTruncatedPresentationRequestSourceName())));
+
+  params.route_response_callbacks.push_back(
+      base::BindOnce(&MediaRouterUIBase::MaybeReportCastingSource,
+                     weak_factory_.GetWeakPtr(), MediaCastMode::LOCAL_FILE));
+
+  params.route_response_callbacks.push_back(base::BindOnce(
+      &MediaRouterUI::MaybeReportFileInformation, weak_factory_.GetWeakPtr()));
+
+  params.route_response_callbacks.push_back(
+      base::BindOnce(&MediaRouterUI::FullScreenFirstVideoElement,
+                     weak_factory_.GetWeakPtr(), file_url, tab_contents));
+
+  params.timeout = GetRouteRequestTimeout(MediaCastMode::LOCAL_FILE);
+  CHECK(initiator());
+  params.incognito = initiator()->GetBrowserContext()->IsOffTheRecord();
+
+  return base::make_optional(std::move(params));
+}
+
+// TODO(crbug.com/792547): Refactor FullScreenFirstVideoElement() and
+// MaybeReportFileInformation() into a local media casting specific location
+// instead of here in the main ui.
+void MediaRouterUI::FullScreenFirstVideoElement(
+    const GURL& file_url,
+    content::WebContents* web_contents,
+    const RouteRequestResult& result) {
+  if (result.result_code() == RouteRequestResult::OK) {
+    new WebContentsFullscreenOnLoadedObserver(file_url, web_contents);
+  }
+}
+
+void MediaRouterUI::UpdateCastModes() {
+  // Gets updated cast modes from |query_result_manager()| and forwards it to
+  // UI.
+  cast_modes_ = query_result_manager()->GetSupportedCastModes();
+  if (ui_initialized_) {
+    handler_->UpdateCastModes(cast_modes(), GetPresentationRequestSourceName(),
+                              forced_cast_mode());
+  }
+}
+
+void MediaRouterUI::UpdateRoutesToCastModesMapping() {
+  std::unordered_map<MediaSource::Id, MediaCastMode> available_source_map;
+  for (const auto& cast_mode : cast_modes()) {
+    for (const auto& source : GetSourcesForCastMode(cast_mode))
+      available_source_map.insert(std::make_pair(source.id(), cast_mode));
+  }
+
+  routes_and_cast_modes_.clear();
+  for (const auto& route : routes()) {
+    auto source_entry = available_source_map.find(route.media_source().id());
+    if (source_entry != available_source_map.end()) {
+      routes_and_cast_modes_.insert(
+          std::make_pair(route.media_route_id(), source_entry->second));
+    }
+  }
+}
+
+std::string MediaRouterUI::GetSerializedInitiatorOrigin() const {
+  url::Origin origin =
+      initiator() ? url::Origin::Create(initiator()->GetLastCommittedURL())
+                  : url::Origin();
+  return origin.Serialize();
+}
+
+void MediaRouterUI::OnRouteControllerInvalidated() {
+  route_controller_observer_.reset();
+  handler_->OnRouteControllerInvalidated();
+}
+void MediaRouterUI::UpdateMediaRouteStatus(const MediaStatus& status) {
+  handler_->UpdateMediaRouteStatus(status);
+}
+
+IssueManager* MediaRouterUI::GetIssueManager() {
+  return GetMediaRouter()->GetIssueManager();
+}
+
+void MediaRouterUI::UpdateSinks() {
+  if (ui_initialized_)
+    handler_->UpdateSinks(GetEnabledSinks());
+}
+
+MediaRouter* MediaRouterUI::GetMediaRouter() const {
+  return MediaRouterFactory::GetApiForBrowserContext(
+      web_ui()->GetWebContents()->GetBrowserContext());
+}
+
+}  // namespace media_router
--- a/chrome/browser/ui/webui/settings/change_password_handler.cc
+++ b/chrome/browser/ui/webui/settings/change_password_handler.cc
@@ -56,9 +56,6 @@ void ChangePasswordHandler::HandleChange
 }
 
 void ChangePasswordHandler::UpdateChangePasswordCardVisibility() {
-  FireWebUIListener(
-      "change-password-visibility",
-      base::Value(true));
 }
 
 }  // namespace settings
--- a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
+++ b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
@@ -247,6 +247,7 @@ void LockProfileAndShowUserManager(const
 void OnSyncSetupComplete(Profile* profile,
                          const std::string& username,
                          const std::string& password) {
+#if 0
   DCHECK(signin_util::IsForceSigninEnabled());
   signin::IdentityManager* identity_manager =
       IdentityManagerFactory::GetForProfile(profile);
@@ -267,6 +268,7 @@ void OnSyncSetupComplete(Profile* profil
         BrowserList::CloseCallback(),
         /*skip_beforeunload=*/true);
   }
+#endif
 }
 
 }  // namespace
@@ -404,11 +406,13 @@ void InlineSigninHelper::OnClientOAuthSu
       // Display a confirmation dialog to the user.
       base::RecordAction(
           base::UserMetricsAction("Signin_Show_UntrustedSigninPrompt"));
+#if 0
       Browser* browser = chrome::FindLastActiveWithProfile(profile_);
       browser->window()->ShowOneClickSigninConfirmation(
           base::UTF8ToUTF16(email_),
           base::BindOnce(&InlineSigninHelper::UntrustedSigninConfirmed,
                          base::Unretained(this), result.refresh_token));
+#endif
       return;
     }
     CreateSyncStarter(result.refresh_token);
--- /dev/null
+++ b/chrome/browser/ui/window_sizer/window_sizer_android.cc
@@ -0,0 +1,17 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/window_sizer/window_sizer.h"
+
+// This doesn't matter for aura, which has different tiling.
+// static
+const int WindowSizer::kWindowTilePixels = 10;
+const int WindowSizer::kWindowMaxDefaultWidth = 1050;
+
+// static
+gfx::Point WindowSizer::GetDefaultPopupOrigin(const gfx::Size& size) {
+  // TODO(skuhne): Check if this isn't needed anymore (since it is implemented
+  // in WindowPositioner) and remove it.
+  return gfx::Point();
+}
--- a/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
+++ b/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
@@ -81,6 +81,7 @@ std::string ChromeZoomLevelPrefs::GetPar
 }
 
 void ChromeZoomLevelPrefs::SetDefaultZoomLevelPref(double level) {
+#if 0
   if (blink::PageZoomValuesEqual(level, host_zoom_map_->GetDefaultZoomLevel()))
     return;
 
@@ -92,16 +93,12 @@ void ChromeZoomLevelPrefs::SetDefaultZoo
   default_zoom_changed_callbacks_.Notify();
   if (zoom_event_manager_)
     zoom_event_manager_->OnDefaultZoomLevelChanged();
+#endif
 }
 
 double ChromeZoomLevelPrefs::GetDefaultZoomLevelPref() const {
   double default_zoom_level = 0.0;
 
-  const base::DictionaryValue* default_zoom_level_dictionary =
-      pref_service_->GetDictionary(prefs::kPartitionDefaultZoomLevel);
-  // If no default has been previously set, the default returned is the
-  // value used to initialize default_zoom_level in this function.
-  default_zoom_level_dictionary->GetDouble(partition_key_, &default_zoom_level);
   return default_zoom_level;
 }
 
@@ -218,28 +215,4 @@ void ChromeZoomLevelPrefs::ExtractPerHos
 
 void ChromeZoomLevelPrefs::InitHostZoomMap(
     content::HostZoomMap* host_zoom_map) {
-  // This init function must be called only once.
-  DCHECK(!host_zoom_map_);
-  DCHECK(host_zoom_map);
-  host_zoom_map_ = host_zoom_map;
-
-  // Initialize the default zoom level.
-  host_zoom_map_->SetDefaultZoomLevel(GetDefaultZoomLevelPref());
-
-  // Initialize the HostZoomMap with per-host zoom levels from the persisted
-  // zoom-level preference values.
-  const base::DictionaryValue* host_zoom_dictionaries =
-      pref_service_->GetDictionary(prefs::kPartitionPerHostZoomLevels);
-  const base::DictionaryValue* host_zoom_dictionary = nullptr;
-  if (host_zoom_dictionaries->GetDictionary(partition_key_,
-                                            &host_zoom_dictionary)) {
-    // Since we're calling this before setting up zoom_subscription_ below we
-    // don't need to worry that host_zoom_dictionary is indirectly affected
-    // by calls to HostZoomMap::SetZoomLevelForHost().
-    ExtractPerHostZoomLevels(host_zoom_dictionary,
-                             true /* sanitize_partition_host_zoom_levels */);
-  }
-  zoom_subscription_ =
-      host_zoom_map_->AddZoomLevelChangedCallback(base::BindRepeating(
-          &ChromeZoomLevelPrefs::OnZoomLevelChanged, base::Unretained(this)));
 }
--- a/chrome/browser/web_applications/BUILD.gn
+++ b/chrome/browser/web_applications/BUILD.gn
@@ -186,7 +186,6 @@ source_set("web_applications_unit_tests"
     "//chrome/browser",
     "//chrome/browser/web_applications/components",
     "//chrome/common",
-    "//chrome/test:test_support",
     "//content/public/browser",
     "//content/test:test_support",
     "//skia",
@@ -217,8 +216,6 @@ source_set("web_applications_browser_tes
     ":web_applications",
     ":web_applications_test_support",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
   ]
 }
 
@@ -234,8 +231,6 @@ source_set("common_browser_tests") {
     ":web_applications_test_support",
     "//chrome/app:command_ids",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
   ]
 }
 
--- a/chrome/browser/web_applications/components/BUILD.gn
+++ b/chrome/browser/web_applications/components/BUILD.gn
@@ -168,7 +168,6 @@ source_set("unit_tests") {
     "//chrome/app/theme:theme_resources",
     "//chrome/browser/web_applications:web_app_test_group",
     "//chrome/browser/web_applications:web_applications_test_support",
-    "//chrome/test:test_support",
     "//content/public/browser",
     "//skia",
     "//testing/gmock",
@@ -190,8 +189,6 @@ source_set("browser_tests") {
   deps = [
     ":components",
     "//chrome/browser/web_applications:web_applications_test_support",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
     "//net:test_support",
   ]
 }
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
@@ -0,0 +1,122 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/components/web_app_shortcut_android.h"
+
+#include <fcntl.h>
+
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/i18n/file_util_icu.h"
+#include "base/nix/xdg_util.h"
+#include "base/path_service.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/shell_integration.h"
+#include "chrome/browser/web_applications/components/web_app_helpers.h"
+#include "chrome/browser/web_applications/components/web_app_shortcut.h"
+#include "chrome/common/buildflags.h"
+#include "chrome/common/chrome_constants.h"
+
+namespace {
+
+#if BUILDFLAG(ENABLE_APP_LIST)
+// The Categories for the App Launcher desktop shortcut. Should be the same as
+// the Chrome desktop shortcut, so they are in the same sub-menu.
+const char kAppListCategories[] = "Network;WebBrowser;";
+#endif
+
+}  // namespace
+
+namespace web_app {
+
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id) {
+  DCHECK(!app_id.empty());
+
+  // Use a prefix, because xdg-desktop-menu requires it.
+  std::string filename(chrome::kBrowserProcessExecutableName);
+  filename.append("-").append(app_id).append("-").append(
+      profile_path.BaseName().value());
+  base::i18n::ReplaceIllegalCharactersInPath(&filename, '_');
+  // Spaces in filenames break xdg-desktop-menu
+  // (see https://bugs.freedesktop.org/show_bug.cgi?id=66605).
+  base::ReplaceChars(filename, " ", "_", &filename);
+  return base::FilePath(filename.append(".desktop"));
+}
+
+void DeleteShortcutOnDesktop(const base::FilePath& shortcut_filename) {
+}
+
+void DeleteShortcutInApplicationsMenu(
+    const base::FilePath& shortcut_filename,
+    const base::FilePath& directory_filename) {
+}
+
+bool CreateDesktopShortcut(
+    const web_app::ShortcutInfo& shortcut_info,
+    const web_app::ShortcutLocations& creation_locations) {
+  return false;
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id) {
+  base::FilePath desktop_path;
+  // If Get returns false, just leave desktop_path empty.
+  base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path);
+  return GetExistingShortcutLocations(env, profile_path, extension_id,
+                                      desktop_path);
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  web_app::ShortcutLocations locations;
+  return locations;
+}
+
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id) {
+}
+
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.h
@@ -0,0 +1,62 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+
+#include <string>
+
+namespace base {
+class FilePath;
+class Environment;
+}  // namespace base
+
+namespace web_app {
+
+struct ShortcutInfo;
+struct ShortcutLocations;
+
+// Create shortcuts on the desktop or in the application menu (as specified by
+// |shortcut_info|), for the web page or extension in |shortcut_info|.
+// For extensions, duplicate shortcuts are avoided, so if a requested shortcut
+// already exists it is deleted first.
+bool CreateDesktopShortcut(const ShortcutInfo& shortcut_info,
+                           const ShortcutLocations& creation_locations);
+
+// Returns filename for .desktop file based on |profile_path| and
+// |app_id|, sanitized for security.
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id);
+
+// Returns the set of locations in which shortcuts are installed for the
+// extension with |extension_id| in |profile_path|.
+// This searches the file system for .desktop files in appropriate locations. A
+// shortcut with NoDisplay=true causes hidden to become true, instead of
+// creating at APP_MENU_LOCATIONS_SUBDIR_CHROMEAPPS.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id);
+
+// Version of GetExistingShortcutLocations which takes an explicit path
+// to the user's desktop directory. Useful for testing.
+// If |desktop_path| is empty, the desktop is not searched.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// been added for the extension with |extension_id| in |profile_path|.
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// for the profile in |profile_path|.
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path);
+
+}  // namespace web_app
+
+#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
--- a/chrome/browser/web_applications/extensions/BUILD.gn
+++ b/chrome/browser/web_applications/extensions/BUILD.gn
@@ -66,7 +66,6 @@ source_set("unit_tests") {
     "//chrome/browser/web_applications:web_applications_test_support",
     "//chrome/browser/web_applications/components",
     "//chrome/common",
-    "//chrome/test:test_support",
     "//components/crx_file:crx_file",
     "//content/public/browser",
     "//content/test:test_support",
@@ -100,8 +99,6 @@ source_set("browser_tests") {
     "//chrome/browser/web_applications:web_applications_on_extensions_test_support",
     "//chrome/browser/web_applications:web_applications_test_support",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
     "//extensions:test_support",
     "//extensions/browser",
     "//extensions/common",
--- a/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
+++ b/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
@@ -67,12 +67,14 @@ void UpdateAllShortcutsForShortcutInfo(
     const base::string16& old_app_title,
     base::OnceClosure callback,
     std::unique_ptr<ShortcutInfo> shortcut_info) {
+#if 0
   base::FilePath shortcut_data_dir =
       internals::GetShortcutDataDir(*shortcut_info);
   internals::PostShortcutIOTaskAndReply(
       base::BindOnce(&internals::UpdatePlatformShortcuts,
                      std::move(shortcut_data_dir), old_app_title),
       std::move(shortcut_info), std::move(callback));
+#endif
 }
 
 }  // namespace
@@ -242,14 +244,6 @@ void CreateShortcuts(ShortcutCreationRea
 
 void DeleteAllShortcuts(Profile* profile, const extensions::Extension* app) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  std::unique_ptr<ShortcutInfo> shortcut_info(
-      ShortcutInfoForExtensionAndProfile(app, profile));
-  base::FilePath shortcut_data_dir =
-      internals::GetShortcutDataDir(*shortcut_info);
-  internals::PostShortcutIOTask(
-      base::BindOnce(&internals::DeletePlatformShortcuts, shortcut_data_dir),
-      std::move(shortcut_info));
 }
 
 void UpdateAllShortcuts(const base::string16& old_app_title,
--- /dev/null
+++ b/chrome/browser/web_applications/web_app_android.cc
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/web_app.h"
+
+#include <utility>
+
+#include "base/environment.h"
+#include "base/logging.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "chrome/browser/shell_integration_linux.h"
+
+namespace web_app {
+
+void UpdateShortcutsForAllApps(Profile* profile,
+                               const base::Closure& callback) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -121,7 +121,7 @@ template("chrome_extra_paks") {
       sources += invoker.additional_paks
     }
 
-    if (!is_android) {
+    if (true || !is_android) {
       # New paks should be added here by default.
       sources += [
         "$root_gen_dir/chrome/bookmarks_resources.pak",
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -421,7 +421,8 @@ static_library("common") {
       "media/chrome_media_drm_bridge_client.cc",
       "media/chrome_media_drm_bridge_client.h",
     ]
-  } else {
+  }
+  if (true) {
     # Non-Android.
     public_deps += [ "//chrome/common/importer" ]
   }
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -64,7 +64,7 @@ const base::Feature kAppNotificationStat
     "AppNotificationStatusMessaging", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // App Service related flags. See chrome/services/app_service/README.md.
 const base::Feature kAppServiceContextMenu{"AppServiceContextMenu",
                                            base::FEATURE_DISABLED_BY_DEFAULT};
@@ -328,7 +328,7 @@ const base::Feature kEnableAmbientAuthen
     "EnableAmbientAuthenticationInGuestSession",
     base::FEATURE_DISABLED_BY_DEFAULT};
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Upload enterprise cloud reporting without the extension.
 const base::Feature kEnterpriseReportingInBrowser{
     "EnterpriseReportingInBrowser", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -406,7 +406,7 @@ const base::Feature kHappinessTrackingSy
                                              base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Enables or disables the Happiness Tracking System for Desktop Chrome.
 const base::Feature kHappinessTrackingSurveysForDesktop{
     "HappinessTrackingSurveysForDesktop", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -514,14 +514,7 @@ const base::Feature kAcknowledgeNtpOverr
     "AcknowledgeNtpOverrideOnDeactivate", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-// Enables showing an entry for mixed content in site settings, which controls
-// allowing blockable mixed content. When enabled, the mixed content shield is
-// not shown on the omnibox, since its functionality is replaced by the
-// setting.
-const base::Feature kMixedContentSiteSetting{"MixedContentSiteSetting",
-                                             base::FEATURE_ENABLED_BY_DEFAULT};
-
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 const base::Feature kOnConnectNative{"OnConnectNative",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -55,7 +55,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppNotificationStatusMessaging;
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppServiceContextMenu;
 COMPONENT_EXPORT(CHROME_FEATURES)
@@ -187,7 +187,7 @@ extern const base::Feature kEnableAmbien
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnableAmbientAuthenticationInIncognito;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnterpriseReportingInBrowser;
 #endif
@@ -255,7 +255,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSystem;
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSurveysForDesktop;
 
@@ -327,7 +327,7 @@ extern const base::Feature kAcknowledgeN
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kMixedContentSiteSetting;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kOnConnectNative;
 #endif
 
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -545,7 +545,7 @@ bool PathProvider(int key, base::FilePat
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if true || defined(OS_LINUX) || defined(OS_MACOSX)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MACOSX)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -122,7 +122,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if true || defined(OS_LINUX) || defined(OS_MACOSX)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -846,7 +846,7 @@ const char kAllowNaClFileHandleAPI[]
 const char kAllowNaClSocketAPI[]            = "allow-nacl-socket-api";
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || true
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 
 // Causes the browser to launch directly in guest mode.
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -261,7 +261,7 @@ extern const char kAllowNaClFileHandleAP
 extern const char kAllowNaClSocketAPI[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || true
 extern const char kEnableNewAppMenuIcon[];
 extern const char kGuest[];
 #endif
--- a/chrome/common/extensions/api/api_sources.gni
+++ b/chrome/common/extensions/api/api_sources.gni
@@ -72,7 +72,7 @@ schema_sources_ = [
   "windows.json",
 ]
 
-if (!is_android) {
+if (true || !is_android) {
   schema_sources_ += [ "processes.idl" ]
 }
 
--- a/chrome/common/features.gni
+++ b/chrome/common/features.gni
@@ -30,8 +30,8 @@ declare_args() {
   builtin_cert_verifier_policy_supported = is_chromeos || is_desktop_linux
 
   # Enables support for background apps.
-  enable_background_contents = !is_android && !is_chromecast
-  enable_background_mode = !is_android && !is_chromecast && !is_chromeos
+  enable_background_contents = !is_chromecast
+  enable_background_mode = !is_chromecast && !is_chromeos
 
   # Enable the printing system dialog for platforms that support printing
   # and have a system dialog.
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -1041,7 +1041,7 @@ const char kSpeechRecognitionFilterProfa
 // permitted.
 const char kAllowDeletingBrowserHistory[] = "history.deleting_enabled";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Whether the "Click here to clear your browsing data" tooltip promo has been
 // shown on the History page.
 const char kHistoryMenuPromoShown[] = "history.menu_promo_shown";
@@ -1205,7 +1205,7 @@ const char kContentSettingsPluginWhiteli
     "profile.content_settings.plugin_whitelist";
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Double that indicates the default zoom level.
 const char kPartitionDefaultZoomLevel[] = "partition.default_zoom_level";
 
@@ -1494,7 +1494,7 @@ const char kWebRtcEventLogCollectionAllo
 // in ICE candidates.
 const char kWebRtcLocalIpsAllowedUrls[] = "webrtc.local_ips_allowed_urls";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Whether or not this profile has been shown the Welcome page.
 const char kHasSeenWelcomePage[] = "browser.has_seen_welcome_page";
 #endif
@@ -1663,7 +1663,7 @@ const char kDefaultTasksBySuffix[] =
 // send text across devices.
 const char kSharedClipboardEnabled[] = "browser.shared_clipboard_enabled";
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 // A flag to enable/disable the Click to Call feature which enables users to
 // send phone numbers from desktop to Android phones.
 const char kClickToCallEnabled[] = "browser.click_to_call_enabled";
@@ -1697,7 +1697,7 @@ const char kShutdownNumProcessesSlow[] =
 // before shutting everything down.
 const char kRestartLastSessionOnShutdown[] = "restart.last.session.on.shutdown";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 // Pref name for the policy controlling presentation of full-tab promotional
 // and/or educational content.
@@ -1740,7 +1740,7 @@ const char kNtpCollapsedSnapshotDocument
 
 // Keeps track of sync promo collapsed state in the Other Devices menu.
 const char kNtpCollapsedSyncPromo[] = "ntp.collapsed_sync_promo";
-#else
+
 // Holds info for New Tab Page custom background
 const char kNtpCustomBackgroundDict[] = "ntp.custom_background_dict";
 const char kNtpCustomBackgroundLocalToDevice[] =
@@ -1807,7 +1807,7 @@ const char kDevToolsTCPDiscoveryConfig[]
 // A dictionary with generic DevTools settings.
 const char kDevToolsPreferences[] = "devtools.preferences";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Tracks the number of times the dice signin promo has been shown in the user
 // menu.
 const char kDiceSigninUserMenuPromoCount[] = "sync_promo.user_menu_show_count";
@@ -2310,13 +2310,13 @@ const char kSystemTimezoneAutomaticDetec
 
 // Pref name for the policy controlling whether to enable Media Router.
 const char kEnableMediaRouter[] = "media_router.enable_media_router";
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Pref name for the policy controlling whether to force the Cast icon to be
 // shown in the toolbar/overflow menu.
 const char kShowCastIconInToolbar[] = "media_router.show_cast_icon_in_toolbar";
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Pref name for the policy controlling the way in which users are notified of
 // the need to relaunch the browser for a pending update.
 const char kRelaunchNotification[] = "browser.relaunch_notification";
@@ -2429,7 +2429,7 @@ const char kCustomHandlersEnabled[] = "c
 // by the cloud policy subsystem.
 const char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
@@ -2561,7 +2561,7 @@ const char kRecoveryComponentNeedsElevat
 const char kRegisteredSupervisedUserWhitelists[] =
     "supervised_users.whitelists";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Boolean that indicates whether Chrome enterprise cloud reporting is enabled
 // or not.
 const char kCloudReportingEnabled[] =
@@ -2828,7 +2828,7 @@ const char kSitePerProcess[] = "site_iso
 const char kUserTriggeredIsolatedOrigins[] =
     "site_isolation.user_triggered_isolated_origins";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Boolean that specifies whether media (audio/video) autoplay is allowed.
 const char kAutoplayAllowed[] = "media.autoplay_allowed";
 
@@ -2900,7 +2900,7 @@ const char kSharingSyncedDevices[] = "sh
 const char kSharingFCMRegistration[] = "sharing.fcm_registration";
 const char kSharingLocalSharingInfo[] = "sharing.local_sharing_info";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Dictionary that contains all of the Hats Survey Metadata.
 const char kHatsSurveyMetadata[] = "hats.survey_metadata";
 #endif  // !defined(OS_ANDROID)
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -328,7 +328,7 @@ extern const char kDeviceLoginScreenWebU
 extern const char kShowHomeButton[];
 extern const char kSpeechRecognitionFilterProfanities[];
 extern const char kAllowDeletingBrowserHistory[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHistoryMenuPromoShown[];
 #endif
 extern const char kForceGoogleSafeSearch[];
@@ -371,7 +371,7 @@ extern const char kUseCustomChromeFrame[
 #if BUILDFLAG(ENABLE_PLUGINS)
 extern const char kContentSettingsPluginWhitelist[];
 #endif
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kPartitionDefaultZoomLevel[];
 extern const char kPartitionPerHostZoomLevels[];
 
@@ -479,7 +479,7 @@ extern const char kWebRTCUDPPortRange[];
 extern const char kWebRtcEventLogCollectionAllowed[];
 extern const char kWebRtcLocalIpsAllowedUrls[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHasSeenWelcomePage[];
 #endif
 
@@ -549,7 +549,7 @@ extern const char kDefaultTasksBySuffix[
 
 extern const char kSharedClipboardEnabled[];
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 extern const char kClickToCallEnabled[];
 #endif  // BUILDFLAG(ENABLE_CLICK_TO_CALL)
 
@@ -565,7 +565,7 @@ extern const char kShutdownNumProcesses[
 extern const char kShutdownNumProcessesSlow[];
 
 extern const char kRestartLastSessionOnShutdown[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 extern const char kPromotionalTabsEnabled[];
 extern const char kCommandLineFlagSecurityWarningsEnabled[];
@@ -582,7 +582,7 @@ extern const char kNtpCollapsedForeignSe
 extern const char kNtpCollapsedRecentlyClosedTabs[];
 extern const char kNtpCollapsedSnapshotDocument[];
 extern const char kNtpCollapsedSyncPromo[];
-#else
+
 extern const char kNtpCustomBackgroundDict[];
 extern const char kNtpCustomBackgroundLocalToDevice[];
 extern const char kNtpPromoBlocklist[];
@@ -607,7 +607,7 @@ extern const char kDevToolsPreferences[]
 extern const char kDevToolsDiscoverTCPTargetsEnabled[];
 extern const char kDevToolsTCPDiscoveryConfig[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kDiceSigninUserMenuPromoCount[];
 #endif
 
@@ -801,11 +801,11 @@ extern const char kSystemTimezoneAutomat
 #endif  // defined(OS_CHROMEOS)
 
 extern const char kEnableMediaRouter[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kShowCastIconInToolbar[];
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kRelaunchNotification[];
 extern const char kRelaunchNotificationPeriod[];
 #endif  // !defined(OS_ANDROID)
@@ -814,7 +814,7 @@ extern const char kRelaunchNotificationP
 extern const char kRelaunchHeadsUpPeriod[];
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kAttemptedToEnableAutoupdate[];
 
 extern const char kMediaGalleriesUniqueId[];
@@ -865,7 +865,7 @@ extern const char kRecoveryComponentNeed
 
 extern const char kRegisteredSupervisedUserWhitelists[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kCloudReportingEnabled[];
 extern const char kCloudExtensionRequestEnabled[];
 extern const char kCloudExtensionRequestIds[];
@@ -975,7 +975,7 @@ extern const char kIsolateOrigins[];
 extern const char kSitePerProcess[];
 extern const char kUserTriggeredIsolatedOrigins[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kAutoplayAllowed[];
 extern const char kAutoplayWhitelist[];
 extern const char kBlockAutoplayEnabled[];
@@ -1012,7 +1012,7 @@ extern const char kSharingSyncedDevices[
 extern const char kSharingFCMRegistration[];
 extern const char kSharingLocalSharingInfo[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHatsSurveyMetadata[];
 #endif  // !defined(OS_ANDROID)
 
--- a/chrome/common/url_constants.h
+++ b/chrome/common/url_constants.h
@@ -350,12 +350,12 @@ extern const char kChromeCleanerLearnMor
 extern const char kWindowsXPVistaDeprecationURL[];
 #endif
 
-#if BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
+#if true || BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 // "Learn more" URL for the one click signin infobar.
 extern const char kChromeSyncLearnMoreURL[];
 #endif
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 // The URL for the "Learn more" page for the blocked plugin infobar.
 extern const char kBlockedPluginLearnMoreURL[];
 
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -321,7 +321,7 @@ bool IsSystemWebUIHost(base::StringPiece
 const char kChromeUICastHost[] = "cast";
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 const char kChromeUIHatsHost[] = "hats";
@@ -337,7 +337,7 @@ const char kChromeUISandboxHost[] = "san
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || true
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
 #endif
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -275,7 +275,7 @@ bool IsSystemWebUIHost(base::StringPiece
 extern const char kChromeUICastHost[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 extern const char kChromeUIHatsHost[];
@@ -292,7 +292,7 @@ extern const char kChromeUISandboxHost[]
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || true
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
 #endif
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -630,7 +630,7 @@ bool ChromeContentRendererClient::IsPlug
     const blink::WebElement& plugin_element,
     const GURL& original_url,
     const std::string& mime_type) {
-#if BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PLUGINS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PLUGINS)
   DCHECK(plugin_element.HasHTMLTagName("object") ||
          plugin_element.HasHTMLTagName("embed"));
   // Blink will next try to load a WebPlugin which would end up in
--- a/chrome/renderer/media/chrome_key_systems.cc
+++ b/chrome/renderer/media/chrome_key_systems.cc
@@ -329,7 +329,7 @@ void AddChromeKeySystems(
 
 #endif  // BUILDFLAG(ENABLE_LIBRARY_CDMS)
 
-#if defined(OS_ANDROID)
+#if BUILDFLAG(ENABLE_WIDEVINE) and defined(OS_ANDROID)
   cdm::AddAndroidWidevine(key_systems_properties);
 #endif  // defined(OS_ANDROID)
 }
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -4443,7 +4443,7 @@ test("unit_tests") {
     }
   }
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     sources += [
       "../../apps/saved_files_service_unittest.cc",
       "../../tools/json_schema_compiler/test/features_generation_unittest.cc",
--- a/chromecast/browser/cast_browser_context.cc
+++ b/chromecast/browser/cast_browser_context.cc
@@ -80,7 +80,7 @@ void CastBrowserContext::InitWhileIOAllo
   BrowserContext::Initialize(this, path_);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 CastBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
--- a/chromecast/browser/cast_browser_context.h
+++ b/chromecast/browser/cast_browser_context.h
@@ -25,7 +25,7 @@ class CastBrowserContext final : public
   ~CastBrowserContext() override;
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
--- a/components/autofill_payments_strings.grdp
+++ b/components/autofill_payments_strings.grdp
@@ -68,7 +68,7 @@
     </if>
   </if>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_AUTOFILL_FIELD_LABEL_PHONE" desc="The label of the Phone entry in a settings-like UI to enter a phone number.">
       Phone
     </message>
@@ -79,19 +79,15 @@
 
   <!-- Autofill save credit card bubble or infobar prompt -->
   <if expr="is_android or is_ios">
-    <then>
       <message name="IDS_AUTOFILL_SAVE_CARD_INFOBAR_ACCEPT" desc="Text to show for the Autofill save credit card infobar accept button.">
         Save
       </message>
-    </then>
-    <else>
       <message name="IDS_AUTOFILL_SAVE_CARD_BUBBLE_LOCAL_SAVE_ACCEPT" desc="Text to show for the Autofill save credit card local save bubble accept button.">
         Save
       </message>
       <message name="IDS_AUTOFILL_SAVE_CARD_BUBBLE_UPLOAD_SAVE_ACCEPT" desc="Text to show for the Autofill save credit card upload save bubble accept button.">
         Save
       </message>
-    </else>
   </if>
   <if expr="is_android">
     <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_CONFIRM" desc="Text to show for the Autofill upload save credit card prompt accept button when more information (e.g., CVC) was needed in order to save the card and was entered." formatter_data="android_java">
@@ -202,7 +198,7 @@
   </message>
 
   <!-- Autofill Local card migration bubble or dialog -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <message name="IDS_AUTOFILL_GOOGLE_PAY_LOGO_ACCESSIBLE_NAME" desc="The accessible name for the Google Pay logo in the local card migration bubble or dialog.">
       Google Pay logo
     </message>
@@ -406,7 +402,7 @@
 
   <!-- WebAuthn fingerprint opt-in dialog -->
   <!-- Desktop only -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <if expr="is_macosx">
       <message name="IDS_AUTOFILL_WEBAUTHN_OPT_IN_DIALOG_TITLE" desc="Headline asking the user if they want to use their device's platform authenticator to confirm their cards in the future instead of CVC.">
         Use Touch ID instead of CVC?
@@ -462,7 +458,7 @@
 
   <!-- Webauthn verify pending dialog -->
   <!-- Desktop only -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <message name="IDS_AUTOFILL_WEBAUTHN_VERIFY_PENDING_DIALOG_TITLE" desc="Headline of the dialog shown when user has opted in to use platform biometric authenticator and has selected one card to fill the form. This shows the verification of the selected card is in progress.">
         Verifying your identity...
     </message>
--- a/components/autofill_strings.grdp
+++ b/components/autofill_strings.grdp
@@ -165,7 +165,7 @@
     Show cards from your Google Account
   </message>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_AUTOFILL_POPUP_ACCESSIBLE_NODE_DATA" desc="The accessibility text to speak when we display an autofill popup.">
       Autofill
     </message>
--- a/components/bookmarks/browser/BUILD.gn
+++ b/components/bookmarks/browser/BUILD.gn
@@ -78,7 +78,7 @@ static_library("browser") {
     all_dependent_configs = [ "//ui/views:flags" ]
   }
 
-  if (toolkit_views && !is_mac) {
+  if (true || (toolkit_views && !is_mac)) {
     sources += [ "bookmark_node_data_views.cc" ]
   }
 
--- a/components/bookmarks/browser/bookmark_node_data.h
+++ b/components/bookmarks/browser/bookmark_node_data.h
@@ -18,7 +18,7 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #include "url/gurl.h"
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
 #include "ui/base/clipboard/clipboard_format_type.h"
 #endif
 
@@ -27,7 +27,7 @@ class Pickle;
 class PickleIterator;
 }
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
 namespace ui {
 class OSExchangeData;
 }
@@ -114,7 +114,7 @@ struct BookmarkNodeData {
 
   ~BookmarkNodeData();
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
   static const ui::ClipboardFormatType& GetBookmarkFormatType();
 #endif
 
@@ -133,7 +133,7 @@ struct BookmarkNodeData {
   // WriteToClipboard() but will also attempt to read a plain bookmark.
   bool ReadFromClipboard(ui::ClipboardBuffer buffer);
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
   // Writes elements to data. If there is only one element and it is a URL
   // the URL and title are written to the clipboard in a format other apps can
   // use.
--- a/components/components_strings.grd
+++ b/components/components_strings.grd
@@ -314,7 +314,7 @@
       <part file="undo_strings.grdp" />
       <part file="version_ui_strings.grdp" />
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="management_strings.grdp" />
       </if>
       <if expr="is_android">
@@ -394,7 +394,7 @@
       <message name="IDS_PLUGIN_NOT_SUPPORTED" desc="The placeholder text for an unsupported plugin.">
         This plugin is not supported
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_PRINT" desc="The text label of the Print... menu item. Opens a dialog box to select print settings">
             &amp;Print...
--- a/components/content_settings/core/browser/cookie_settings.cc
+++ b/components/content_settings/core/browser/cookie_settings.cc
@@ -58,6 +58,7 @@ void CookieSettings::GetCookieSettings(
 
 void CookieSettings::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] CookieSettings::RegisterProfilePrefs";
   registry->RegisterBooleanPref(
       prefs::kBlockThirdPartyCookies, true,
       user_prefs::PrefRegistrySyncable::SYNCABLE_PREF);
--- a/components/feature_engagement/public/event_constants.cc
+++ b/components/feature_engagement/public/event_constants.cc
@@ -12,13 +12,13 @@ namespace feature_engagement {
 namespace events {
 
 #if defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || true
 const char kNewTabOpened[] = "new_tab_opened";
 #endif  // defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) ||
         // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const char kReopenTabConditionsMet[] = "reopen_tab_conditions_met";
 const char kTabReopened[] = "tab_reopened";
 
--- a/components/feature_engagement/public/event_constants.h
+++ b/components/feature_engagement/public/event_constants.h
@@ -14,7 +14,7 @@ namespace events {
 
 // Desktop and IOS.
 #if defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || true
 // The user has explicitly opened a new tab via an entry point from inside of
 // Chrome.
 extern const char kNewTabOpened[];
@@ -23,7 +23,7 @@ extern const char kNewTabOpened[];
 
 // Desktop
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 // All conditions for reopen closed tab IPH were met. Since this IPH needs to
 // track user events (opening/closing tabs, focusing the omnibox, etc) on the
 // second level, it must be done manually.
--- a/components/feature_engagement/public/feature_constants.cc
+++ b/components/feature_engagement/public/feature_constants.cc
@@ -15,7 +15,7 @@ const base::Feature kIPHDummyFeature{"IP
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const base::Feature kIPHFocusModeFeature{"IPH_FocusMode",
                                          base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kIPHGlobalMediaControlsFeature{
--- a/components/feature_engagement/public/feature_constants.h
+++ b/components/feature_engagement/public/feature_constants.h
@@ -18,7 +18,7 @@ extern const base::Feature kIPHDemoMode;
 extern const base::Feature kIPHDummyFeature;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 extern const base::Feature kIPHFocusModeFeature;
 extern const base::Feature kIPHGlobalMediaControlsFeature;
 extern const base::Feature kIPHReopenTabFeature;
--- a/components/guest_view/browser/BUILD.gn
+++ b/components/guest_view/browser/BUILD.gn
@@ -6,7 +6,7 @@
 # assert to prevent the accidental building of GuestViews on mobile
 # platforms. If you're now using GuestViews on mobile, go ahead and
 # remove this assert.
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 static_library("browser") {
   output_name = "guest_view_browser"
--- a/components/guest_view/renderer/BUILD.gn
+++ b/components/guest_view/renderer/BUILD.gn
@@ -6,7 +6,7 @@
 # assert to prevent the accidental building of GuestViews on mobile
 # platforms. If you're now using GuestViews on mobile, go ahead and
 # remove this assert.
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 static_library("renderer") {
   sources = [
--- a/components/history_strings.grdp
+++ b/components/history_strings.grdp
@@ -63,7 +63,7 @@
       Clear Browsing Data...
     </message>
   </if>
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_HISTORY_OTHER_SESSIONS_COLLAPSE_SESSION" desc="In the 'Other Sessions' menu on the history page, the label for the command to collapse (hide) the list of windows and tabs in a session.">
       Collapse list
     </message>
--- a/components/keep_alive_registry/BUILD.gn
+++ b/components/keep_alive_registry/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android)
+# assert(!is_android)
 
 source_set("keep_alive_registry") {
   sources = [
--- a/components/new_or_sad_tab_strings.grdp
+++ b/components/new_or_sad_tab_strings.grdp
@@ -117,7 +117,7 @@
                desc="Title of the new tab page, not to be confused with the action of opening a new tab.">
         New Tab
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_NEW_TAB_OTR_HEADING"
                  desc="Heading used when a person opens an OTR window">
           Youve gone incognito
--- a/components/page_info_strings.grdp
+++ b/components/page_info_strings.grdp
@@ -175,7 +175,7 @@
     </message>
 
     <!-- Certificate Viewer link -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_CERTIFICATE" desc="Title of the certificate area in the Page Info bubble, shown when a HTTPS site is loaded.">
         Certificate
       </message>
@@ -203,7 +203,7 @@
     </if>
 
     <!-- Cookies -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_COOKIES" desc="The label for the Cookies setting in the Page Information Window.">
         Cookies
       </message>
@@ -412,8 +412,8 @@
     </message>
 
     <!-- Permission change infobar. -->
-    <if expr="not is_android">
-      <message name="IDS_PAGE_INFO_INFOBAR_TEXT" desc="The string shown in the infobar after the user has changed site permissions settings, reminding them to reload the page in order for the new settings to take effect.">
+    <if expr="is_android or not is_android">
+      <message name=" IDS_PAGE_INFO_INFOBAR_TEXT" desc="The string shown in the infobar after the user has changed site permissions settings, reminding them to reload the page in order for the new settings to take effect.">
         To apply your updated settings to this site, reload this page
       </message>
       <message name="IDS_PAGE_INFO_INFOBAR_BUTTON" desc="The string used in the infobar button allowing the user to reload the page directly from the infobar.">
--- a/components/payments/content/payment_request.cc
+++ b/components/payments/content/payment_request.cc
@@ -126,7 +126,7 @@ void PaymentRequest::Init(
     mojo::PendingRemote<mojom::PaymentRequestClient> client,
     std::vector<mojom::PaymentMethodDataPtr> method_data,
     mojom::PaymentDetailsPtr details,
-    mojom::PaymentOptionsPtr options) {
+    mojom::PaymentOptionsPtr options, bool google_pay_bridge_eligible) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (is_initialized_) {
--- a/components/payments/content/payment_request.h
+++ b/components/payments/content/payment_request.h
@@ -72,7 +72,7 @@ class PaymentRequest : public mojom::Pay
   void Init(mojo::PendingRemote<mojom::PaymentRequestClient> client,
             std::vector<mojom::PaymentMethodDataPtr> method_data,
             mojom::PaymentDetailsPtr details,
-            mojom::PaymentOptionsPtr options) override;
+            mojom::PaymentOptionsPtr options, bool google_pay_bridge_eligible) override;
   void Show(bool is_user_gesture, bool wait_for_updated_details) override;
   void Retry(mojom::PaymentValidationErrorsPtr errors) override;
   void UpdateWith(mojom::PaymentDetailsPtr details) override;
--- a/components/payments_strings.grdp
+++ b/components/payments_strings.grdp
@@ -552,7 +552,7 @@
   </if>
 
   <!-- Payment Request section preview strings. They are slightly different on desktop and android because the pluralization and formatting code behaves differently. -->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_PAYMENT_REQUEST_PAYMENT_METHODS_PREVIEW" desc="This is a snippet of a payment method a user has saved to Chrome, plus an indication of the number of additional payment methods the user has saved. Its function is to show the user has payment methods that can be used to complete a payment, and thus doesn't have to type the entire payment method. [ICU Syntax]">
     {PAYMENT_METHOD, plural,
        =0 {<ph name="PAYMENT_METHOD_PREVIEW">{1}<ex>VISA ....1234</ex></ph>}
--- a/components/pdf_strings.grdp
+++ b/components/pdf_strings.grdp
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <grit-part>
-  <if expr="enable_plugins">
+  <if expr="is_android or enable_plugins">
     <message name="IDS_PDF_NEED_PASSWORD" desc="A message asking the user for a password to open a PDF file.">
       This document is password protected.  Please enter a password.
     </message>
--- a/components/policy/core/browser/configuration_policy_handler.cc
+++ b/components/policy/core/browser/configuration_policy_handler.cc
@@ -364,6 +364,7 @@ SchemaValidatingPolicyHandler::SchemaVal
     Schema schema,
     SchemaOnErrorStrategy strategy)
     : policy_name_(policy_name), schema_(schema), strategy_(strategy) {
+  LOG(ERROR) << "[Kiwi] Processing schema: " << policy_name;
   DCHECK(schema_.valid());
 }
 
--- a/components/policy/resources/policy_templates.json
+++ b/components/policy/resources/policy_templates.json
@@ -3976,7 +3976,7 @@
         'items': { 'type': 'string' },
         'id': 'ExtensionInstallSources',
       },
-      'supported_on': ['chrome.*:21-', 'chrome_os:21-'],
+      'supported_on': ['chrome.*:21-', 'chrome_os:21-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4035,7 +4035,7 @@
         },
         'id': 'ExtensionAllowedTypes',
       },
-      'supported_on': ['chrome.*:25-', 'chrome_os:25-'],
+      'supported_on': ['chrome.*:25-', 'chrome_os:25-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4150,7 +4150,7 @@
         },
       },
       'url_schema': 'https://www.ch40m1um.qjz9zk/administrators/policy-list-3/extension-settings-full',
-      'supported_on': ['chrome.*:62-', 'chrome_os:62-'],
+      'supported_on': ['chrome.*:62-', 'chrome_os:62-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4422,7 +4422,7 @@
       'owners': ['file://components/policy/resources/OWNERS'],
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.*:10-', 'chrome_os:11-'],
+      'supported_on': ['chrome.*:10-', 'chrome_os:11-', 'android:30-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -16499,7 +16499,7 @@
           'required': ['url']
         }
       },
-      'supported_on': ['chrome.*:75-', 'chrome_os:75-'],
+      'supported_on': ['chrome.*:75-', 'chrome_os:75-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
--- a/components/prefs/pref_service.cc
+++ b/components/prefs/pref_service.cc
@@ -97,12 +97,16 @@ PrefService::PrefService(
       user_pref_store_(std::move(user_prefs)),
       read_error_callback_(std::move(read_error_callback)),
       pref_registry_(std::move(pref_registry)) {
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 1";
   pref_notifier_->SetPrefService(this);
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 2";
 
   DCHECK(pref_registry_);
   DCHECK(pref_value_store_);
 
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 3";
   InitFromStorage(async);
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 4";
 }
 
 PrefService::~PrefService() {
--- a/components/search/search.cc
+++ b/components/search/search.cc
@@ -9,11 +9,7 @@
 namespace search {
 
 bool IsInstantExtendedAPIEnabled() {
-#if defined(OS_IOS) || defined(OS_ANDROID)
-  return false;
-#else
   return true;
-#endif
 }
 
 }  // namespace search
--- a/components/signin/features.gni
+++ b/components/signin/features.gni
@@ -3,7 +3,7 @@
 # found in the LICENSE file.
 
 # Dice is supported on the platform (but not necessarily enabled).
-enable_dice_support = (is_linux && !is_chromeos) || is_mac || is_win
+enable_dice_support = (is_linux && !is_chromeos) || is_mac || is_win || is_android
 
 # Mirror is enabled and other account consistency mechanisms are not available.
 enable_mirror = is_android || is_ios
--- a/components/sync_ui_strings.grdp
+++ b/components/sync_ui_strings.grdp
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <grit-part>
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_SYNC_BASIC_ENCRYPTION_DATA" desc="Text of the radio that when selected enables basic encryption.">
       Encrypt synced passwords with your Google credentials
     </message>
--- a/components/ui_devtools/views/BUILD.gn
+++ b/components/ui_devtools/views/BUILD.gn
@@ -34,6 +34,13 @@ source_set("views") {
     "//ui/views",
   ]
 
+  sources += [
+    "dom_agent_android.cc",
+    "dom_agent_android.h",
+    "overlay_agent_android.cc",
+    "overlay_agent_android.h",
+  ]
+
   if (use_aura) {
     sources += [
       "dom_agent_aura.cc",
--- /dev/null
+++ b/components/ui_devtools/views/dom_agent_android.cc
@@ -0,0 +1,44 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/ui_devtools/views/dom_agent_android.h"
+
+#include "base/stl_util.h"
+#include "components/ui_devtools/views/widget_element.h"
+#include "components/ui_devtools/views/window_element.h"
+
+namespace ui_devtools {
+
+namespace {
+using ui_devtools::protocol::Array;
+using ui_devtools::protocol::DOM::Node;
+}  // namespace
+
+DOMAgentAndroid* DOMAgentAndroid::dom_agent_android_ = nullptr;
+
+DOMAgentAndroid::DOMAgentAndroid() {
+  DCHECK(!dom_agent_android_);
+  dom_agent_android_ = this;
+}
+
+DOMAgentAndroid::~DOMAgentAndroid() {
+  dom_agent_android_ = nullptr;
+}
+
+std::vector<UIElement*> DOMAgentAndroid::CreateChildrenForRoot() {
+  std::vector<UIElement*> children;
+  return children;
+}
+
+std::unique_ptr<Node> DOMAgentAndroid::BuildTreeForWindow(
+    UIElement* window_element_root) {
+  return nullptr;
+}
+
+// static
+std::unique_ptr<DOMAgentViews> DOMAgentViews::Create() {
+  return std::make_unique<DOMAgentAndroid>();
+}
+
+}  // namespace ui_devtools
--- /dev/null
+++ b/components/ui_devtools/views/dom_agent_android.h
@@ -0,0 +1,32 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_ANDROID_H_
+#define COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_ANDROID_H_
+
+#include "components/ui_devtools/views/dom_agent_views.h"
+
+namespace ui_devtools {
+
+class DOMAgentAndroid : public DOMAgentViews {
+
+ public:
+  DOMAgentAndroid();
+
+  ~DOMAgentAndroid() override;
+  static DOMAgentAndroid* GetInstance() { return dom_agent_android_; }
+
+  std::vector<UIElement*> CreateChildrenForRoot() override;
+
+  std::unique_ptr<protocol::DOM::Node> BuildTreeForWindow(
+      UIElement* window_element_root) override;
+
+ private:
+  static DOMAgentAndroid* dom_agent_android_;
+
+  DISALLOW_COPY_AND_ASSIGN(DOMAgentAndroid);
+};
+}  // namespace ui_devtools
+
+#endif  // COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_AURA_H_
--- /dev/null
+++ b/components/ui_devtools/views/overlay_agent_android.cc
@@ -0,0 +1,44 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/ui_devtools/views/overlay_agent_android.h"
+
+#include "components/ui_devtools/dom_agent.h"
+#include "components/ui_devtools/views/window_element.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/window_util.h"
+
+namespace ui_devtools {
+
+OverlayAgentAndroid* OverlayAgentAndroid::overlay_agent_android_ = nullptr;
+
+OverlayAgentAndroid::OverlayAgentAndroid(DOMAgent* dom_agent)
+    : OverlayAgentViews(dom_agent) {
+  DCHECK(!overlay_agent_android_);
+  overlay_agent_android_ = this;
+}
+
+OverlayAgentAndroid::~OverlayAgentAndroid() {
+  overlay_agent_android_ = nullptr;
+}
+
+void OverlayAgentAndroid::InstallPreTargetHandler() {
+}
+
+void OverlayAgentAndroid::RemovePreTargetHandler() {
+}
+
+int OverlayAgentAndroid::FindElementIdTargetedByPoint(
+    ui::LocatedEvent* event) const {
+  return 0;
+}
+
+// static
+std::unique_ptr<OverlayAgentViews> OverlayAgentViews::Create(
+    DOMAgent* dom_agent) {
+  return std::make_unique<OverlayAgentAndroid>(dom_agent);
+}
+
+}  // namespace ui_devtools
--- /dev/null
+++ b/components/ui_devtools/views/overlay_agent_android.h
@@ -0,0 +1,36 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_ANDROID_H_
+#define COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_ANDROID_H_
+
+#include "components/ui_devtools/views/overlay_agent_views.h"
+
+namespace ui_devtools {
+
+class DOMAgent;
+
+class OverlayAgentAndroid : public OverlayAgentViews {
+ public:
+  OverlayAgentAndroid(DOMAgent* dom_agent);
+  ~OverlayAgentAndroid() override;
+
+  int FindElementIdTargetedByPoint(ui::LocatedEvent* event) const override;
+  static OverlayAgentAndroid* GetInstance() { return overlay_agent_android_; }
+
+ private:
+  void InstallPreTargetHandler() override;
+  void RemovePreTargetHandler() override;
+
+  FRIEND_TEST_ALL_PREFIXES(OverlayAgentTest, HighlightWindow);
+  FRIEND_TEST_ALL_PREFIXES(OverlayAgentTest, HighlightEmptyOrInvisibleWindow);
+
+  static OverlayAgentAndroid* overlay_agent_android_;
+
+  DISALLOW_COPY_AND_ASSIGN(OverlayAgentAndroid);
+};
+
+}  // namespace ui_devtools
+
+#endif  // COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_AURA_H_
--- a/components/ui_devtools/views/overlay_agent_views.cc
+++ b/components/ui_devtools/views/overlay_agent_views.cc
@@ -718,10 +718,6 @@ bool OverlayAgentViews::UpdateHighlight(
   layer_for_highlighting_screen_offset_ =
       widget->GetContentsView()->GetBoundsInScreen().OffsetFromOrigin();
 #else
-  gfx::NativeWindow root = window_and_bounds.first->GetRootWindow();
-  root_layer = root->layer();
-  layer_for_highlighting_screen_offset_ =
-      root->GetBoundsInScreen().OffsetFromOrigin();
 #endif  // defined(OS_MACOSX)
   DCHECK(root_layer);
 
--- a/components/url_formatter/elide_url.cc
+++ b/components/url_formatter/elide_url.cc
@@ -25,7 +25,7 @@
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 const base::char16 kDot = '.';
 
 // Build a path from the first |num_components| elements in |path_elements|.
@@ -144,7 +144,7 @@ base::string16 HostForDisplay(base::Stri
 
 namespace url_formatter {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 // TODO(pkasting): http://crbug.com/77883 This whole function gets
 // kerning/ligatures/etc. issues potentially wrong by assuming that the width of
--- a/components/url_formatter/elide_url.h
+++ b/components/url_formatter/elide_url.h
@@ -27,7 +27,7 @@ namespace url_formatter {
 
 // ElideUrl and Elide host require
 // gfx::GetStringWidthF which is not implemented in Android
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // This function takes a GURL object and elides it. It returns a string
 // composed of parts from subdomain, domain, path, filename and query.
 // A "..." is added automatically at the end if the elided string is bigger
--- a/components/web_modal/BUILD.gn
+++ b/components/web_modal/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 component("web_modal") {
   sources = [
--- a/components/zoom/BUILD.gn
+++ b/components/zoom/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android && !is_ios, "Desktop zoom is not used on mobile platforms.")
+# assert(!is_android && !is_ios, "Desktop zoom is not used on mobile platforms.")
 
 static_library("zoom") {
   sources = [
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -413,6 +413,7 @@ class ContentClientInitializer {
   static void Set(const std::string& process_type,
                   ContentMainDelegate* delegate) {
     ContentClient* content_client = GetContentClient();
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Step 1";
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
     if (process_type.empty())
       content_client->browser_ = delegate->CreateContentBrowserClient();
@@ -456,6 +457,7 @@ int RunZygote(ContentMainDelegate* deleg
     {switches::kPpapiPluginProcess, PpapiPluginMain},
 #endif
   };
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - RunZygote";
 
   std::vector<std::unique_ptr<service_manager::ZygoteForkDelegate>>
       zygote_fork_delegates;
@@ -525,9 +527,11 @@ static void RegisterMainThreadFactories(
 // Returns the exit code for this process.
 int RunBrowserProcessMain(const MainFunctionParams& main_function_params,
                           ContentMainDelegate* delegate) {
+  LOG(ERROR) << "[Kiwi] RunBrowserProcessMain - Step 1";
   int exit_code = delegate->RunProcess("", main_function_params);
   if (exit_code >= 0)
     return exit_code;
+  LOG(ERROR) << "[Kiwi] RunBrowserProcessMain - Step 2";
   return BrowserMain(main_function_params);
 }
 #endif  // !defined(CHROME_MULTIPLE_DLL_CHILD)
@@ -590,6 +594,7 @@ int ContentMainRunnerImpl::TerminateForF
 }
 
 int ContentMainRunnerImpl::Initialize(const ContentMainParams& params) {
+  LOG(ERROR) << "[Kiwi] ContentMainRunnerImpl::Initialize - Step 1";
   ui_task_ = params.ui_task;
   created_main_parts_closure_ = params.created_main_parts_closure;
 
@@ -867,6 +872,8 @@ int ContentMainRunnerImpl::Run(bool star
 
   RegisterMainThreadFactories();
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager";
+
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
   if (process_type.empty())
     return RunServiceManager(main_params, start_service_manager_only);
@@ -914,34 +921,46 @@ int ContentMainRunnerImpl::RunServiceMan
     // incorrect to post to a BrowserThread before this point. This instantiates
     // and binds the MessageLoopForUI on the main thread (but it's only labeled
     // as BrowserThread::UI in BrowserMainLoop::MainMessageLoopStart).
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3c";
     BrowserTaskExecutor::Create();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3d";
     delegate_->PostEarlyInitialization(main_params.ui_task != nullptr);
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e";
     if (GetContentClient()->browser()->ShouldCreateThreadPool()) {
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e-1";
       // The FeatureList needs to create before starting the ThreadPool.
       StartBrowserThreadPool();
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e-2";
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3f";
 
     BrowserTaskExecutor::PostFeatureListSetup();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3g";
     tracing::InitTracingPostThreadPoolStartAndFeatureList();
 
     if (should_start_service_manager_only)
       ForceInProcessNetworkService(true);
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3h";
     discardable_shared_memory_manager_ =
         std::make_unique<discardable_memory::DiscardableSharedMemoryManager>();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3i";
     // PowerMonitor is needed in reduced mode. BrowserMainLoop will safely skip
     // initializing it again if it has already been initialized.
     base::PowerMonitor::Initialize(
         std::make_unique<base::PowerMonitorDeviceSource>());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3j";
 
     service_manager_environment_ = std::make_unique<ServiceManagerEnvironment>(
         BrowserTaskExecutor::CreateIOThread());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3k";
     download::SetIOTaskRunner(
         service_manager_environment_->ipc_thread()->task_runner());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3l";
 
     InitializeBrowserMemoryInstrumentationClient();
 
@@ -953,15 +972,19 @@ int ContentMainRunnerImpl::RunServiceMan
 #endif
   }
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 5";
   if (should_start_service_manager_only) {
     DVLOG(0) << "Chrome is running in ServiceManager only mode.";
     return -1;
   }
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 6";
+
   DVLOG(0) << "Chrome is running in full browser mode.";
   is_browser_main_loop_started_ = true;
   startup_data_ = service_manager_environment_->CreateBrowserStartupData();
   main_params.startup_data = startup_data_.get();
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 7";
   return RunBrowserProcessMain(main_params, delegate_);
 }
 #endif  // !defined(CHROME_MULTIPLE_DLL_CHILD)
--- a/content/app/content_service_manager_main_delegate.cc
+++ b/content/app/content_service_manager_main_delegate.cc
@@ -23,6 +23,7 @@ ContentServiceManagerMainDelegate::~Cont
 
 int ContentServiceManagerMainDelegate::Initialize(
     const InitializeParams& params) {
+  LOG(ERROR) << "[Kiwi] ContentServiceManagerMainDelegate::Initialize - Step 1";
 #if defined(OS_ANDROID)
   // May be called twice on Android due to the way browser startup requests are
   // dispatched by the system.
@@ -33,6 +34,7 @@ int ContentServiceManagerMainDelegate::I
 #if defined(OS_MACOSX)
   content_main_params_.autorelease_pool = params.autorelease_pool;
 #endif
+  LOG(ERROR) << "[Kiwi] ContentServiceManagerMainDelegate::Initialize - Step 2";
 
   return content_main_runner_->Initialize(content_main_params_);
 }
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2202,9 +2202,11 @@ jumbo_source_set("browser") {
       "renderer_host/pepper/pepper_truetype_font_host.cc",
       "renderer_host/pepper/pepper_truetype_font_host.h",
       "renderer_host/pepper/pepper_truetype_font_linux.cc",
+      "renderer_host/pepper/pepper_truetype_font_android.cc",
       "renderer_host/pepper/pepper_truetype_font_list.h",
       "renderer_host/pepper/pepper_truetype_font_list_host.cc",
       "renderer_host/pepper/pepper_truetype_font_list_host.h",
+      "renderer_host/pepper/pepper_truetype_font_list_android.cc",
       "renderer_host/pepper/pepper_truetype_font_list_mac.mm",
       "renderer_host/pepper/pepper_truetype_font_list_win.cc",
       "renderer_host/pepper/pepper_truetype_font_mac.mm",
@@ -2433,7 +2435,7 @@ jumbo_source_set("browser") {
     }
     defines += [ "APPCACHE_USE_SIMPLE_CACHE" ]
     libs += [ "jnigraphics" ]
-  } else {
+
     # Not Android.
     sources += [
       # The WebAuthn devtools protocol API is not supported in Android yet.
@@ -2441,8 +2443,6 @@ jumbo_source_set("browser") {
       "$target_gen_dir/devtools/protocol/web_authn.h",
 
       # Devtools frontend not included in Android
-      "devtools/devtools_frontend_host_impl.cc",
-      "devtools/devtools_frontend_host_impl.h",
       "devtools/protocol/webauthn_handler.cc",
       "devtools/protocol/webauthn_handler.h",
       "host_zoom_level_context.cc",
@@ -2580,12 +2580,16 @@ jumbo_source_set("browser") {
     ]
   }
 
-  if (use_aura || is_mac) {
+  if (true || use_aura || is_mac) {
+if (false) {
     sources += [
       "compositor/image_transport_factory.cc",
       "compositor/image_transport_factory.h",
       "compositor/viz_process_transport_factory.cc",
       "compositor/viz_process_transport_factory.h",
+    ]
+}
+    sources += [
       "context_factory.cc",
       "renderer_host/browser_compositor_view_mac.h",
       "renderer_host/browser_compositor_view_mac.mm",
--- a/content/browser/browser_main.cc
+++ b/content/browser/browser_main.cc
@@ -31,6 +31,7 @@ class ScopedBrowserMainEvent {
 
 // Main routine for running as the Browser process.
 int BrowserMain(const MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 1";
   ScopedBrowserMainEvent scoped_browser_main_event;
 
   base::trace_event::TraceLog::GetInstance()->set_process_name("Browser");
@@ -39,13 +40,16 @@ int BrowserMain(const MainFunctionParams
 
   std::unique_ptr<BrowserMainRunnerImpl> main_runner(
       BrowserMainRunnerImpl::Create());
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 2";
 
   int exit_code = main_runner->Initialize(parameters);
   if (exit_code >= 0)
     return exit_code;
 
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 3";
   exit_code = main_runner->Run();
 
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 4";
   main_runner->Shutdown();
 
   return exit_code;
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -583,6 +583,7 @@ BrowserMainLoop::~BrowserMainLoop() {
 }
 
 void BrowserMainLoop::Init() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::Init - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::Init");
 
   // |startup_data| is optional. If set, the thread owned by the data
@@ -598,6 +599,7 @@ void BrowserMainLoop::Init() {
     service_manager_shutdown_closure_ =
         std::move(startup_data->service_manager_shutdown_closure);
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::Init - Step 2";
 
   parts_ = GetContentClient()->browser()->CreateBrowserMainParts(parameters_);
 }
@@ -830,6 +832,7 @@ void BrowserMainLoop::PostMainMessageLoo
 }
 
 int BrowserMainLoop::PreCreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PreCreateThreads - Step 1";
   if (parts_) {
     TRACE_EVENT0("startup",
         "BrowserMainLoop::CreateThreads:PreCreateThreads");
@@ -889,6 +892,7 @@ int BrowserMainLoop::PreCreateThreads()
 
   // Record metrics about which site isolation flags have been turned on.
   SiteIsolationPolicy::StartRecordingSiteIsolationFlagUsage();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PreCreateThreads - Step 2";
 
   return result_code_;
 }
@@ -898,6 +902,7 @@ void BrowserMainLoop::PreShutdown() {
 }
 
 void BrowserMainLoop::CreateStartupTasks() {
+  LOG(ERROR) << "BrowserMainLoop::CreateStartupTasks - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::CreateStartupTasks");
 
   DCHECK(!startup_task_runner_);
@@ -966,11 +971,13 @@ void BrowserMainLoop::SynchronouslyFlush
 #endif  // OS_ANDROID
 
 int BrowserMainLoop::CreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 1";
   TRACE_EVENT0("startup,rail", "BrowserMainLoop::CreateThreads");
 
   // Release the ThreadPool's threads.
   scoped_execution_fence_.reset();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 2";
   // The |io_thread| can have optionally been injected into Init(), but if not,
   // create it here. Thre thread is only tagged as BrowserThread::IO here in
   // order to prevent any code from statically posting to it before
@@ -979,9 +986,12 @@ int BrowserMainLoop::CreateThreads() {
   if (!io_thread_) {
     io_thread_ = BrowserTaskExecutor::CreateIOThread();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 3";
   io_thread_->RegisterAsBrowserThread();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 4";
   BrowserTaskExecutor::InitializeIOThread();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 5";
   // TODO(https://crbug.com/863341): Replace with a better API
   GetContentClient()->browser()->PostAfterStartupTask(
       FROM_HERE, base::SequencedTaskRunnerHandle::Get(),
@@ -998,20 +1008,24 @@ int BrowserMainLoop::CreateThreads() {
           // Accessing an Unretained pointer to BrowserMainLoop from a main
           // thread task is therefore safe.
           base::Unretained(this)));
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 6";
 
   created_threads_ = true;
   return result_code_;
 }
 
 int BrowserMainLoop::PostCreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 1";
   tracing_controller_ = std::make_unique<content::TracingControllerImpl>();
   content::BackgroundTracingManagerImpl::GetInstance()
       ->AddMetadataGeneratorFunction();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 2";
   if (parts_) {
     TRACE_EVENT0("startup", "BrowserMainLoop::PostCreateThreads");
     parts_->PostCreateThreads();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 3";
 
   return result_code_;
 }
@@ -1237,16 +1251,19 @@ void BrowserMainLoop::InitializeMainThre
 }
 
 int BrowserMainLoop::BrowserThreadsStarted() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::BrowserThreadsStarted");
 
   // Bring up Mojo IPC and the embedded Service Manager as early as possible.
   // Initializaing mojo requires the IO thread to have been initialized first,
   // so this cannot happen any earlier than now.
   InitializeMojo();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 2";
 
   data_decoder_service_provider_ = std::make_unique<OopDataDecoder>();
 
   HistogramSynchronizer::GetInstance();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 3";
 
   // cc assumes a single client name for metrics in a process, which is
   // is inconsistent with single process mode where both the renderer and
@@ -1266,6 +1283,7 @@ int BrowserMainLoop::BrowserThreadsStart
   InitShaderCacheFactorySingleton(
       base::CreateSingleThreadTaskRunner({BrowserThread::IO}));
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 4";
   // Initialize the FontRenderParams on IO thread. This needs to be initialized
   // before gpu process initialization below.
   base::PostTask(FROM_HERE, {BrowserThread::IO},
@@ -1273,6 +1291,7 @@ int BrowserMainLoop::BrowserThreadsStart
                                 gfx::GetFontRenderParams(
                                     gfx::FontRenderParamsQuery(), nullptr)));
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 5";
   bool always_uses_gpu = true;
   bool established_gpu_channel = false;
 #if defined(OS_ANDROID)
@@ -1287,6 +1306,7 @@ int BrowserMainLoop::BrowserThreadsStart
       parsed_command_line_.HasSwitch(switches::kDisableGpuEarlyInit)) {
     established_gpu_channel = always_uses_gpu = false;
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 6";
 
   host_frame_sink_manager_ = std::make_unique<viz::HostFrameSinkManager>();
   BrowserGpuChannelHostFactory::Initialize(established_gpu_channel);
@@ -1320,6 +1340,7 @@ int BrowserMainLoop::BrowserThreadsStart
     TRACE_EVENT0("startup", "BrowserThreadsStarted::Subsystem:MidiService");
     midi_service_.reset(new midi::MidiService);
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 7";
 
   {
     TRACE_EVENT0("startup", "BrowserThreadsStarted::Subsystem:Devices");
@@ -1344,6 +1365,7 @@ int BrowserMainLoop::BrowserThreadsStart
   device_monitor_mac_.reset(
       new media::DeviceMonitorMac(base::ThreadTaskRunnerHandle::Get()));
 #endif
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 8";
 
   // Instantiated once using CreateSingletonInstance(), and accessed only using
   // GetInstance(), which is not allowed to create the object. This allows us
@@ -1416,6 +1438,7 @@ int BrowserMainLoop::BrowserThreadsStart
                        GPU_PROCESS_KIND_SANDBOXED, true /* force_create */));
   }
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 9";
 #if defined(OS_WIN)
   if (!parsed_command_line_.HasSwitch(
           switches::kDisableGpuProcessForDX12VulkanInfoCollection)) {
@@ -1516,6 +1539,7 @@ void BrowserMainLoop::InitializeMojo() {
     // thread.
     mojo::SyncCallRestrictions::DisallowSyncCall();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 12";
 
   // Ensure that any NavigableContentsViews constructed in the browser process
   // know they're running in the same process as the service.
--- a/content/browser/browser_main_runner_impl.cc
+++ b/content/browser/browser_main_runner_impl.cc
@@ -62,6 +62,7 @@ BrowserMainRunnerImpl::~BrowserMainRunne
 }
 
 int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 1";
   SCOPED_UMA_HISTOGRAM_LONG_TIMER(
       "Startup.BrowserMainRunnerImplInitializeLongTime");
   TRACE_EVENT0("startup", "BrowserMainRunnerImpl::Initialize");
@@ -75,6 +76,7 @@ int BrowserMainRunnerImpl::Initialize(co
 
     const base::TimeTicks start_time_step1 = base::TimeTicks::Now();
 
+    LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 2";
     SkGraphics::Init();
 
     if (parameters.command_line.HasSwitch(switches::kWaitForDebugger))
@@ -93,6 +95,7 @@ int BrowserMainRunnerImpl::Initialize(co
 #endif  // OS_WIN
 
     gfx::InitializeFonts();
+    LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 3";
 
     main_loop_.reset(
         new BrowserMainLoop(parameters, std::move(scoped_execution_fence_)));
--- a/content/browser/frame_host/navigation_controller_impl.cc
+++ b/content/browser/frame_host/navigation_controller_impl.cc
@@ -946,8 +946,10 @@ void NavigationControllerImpl::LoadURL(c
 }
 
 void NavigationControllerImpl::LoadURLWithParams(const LoadURLParams& params) {
+#if 0
   if (params.is_renderer_initiated)
     DCHECK(params.initiator_origin.has_value());
+#endif
 
   TRACE_EVENT1("browser,navigation",
                "NavigationControllerImpl::LoadURLWithParams", "url",
@@ -3087,7 +3089,9 @@ NavigationControllerImpl::CreateNavigati
   DCHECK_EQ(-1, GetIndexOfEntry(entry));
   DCHECK(frame_entry);
   // All renderer-initiated navigations must have an initiator_origin.
+#if 0
   DCHECK(!params.is_renderer_initiated || params.initiator_origin.has_value());
+#endif
 
   GURL url_to_load;
   GURL virtual_url;
--- a/content/browser/frame_host/navigation_request.cc
+++ b/content/browser/frame_host/navigation_request.cc
@@ -870,7 +870,9 @@ NavigationRequest::NavigationRequest(
       commit_navigation_client_(mojo::NullAssociatedRemote()),
       rfh_restored_from_back_forward_cache_(
           rfh_restored_from_back_forward_cache) {
+#if 0
   DCHECK(browser_initiated_ || common_params_->initiator_origin.has_value());
+#endif
   DCHECK(!IsRendererDebugURL(common_params_->url));
   DCHECK(common_params_->method == "POST" || !common_params_->post_data);
   TRACE_EVENT_ASYNC_BEGIN2("navigation", "NavigationRequest", this,
--- /dev/null
+++ b/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
@@ -0,0 +1,78 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/pepper/pepper_truetype_font.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/compiler_specific.h"
+#include "base/files/scoped_file.h"
+#include "base/macros.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/sys_byteorder.h"
+#include "build/build_config.h"
+#include "components/services/font/ppapi_fontconfig_matching.h"
+#include "content/public/common/common_sandbox_support_linux.h"
+#include "ppapi/buildflags/buildflags.h"
+#include "ppapi/c/dev/ppb_truetype_font_dev.h"
+#include "ppapi/c/pp_errors.h"
+#include "ppapi/c/trusted/ppb_browser_font_trusted.h"
+
+namespace content {
+
+namespace {
+
+class PepperTrueTypeFontAndroid : public PepperTrueTypeFont {
+ public:
+  PepperTrueTypeFontAndroid();
+
+  // PepperTrueTypeFont implementation.
+  int32_t Initialize(ppapi::proxy::SerializedTrueTypeFontDesc* desc) override;
+  int32_t GetTableTags(std::vector<uint32_t>* tags) override;
+  int32_t GetTable(uint32_t table_tag,
+                   int32_t offset,
+                   int32_t max_data_length,
+                   std::string* data) override;
+
+ private:
+  ~PepperTrueTypeFontAndroid() override;
+
+  base::ScopedFD fd_;
+
+  DISALLOW_COPY_AND_ASSIGN(PepperTrueTypeFontAndroid);
+};
+
+PepperTrueTypeFontAndroid::PepperTrueTypeFontAndroid() {
+}
+
+PepperTrueTypeFontAndroid::~PepperTrueTypeFontAndroid() {
+}
+
+int32_t PepperTrueTypeFontAndroid::Initialize(
+    ppapi::proxy::SerializedTrueTypeFontDesc* desc) {
+  return fd_.is_valid() ? PP_OK : PP_ERROR_FAILED;
+}
+
+int32_t PepperTrueTypeFontAndroid::GetTableTags(std::vector<uint32_t>* tags) {
+  return PP_ERROR_FAILED;
+}
+
+int32_t PepperTrueTypeFontAndroid::GetTable(uint32_t table_tag,
+                                          int32_t offset,
+                                          int32_t max_data_length,
+                                          std::string* data) {
+  return PP_ERROR_FAILED;
+}
+
+}  // namespace
+
+// static
+PepperTrueTypeFont* PepperTrueTypeFont::Create() {
+  return new PepperTrueTypeFontAndroid();
+}
+
+}  // namespace content
--- /dev/null
+++ b/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
@@ -0,0 +1,20 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/logging.h"
+#include "content/browser/renderer_host/pepper/pepper_truetype_font_list.h"
+
+namespace content {
+
+void GetFontFamilies_SlowBlocking(std::vector<std::string>* font_families) {
+  NOTIMPLEMENTED();
+}
+
+void GetFontsInFamily_SlowBlocking(
+    const std::string& family,
+    std::vector<ppapi::proxy::SerializedTrueTypeFontDesc>* fonts_in_family) {
+  NOTIMPLEMENTED();
+}
+
+}  // namespace content
--- a/content/browser/renderer_host/render_view_host_impl.cc
+++ b/content/browser/renderer_host/render_view_host_impl.cc
@@ -104,7 +104,7 @@
 #include "ui/gfx/system_fonts_win.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/browser/host_zoom_map_impl.h"
 #endif
 
@@ -700,7 +700,7 @@ void RenderViewHostImpl::ClosePage() {
 
     // TODO(creis): Should this be moved to Shutdown?  It may not be called for
     // RenderViewHosts that have been swapped out.
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     static_cast<HostZoomMapImpl*>(HostZoomMap::Get(GetSiteInstance()))
         ->WillCloseRenderView(GetProcess()->GetID(), GetRoutingID());
 #endif
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -97,7 +97,6 @@
 
 #if defined(OS_ANDROID)
 #include "net/android/http_auth_negotiate_android.h"
-#else
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // defined(OS_ANDROID)
 
@@ -1346,7 +1345,7 @@ void StoragePartitionImpl::Initialize()
   push_messaging_context_ = std::make_unique<PushMessagingContext>(
       browser_context_, service_worker_context_);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   host_zoom_level_context_ = new HostZoomLevelContext(
       browser_context_->CreateZoomLevelDelegate(partition_path_));
 #endif  // !defined(OS_ANDROID)
@@ -1603,7 +1602,7 @@ SharedWorkerServiceImpl* StoragePartitio
   return shared_worker_service_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 HostZoomMap* StoragePartitionImpl::GetHostZoomMap() {
   DCHECK(initialized_);
   DCHECK(host_zoom_level_context_.get());
--- a/content/browser/storage_partition_impl.h
+++ b/content/browser/storage_partition_impl.h
@@ -50,7 +50,7 @@
 #include "storage/browser/quota/special_storage_policy.h"
 #include "third_party/blink/public/mojom/dom_storage/storage_partition_service.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/browser/host_zoom_level_context.h"
 #endif
 
@@ -144,7 +144,7 @@ class CONTENT_EXPORT StoragePartitionImp
   DevToolsBackgroundServicesContextImpl* GetDevToolsBackgroundServicesContext()
       override;
   ContentIndexContextImpl* GetContentIndexContext() override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HostZoomMap* GetHostZoomMap() override;
   HostZoomLevelContext* GetHostZoomLevelContext() override;
   ZoomLevelDelegate* GetZoomLevelDelegate() override;
@@ -445,7 +445,7 @@ class CONTENT_EXPORT StoragePartitionImp
   std::unique_ptr<SharedWorkerServiceImpl> shared_worker_service_;
   std::unique_ptr<PushMessagingContext> push_messaging_context_;
   scoped_refptr<storage::SpecialStoragePolicy> special_storage_policy_;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   scoped_refptr<HostZoomLevelContext> host_zoom_level_context_;
 #endif  // !defined(OS_ANDROID)
   scoped_refptr<PlatformNotificationContextImpl> platform_notification_context_;
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -173,7 +173,7 @@
 #include "content/browser/android/nfc_host.h"
 #include "content/browser/web_contents/web_contents_android.h"
 #include "services/device/public/mojom/nfc.mojom.h"
-#else  // !OS_ANDROID
+
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // OS_ANDROID
 
@@ -585,7 +585,7 @@ WebContentsImpl::WebContentsImpl(Browser
       audio_stream_monitor_(this),
       media_web_contents_observer_(
           std::make_unique<MediaWebContentsObserver>(this)),
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
       page_scale_factor_is_one_(true),
 #endif  // !defined(OS_ANDROID)
       is_overlay_content_(false),
@@ -1181,7 +1181,7 @@ FindRequestManager* WebContentsImpl::Get
   return GetFindRequestManager();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void WebContentsImpl::UpdateZoom() {
   RenderWidgetHostImpl* rwh = GetRenderViewHost()->GetWidget();
   if (rwh->GetView())
@@ -5687,7 +5687,7 @@ WebContents* WebContentsImpl::GetAsWebCo
   return this;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 double WebContentsImpl::GetPendingPageZoomLevel() {
   NavigationEntry* pending_entry = GetController().GetPendingEntry();
   if (!pending_entry)
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -255,7 +255,7 @@ class CONTENT_EXPORT WebContentsImpl : p
   // bitmap.
   void AddAccessibilityMode(ui::AXMode mode);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Sets the zoom level for frames associated with this WebContents.
   void UpdateZoom();
 
@@ -801,7 +801,7 @@ class CONTENT_EXPORT WebContentsImpl : p
   void OnVerticalScrollDirectionChanged(
       viz::VerticalScrollDirection scroll_direction) override;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   double GetPendingPageZoomLevel() override;
 #endif  // !defined(OS_ANDROID)
 
@@ -1885,7 +1885,7 @@ class CONTENT_EXPORT WebContentsImpl : p
 
   std::unique_ptr<RenderWidgetHostInputEventRouter> rwh_input_event_router_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   bool page_scale_factor_is_one_;
 #endif  // !defined(OS_ANDROID)
 
--- a/content/browser/webui/shared_resources_data_source.cc
+++ b/content/browser/webui/shared_resources_data_source.cc
@@ -87,7 +87,7 @@ const std::map<std::string, std::string>
     return aliases;
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   aliases["../../../third_party/polymer/v1_0/components-chromium/polymer2/"] =
       "polymer/v1_0/polymer/";
 #endif  // !defined(OS_ANDROID)
@@ -183,7 +183,7 @@ const std::map<int, std::string> CreateC
 }
 #endif  // !defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool ShouldIgnore(std::string resource) {
 #if defined(OS_CHROMEOS)
   if (UsingMultiplePolymerVersions())
@@ -215,7 +215,7 @@ void AddResourcesToMap(ResourcesMap* res
   for (size_t i = 0; i < kWebuiResourcesSize; ++i) {
     const auto& resource = kWebuiResources[i];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     if (ShouldIgnore(resource.name))
       continue;
 #endif  // !defined(OS_ANDROID)
--- a/content/public/browser/browser_context.h
+++ b/content/public/browser/browser_context.h
@@ -28,7 +28,7 @@
 #include "third_party/blink/public/mojom/blob/blob.mojom-forward.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-forward.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/public/browser/zoom_level_delegate.h"
 #endif
 
@@ -248,7 +248,7 @@ class CONTENT_EXPORT BrowserContext : pu
   // StoragePartition can have time to do necessary cleanups on IO thread.
   void ShutdownStoragePartitions();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Creates a delegate to initialize a HostZoomMap and persist its information.
   // This is called during creation of each StoragePartition.
   virtual std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -850,7 +850,7 @@ void ContentBrowserClient::CreateWebUsbS
     RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<blink::mojom::WebUsbService> receiver) {}
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 SerialDelegate* ContentBrowserClient::GetSerialDelegate() {
   return nullptr;
 }
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1525,7 +1525,7 @@ class CONTENT_EXPORT ContentBrowserClien
       RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::WebUsbService> receiver);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Allows the embedder to provide an implementation of the Serial API.
   virtual SerialDelegate* GetSerialDelegate();
 #endif
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -27,15 +27,13 @@ const DesktopMediaID::Id DesktopMediaID:
 // static
 const DesktopMediaID::Id DesktopMediaID::kFakeId = -3;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || true
 // static
 DesktopMediaID DesktopMediaID::RegisterNativeWindow(DesktopMediaID::Type type,
                                                     gfx::NativeWindow window) {
   DCHECK(type == TYPE_SCREEN || type == TYPE_WINDOW);
   DCHECK(window);
   DesktopMediaID media_id(type, kNullId);
-  media_id.window_id =
-      DesktopMediaWindowRegistry::GetInstance()->RegisterWindow(window);
   return media_id;
 }
 
--- a/content/public/browser/desktop_media_id.h
+++ b/content/public/browser/desktop_media_id.h
@@ -28,7 +28,7 @@ struct CONTENT_EXPORT DesktopMediaID {
   // Represents a fake id to create a dummy capturer for autotests.
   static const Id kFakeId;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || true
   // Assigns integer identifier to the |window| and returns its DesktopMediaID.
   static DesktopMediaID RegisterNativeWindow(Type type,
                                              gfx::NativeWindow window);
--- a/content/public/browser/storage_partition.h
+++ b/content/public/browser/storage_partition.h
@@ -67,7 +67,7 @@ class PlatformNotificationContext;
 class ServiceWorkerContext;
 class SharedWorkerService;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class HostZoomLevelContext;
 class HostZoomMap;
 class ZoomLevelDelegate;
@@ -138,7 +138,7 @@ class CONTENT_EXPORT StoragePartition {
   virtual DevToolsBackgroundServicesContext*
   GetDevToolsBackgroundServicesContext() = 0;
   virtual ContentIndexContext* GetContentIndexContext() = 0;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   virtual HostZoomMap* GetHostZoomMap() = 0;
   virtual HostZoomLevelContext* GetHostZoomLevelContext() = 0;
   virtual ZoomLevelDelegate* GetZoomLevelDelegate() = 0;
--- a/content/public/common/pepper_plugin_info.h
+++ b/content/public/common/pepper_plugin_info.h
@@ -17,9 +17,11 @@
 #include "ppapi/c/pp_module.h"
 #include "ppapi/c/ppb.h"
 
+#if 0
 #if !BUILDFLAG(ENABLE_PLUGINS)
 #error "Plugins should be enabled"
 #endif
+#endif
 
 namespace content {
 
--- a/content/shell/BUILD.gn
+++ b/content/shell/BUILD.gn
@@ -560,7 +560,7 @@ repack("pak") {
     sources +=
         [ "$root_gen_dir/ui/views/resources/views_resources_100_percent.pak" ]
   }
-  if (!is_android) {
+  if (true || !is_android) {
     sources +=
         [ "$root_gen_dir/content/browser/devtools/devtools_resources.pak" ]
     deps += [ "//content/browser/devtools:resources" ]
--- a/content/shell/browser/shell_browser_context.cc
+++ b/content/shell/browser/shell_browser_context.cc
@@ -139,7 +139,7 @@ void ShellBrowserContext::FinishInitWhil
   SimpleKeyMap::GetInstance()->Associate(this, key_.get());
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<ZoomLevelDelegate> ShellBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath&) {
   return std::unique_ptr<ZoomLevelDelegate>();
--- a/content/shell/browser/shell_browser_context.h
+++ b/content/shell/browser/shell_browser_context.h
@@ -25,7 +25,7 @@ class ClientHintsControllerDelegate;
 class DownloadManagerDelegate;
 class PermissionControllerDelegate;
 class ShellDownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class ZoomLevelDelegate;
 #endif  // !defined(OS_ANDROID)
 
@@ -44,7 +44,7 @@ class ShellBrowserContext : public Brows
 
   // BrowserContext implementation.
   base::FilePath GetPath() override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
--- a/extensions/BUILD.gn
+++ b/extensions/BUILD.gn
@@ -206,40 +206,6 @@ repack("shell_and_test_pak") {
   ]
 }
 
-test("extensions_unittests") {
-  sources = [
-    "test/extensions_unittests_main.cc",
-    "test/logging_timer_unittest.cc",
-  ]
-
-  data = [
-    "test/data/",
-    "//chrome/test/data/extensions/",
-    "//components/test/data/cast_certificate/",
-    "$root_out_dir/content_shell.pak",
-    "$root_out_dir/extensions_shell_and_test.pak",
-  ]
-
-  deps = [
-    ":extensions_resources",
-    ":shell_and_test_pak",
-    ":test_support",
-    "//base/test:test_support",
-    "//content/public/common",
-    "//content/test:test_support",
-    "//extensions/browser:unit_tests",
-    "//extensions/common",
-    "//extensions/common:unit_tests",
-    "//extensions/renderer:unit_tests",
-    "//extensions/shell:unit_tests",
-    "//services/data_decoder:lib",
-    "//services/service_manager/public/cpp/test:test_support",
-    "//ui/gl:test_support",
-  ]
-
-  data_deps = [ "//third_party/mesa_headers" ]
-}
-
 test("extensions_browsertests") {
   data = [
     "//extensions/test/data/",
--- a/extensions/browser/api/api_resource_manager.h
+++ b/extensions/browser/api/api_resource_manager.h
@@ -106,8 +106,11 @@ class ApiResourceManager : public Browse
  public:
   explicit ApiResourceManager(content::BrowserContext* context)
       : data_(base::MakeRefCounted<ApiResourceData>()) {
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 1";
     extension_registry_observer_.Add(ExtensionRegistry::Get(context));
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 2";
     process_manager_observer_.Add(ProcessManager::Get(context));
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 3";
   }
 
   virtual ~ApiResourceManager() {
@@ -387,10 +390,15 @@ template <class T>
 struct BrowserContextFactoryDependencies<ApiResourceManager<T>> {
   static void DeclareFactoryDependencies(
       BrowserContextKeyedAPIFactory<ApiResourceManager<T>>* factory) {
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Prestep A";
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step A";
     factory->DependsOn(
         ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step B";
     factory->DependsOn(ExtensionRegistryFactory::GetInstance());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step C";
     factory->DependsOn(ProcessManagerFactory::GetInstance());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step D";
   }
 };
 
--- a/extensions/browser/api/messaging/message_service.cc
+++ b/extensions/browser/api/messaging/message_service.cc
@@ -441,7 +441,7 @@ void MessageService::OpenChannelToNative
   channel->opener->IncrementLazyKeepaliveCount();
 
   AddChannel(std::move(channel), receiver_port_id);
-#else  // !(defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX))
+#elif 0  // !(defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX))
   const char kNativeMessagingNotSupportedError[] =
       "Native Messaging is not supported on this platform.";
   opener_port->DispatchOnDisconnect(kNativeMessagingNotSupportedError);
--- a/extensions/browser/api/socket/tcp_socket.cc
+++ b/extensions/browser/api/socket/tcp_socket.cc
@@ -30,35 +30,8 @@ namespace extensions {
 
 namespace {
 
-// Returns true if successfully parsed the SSL protocol version that is
-// represented by a string. Returns false if |version_str| is invalid.
-bool SSLProtocolVersionFromString(const std::string& version_str,
-                                  network::mojom::SSLVersion* version_out) {
-  if (version_str == "tls1") {
-    *version_out = network::mojom::SSLVersion::kTLS1;
-    return true;
-  }
-  if (version_str == "tls1.1") {
-    *version_out = network::mojom::SSLVersion::kTLS11;
-    return true;
-  }
-  if (version_str == "tls1.2") {
-    *version_out = network::mojom::SSLVersion::kTLS12;
-    return true;
-  }
-  if (version_str == "tls1.3") {
-    *version_out = network::mojom::SSLVersion::kTLS13;
-    return true;
-  }
-  return false;
-}
-
 }  // namespace
 
-const char kTCPSocketTypeInvalidError[] =
-    "Cannot call both connect and listen on the same socket.";
-const char kSocketListenError[] = "Could not listen on the specified port.";
-
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
     ApiResourceManager<ResumableTCPSocket>>>::DestructorAtExit g_factory =
     LAZY_INSTANCE_INITIALIZER;
@@ -85,7 +58,6 @@ TCPSocket::TCPSocket(content::BrowserCon
                      const std::string& owner_extension_id)
     : Socket(owner_extension_id),
       browser_context_(browser_context),
-      socket_mode_(UNKNOWN),
       mojo_data_pump_(nullptr),
       task_runner_(base::SequencedTaskRunnerHandle::Get()) {}
 
@@ -97,7 +69,6 @@ TCPSocket::TCPSocket(
     const std::string& owner_extension_id)
     : Socket(owner_extension_id),
       browser_context_(nullptr),
-      socket_mode_(CLIENT),
       client_socket_(std::move(socket)),
       mojo_data_pump_(std::make_unique<MojoDataPump>(std::move(receive_stream),
                                                      std::move(send_stream))),
@@ -113,7 +84,7 @@ TCPSocket::~TCPSocket() {
 void TCPSocket::Connect(const net::AddressList& address,
                         net::CompletionOnceCallback callback) {
   DCHECK(callback);
-
+#if 0
   if (socket_mode_ == SERVER || connect_callback_) {
     std::move(callback).Run(net::ERR_CONNECTION_FAILED);
     return;
@@ -144,6 +115,7 @@ void TCPSocket::Connect(const net::Addre
                                 storage_partition_, browser_context_, address,
                                 client_socket_.BindNewPipeAndPassReceiver(),
                                 std::move(completion_callback_ui)));
+#endif
 }
 
 void TCPSocket::Disconnect(bool socket_destroying) {
@@ -174,28 +146,6 @@ void TCPSocket::Bind(const std::string&
 
 void TCPSocket::Read(int count, ReadCompletionCallback callback) {
   DCHECK(callback);
-
-  const bool socket_destroying = false;
-  if (socket_mode_ != CLIENT) {
-    std::move(callback).Run(net::ERR_FAILED, nullptr, socket_destroying);
-    return;
-  }
-
-  if (!mojo_data_pump_) {
-    std::move(callback).Run(net::ERR_SOCKET_NOT_CONNECTED, nullptr,
-                            socket_destroying);
-    return;
-  }
-  if (mojo_data_pump_->HasPendingRead() || connect_callback_) {
-    // It's illegal to read a net::TCPSocket while a pending Connect or Read is
-    // already in progress.
-    std::move(callback).Run(net::ERR_IO_PENDING, nullptr, socket_destroying);
-    return;
-  }
-
-  read_callback_ = std::move(callback);
-  mojo_data_pump_->Read(count, base::BindOnce(&TCPSocket::OnReadComplete,
-                                              base::Unretained(this)));
 }
 
 void TCPSocket::RecvFrom(int count, RecvFromCompletionCallback callback) {
@@ -213,25 +163,16 @@ void TCPSocket::SendTo(scoped_refptr<net
 void TCPSocket::SetKeepAlive(bool enable,
                              int delay,
                              SetKeepAliveCallback callback) {
-  if (!client_socket_) {
-    std::move(callback).Run(net::ERR_FAILED);
-    return;
-  }
-  client_socket_->SetKeepAlive(enable, delay, std::move(callback));
 }
 
 void TCPSocket::SetNoDelay(bool no_delay, SetNoDelayCallback callback) {
-  if (!client_socket_) {
-    std::move(callback).Run(net::ERR_FAILED);
-    return;
-  }
-  client_socket_->SetNoDelay(no_delay, std::move(callback));
 }
 
 void TCPSocket::Listen(const std::string& address,
                        uint16_t port,
                        int backlog,
                        ListenCallback callback) {
+#if 0
   DCHECK(!server_socket_);
   DCHECK(!client_socket_);
   DCHECK(!listen_callback_);
@@ -269,9 +210,11 @@ void TCPSocket::Listen(const std::string
                      browser_context_, ip_end_point, backlog,
                      server_socket_.BindNewPipeAndPassReceiver(),
                      std::move(completion_callback_ui)));
+#endif
 }
 
 void TCPSocket::Accept(AcceptCompletionCallback callback) {
+#if 0
   if (socket_mode_ != SERVER || !server_socket_) {
     std::move(callback).Run(net::ERR_FAILED, mojo::NullRemote(), base::nullopt,
                             mojo::ScopedDataPipeConsumerHandle(),
@@ -291,6 +234,7 @@ void TCPSocket::Accept(AcceptCompletionC
   server_socket_->Accept(
       mojo::NullRemote() /* observer */,
       base::BindOnce(&TCPSocket::OnAccept, base::Unretained(this)));
+#endif
 }
 
 bool TCPSocket::IsConnected() {
@@ -357,12 +301,6 @@ void TCPSocket::OnConnectCompleteOnUIThr
     const base::Optional<net::IPEndPoint>& peer_addr,
     mojo::ScopedDataPipeConsumerHandle receive_stream,
     mojo::ScopedDataPipeProducerHandle send_stream) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  original_task_runner->PostTask(
-      FROM_HERE,
-      base::BindOnce(std::move(callback), result, local_addr, peer_addr,
-                     std::move(receive_stream), std::move(send_stream)));
 }
 
 void TCPSocket::OnConnectComplete(
@@ -371,18 +309,6 @@ void TCPSocket::OnConnectComplete(
     const base::Optional<net::IPEndPoint>& peer_addr,
     mojo::ScopedDataPipeConsumerHandle receive_stream,
     mojo::ScopedDataPipeProducerHandle send_stream) {
-  DCHECK(!is_connected_);
-  DCHECK(connect_callback_);
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
-
-  if (result == net::OK) {
-    is_connected_ = true;
-    local_addr_ = local_addr;
-    peer_addr_ = peer_addr;
-    mojo_data_pump_ = std::make_unique<MojoDataPump>(std::move(receive_stream),
-                                                     std::move(send_stream));
-  }
-  std::move(connect_callback_).Run(result);
 }
 
 // static
@@ -393,6 +319,7 @@ void TCPSocket::ListenOnUIThread(
     int backlog,
     mojo::PendingReceiver<network::mojom::TCPServerSocket> receiver,
     network::mojom::NetworkContext::CreateTCPServerSocketCallback callback) {
+#if 0
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (!storage_partition) {
@@ -404,6 +331,7 @@ void TCPSocket::ListenOnUIThread(
       net::MutableNetworkTrafficAnnotationTag(
           Socket::GetNetworkTrafficAnnotationTag()),
       std::move(receiver), std::move(callback));
+#endif
 }
 
 // static
@@ -412,25 +340,11 @@ void TCPSocket::OnListenCompleteOnUIThre
     network::mojom::NetworkContext::CreateTCPServerSocketCallback callback,
     int result,
     const base::Optional<net::IPEndPoint>& local_addr) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  original_task_runner->PostTask(
-      FROM_HERE, base::BindOnce(std::move(callback), result, local_addr));
 }
 
 void TCPSocket::OnListenComplete(
     int result,
     const base::Optional<net::IPEndPoint>& local_addr) {
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
-  DCHECK(listen_callback_);
-
-  if (result != net::OK) {
-    server_socket_.reset();
-    std::move(listen_callback_).Run(result, kSocketListenError);
-    return;
-  }
-  local_addr_ = local_addr;
-  std::move(listen_callback_).Run(result, "");
 }
 
 content::StoragePartition* TCPSocket::GetStoragePartitionHelper() {
@@ -495,6 +409,7 @@ void TCPSocket::OnUpgradeToTLSComplete(
 
 void TCPSocket::UpgradeToTLS(api::socket::SecureOptions* options,
                              UpgradeToTLSCallback callback) {
+#if 0
   if (!client_socket_ || !mojo_data_pump_ ||
       mojo_data_pump_->HasPendingRead() || mojo_data_pump_->HasPendingWrite()) {
     std::move(callback).Run(net::ERR_FAILED, mojo::NullRemote(),
@@ -562,6 +477,7 @@ void TCPSocket::UpgradeToTLS(api::socket
       base::BindOnce(&TCPSocket::OnUpgradeToTLSComplete, base::Unretained(this),
                      std::move(callback), std::move(tls_socket),
                      local_addr_.value(), peer_addr_.value()));
+#endif
 }
 
 ResumableTCPSocket::ResumableTCPSocket(content::BrowserContext* browser_context,
--- a/extensions/browser/api/socket/tcp_socket.h
+++ b/extensions/browser/api/socket/tcp_socket.h
@@ -170,8 +170,6 @@ class TCPSocket : public Socket {
   // ApiResourceManager which is a BrowserContextKeyedAPI.
   content::BrowserContext* browser_context_;
 
-  SocketMode socket_mode_;
-
   // CLIENT mode.
   mojo::Remote<network::mojom::TCPConnectedSocket> client_socket_;
   // SERVER mode.
--- a/extensions/browser/api/system_cpu/BUILD.gn
+++ b/extensions/browser/api/system_cpu/BUILD.gn
@@ -11,6 +11,7 @@ source_set("system_cpu") {
   sources = [
     "cpu_info_provider.cc",
     "cpu_info_provider.h",
+    "cpu_info_provider_android.cc",
     "cpu_info_provider_linux.cc",
     "cpu_info_provider_mac.cc",
     "cpu_info_provider_win.cc",
--- /dev/null
+++ b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
@@ -0,0 +1,77 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/api/system_cpu/cpu_info_provider.h"
+
+#include <stdint.h>
+
+#include <cstdio>
+#include <sstream>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+
+namespace extensions {
+
+namespace {
+
+const char kProcStat[] = "/proc/stat";
+
+}  // namespace
+
+bool CpuInfoProvider::QueryCpuTimePerProcessor(
+    std::vector<api::system_cpu::ProcessorInfo>* infos) {
+  DCHECK(infos);
+
+  // WARNING: this method may return incomplete data because some processors may
+  // be brought offline at runtime. /proc/stat does not report statistics of
+  // offline processors. CPU usages of offline processors will be filled with
+  // zeros.
+  //
+  // An example of output of /proc/stat when processor 0 and 3 are online, but
+  // processor 1 and 2 are offline:
+  //
+  //   cpu  145292 20018 83444 1485410 995 44 3578 0 0 0
+  //   cpu0 138060 19947 78350 1479514 570 44 3576 0 0 0
+  //   cpu3 2033 32 1075 1400 52 0 1 0 0 0
+  std::string contents;
+  if (!base::ReadFileToString(base::FilePath(kProcStat), &contents))
+    return false;
+
+  std::istringstream iss(contents);
+  std::string line;
+
+  // Skip the first line because it is just an aggregated number of
+  // all cpuN lines.
+  std::getline(iss, line);
+  while (std::getline(iss, line)) {
+    if (line.compare(0, 3, "cpu") != 0)
+      continue;
+
+    uint64_t user = 0, nice = 0, sys = 0, idle = 0;
+    uint32_t pindex = 0;
+    int vals =
+        sscanf(line.c_str(),
+               "cpu%" PRIu32 " %" PRIu64 " %" PRIu64 " %" PRIu64 " %" PRIu64,
+               &pindex,
+               &user,
+               &nice,
+               &sys,
+               &idle);
+    if (vals != 5 || pindex >= infos->size()) {
+      NOTREACHED();
+      return false;
+    }
+
+    infos->at(pindex).usage.kernel = static_cast<double>(sys);
+    infos->at(pindex).usage.user = static_cast<double>(user + nice);
+    infos->at(pindex).usage.idle = static_cast<double>(idle);
+    infos->at(pindex).usage.total =
+        static_cast<double>(sys + user + nice + idle);
+  }
+
+  return true;
+}
+
+}  // namespace extensions
--- a/extensions/browser/extensions_browser_client.cc
+++ b/extensions/browser/extensions_browser_client.cc
@@ -21,6 +21,7 @@ ExtensionsBrowserClient::ExtensionsBrows
 ExtensionsBrowserClient::~ExtensionsBrowserClient() = default;
 
 ExtensionsBrowserClient* ExtensionsBrowserClient::Get() {
+  LOG(ERROR) << "[Kiwi] ExtensionsBrowserClient::Get - Step: " << g_extension_browser_client;
   return g_extension_browser_client;
 }
 
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -145,6 +145,7 @@ static std::string TerminationStatusToSt
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM:
       return "oom killed";
 #endif
+    case base::TERMINATION_STATUS_OOM_PROTECTED:
     case base::TERMINATION_STATUS_OOM:
       return "oom";
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
--- a/extensions/buildflags/buildflags.gni
+++ b/extensions/buildflags/buildflags.gni
@@ -5,7 +5,7 @@
 import("//build/config/features.gni")
 
 declare_args() {
-  enable_extensions = !is_android && !is_ios && !is_fuchsia
+  enable_extensions = !is_ios && !is_fuchsia
 
   # Enables Wi-Fi Display functionality
   # WARNING: This enables MPEG Transport Stream (MPEG-TS) encoding!
--- a/mojo/public/js/mojo_bindings_resources.grd
+++ b/mojo/public/js/mojo_bindings_resources.grd
@@ -14,7 +14,7 @@
   <release seq="1">
     <includes>
       <!-- All resources included on Android should use the lite bindings. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MOJO_MOJO_BINDINGS_JS"
             file="${root_gen_dir}/mojo/public/js/mojo_bindings.js"
             use_base_dir="false"
--- a/services/device/public/cpp/hid/BUILD.gn
+++ b/services/device/public/cpp/hid/BUILD.gn
@@ -7,7 +7,7 @@ import("//build/config/features.gni")
 source_set("hid") {
   # HID is not implemented on Android and we want to be particularly careful
   # about not bloating binary size by accidentially including it.
-  assert(!is_android)
+#  assert(!is_android)
 
   sources = [
     "fake_input_service_linux.cc",
--- a/services/service_manager/embedder/main.cc
+++ b/services/service_manager/embedder/main.cc
@@ -251,6 +251,8 @@ int Main(const MainParams& params) {
   MainDelegate* delegate = params.delegate;
   DCHECK(delegate);
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 1";
+
   int exit_code = -1;
   base::debug::GlobalActivityTracker* tracker = nullptr;
   ProcessType process_type = delegate->OverrideProcessType();
@@ -258,6 +260,7 @@ int Main(const MainParams& params) {
   std::unique_ptr<base::mac::ScopedNSAutoreleasePool> autorelease_pool;
 #endif
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 2";
   // A flag to indicate whether Main() has been called before. On Android, we
   // may re-run Main() without restarting the browser process. This flag
   // prevents initializing things more than once.
@@ -265,12 +268,15 @@ int Main(const MainParams& params) {
 #if !defined(OS_ANDROID)
   DCHECK(!is_initialized);
 #endif
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3";
   if (!is_initialized) {
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3a";
     is_initialized = true;
 #if defined(OS_MACOSX) && BUILDFLAG(USE_ALLOCATOR_SHIM)
     base::allocator::InitializeAllocatorShim();
 #endif
     base::EnableTerminationOnOutOfMemory();
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3b";
 
 #if defined(OS_LINUX)
     // The various desktop environments set this environment variable that
@@ -286,6 +292,7 @@ int Main(const MainParams& params) {
     setenv("DBUS_SESSION_BUS_ADDRESS", "disabled:", kNoOverrideIfAlreadySet);
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3c";
 #if defined(OS_WIN)
     base::win::RegisterInvalidParamHandler();
     ui::win::CreateATLModuleIfNeeded();
@@ -301,17 +308,20 @@ int Main(const MainParams& params) {
     argc = params.argc;
     argv = params.argv;
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3d";
 
     base::CommandLine::Init(argc, argv);
 
 #if defined(OS_POSIX)
     PopulateFDsFromCommandLine();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3e";
 
     base::EnableTerminationOnHeapCorruption();
 
     SetProcessTitleFromCommandLine(argv);
 #endif  // !defined(OS_ANDROID)
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3f";
 
 // On Android setlocale() is not supported, and we don't override the signal
 // handlers so we can get a stack trace when crashing.
@@ -332,6 +342,7 @@ int Main(const MainParams& params) {
 
     SetupSignalHandlers();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3g";
 
     const auto& command_line = *base::CommandLine::ForCurrentProcess();
 
@@ -339,6 +350,7 @@ int Main(const MainParams& params) {
     base::win::SetupCRT(command_line);
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3h";
     MainDelegate::InitializeParams init_params;
 
 #if defined(OS_MACOSX)
@@ -350,6 +362,7 @@ int Main(const MainParams& params) {
     init_params.autorelease_pool = autorelease_pool.get();
     InitializeMac();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3i";
 
     mojo::core::Configuration mojo_config;
     if (process_type == ProcessType::kDefault &&
@@ -357,16 +370,21 @@ int Main(const MainParams& params) {
             switches::kProcessTypeServiceManager) {
       mojo_config.is_broker_process = true;
     }
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3j";
     mojo_config.max_message_num_bytes = kMaximumMojoMessageSize;
     delegate->OverrideMojoConfiguration(&mojo_config);
     mojo::core::Init(mojo_config);
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3k";
     ui::RegisterPathProvider();
 
     tracker = base::debug::GlobalActivityTracker::Get();
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3l";
     exit_code = delegate->Initialize(init_params);
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3m";
     if (exit_code >= 0) {
       if (tracker) {
+        LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3n";
         tracker->SetProcessPhase(
             base::debug::GlobalActivityTracker::PROCESS_LAUNCH_FAILED);
         tracker->process_data().SetInt("exit-code", exit_code);
@@ -374,6 +392,7 @@ int Main(const MainParams& params) {
       return exit_code;
     }
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3o";
 #if defined(OS_WIN)
     // Route stdio to parent console (if any) or create one.
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
@@ -382,6 +401,7 @@ int Main(const MainParams& params) {
     }
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3p";
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
             ::switches::kTraceToConsole)) {
       base::trace_event::TraceConfig trace_config =
@@ -391,6 +411,7 @@ int Main(const MainParams& params) {
     }
   }
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 4";
   const auto& command_line = *base::CommandLine::ForCurrentProcess();
   if (process_type == ProcessType::kDefault) {
     std::string type_switch =
@@ -403,21 +424,26 @@ int Main(const MainParams& params) {
       process_type = ProcessType::kEmbedder;
     }
   }
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5";
   switch (process_type) {
     case ProcessType::kDefault:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5a";
       NOTREACHED();
       break;
 
     case ProcessType::kServiceManager:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5b";
       exit_code = RunServiceManager(delegate);
       break;
 
     case ProcessType::kService:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5c";
       CommonSubprocessInit();
       exit_code = RunService(delegate);
       break;
 
     case ProcessType::kEmbedder:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5d";
       if (delegate->IsEmbedderSubprocess())
         CommonSubprocessInit();
       exit_code = delegate->RunEmbedderProcess();
@@ -425,6 +451,7 @@ int Main(const MainParams& params) {
   }
 
   if (tracker) {
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5e";
     if (exit_code == 0) {
       tracker->SetProcessPhaseIfEnabled(
           base::debug::GlobalActivityTracker::PROCESS_EXITED_CLEANLY);
--- a/services/tracing/public/cpp/trace_startup.cc
+++ b/services/tracing/public/cpp/trace_startup.cc
@@ -103,8 +103,11 @@ void InitTracingPostThreadPoolStartAndFe
   // TODO(nuskos): We should switch these to DCHECK once we're reasonably
   // confident we've ensured this is called properly in all processes. Probably
   // after M78 release has been cut (since we'll verify in the rollout of M78).
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 3: " << base::ThreadPoolInstance::Get();
   CHECK(base::ThreadPoolInstance::Get());
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 4: " << base::FeatureList::GetInstance();
   CHECK(base::FeatureList::GetInstance());
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 5";
   // Below are the things tracing must do once per process.
   TraceEventDataSource::GetInstance()->OnTaskSchedulerAvailable();
   if (ShouldSetupSystemTracing()) {
@@ -114,6 +117,7 @@ void InitTracingPostThreadPoolStartAndFe
     // state. This Get() call ensures that the constructor has run.
     PerfettoTracedProcess::Get();
   }
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 6";
 }
 
 void PropagateTracingFlagsToChildProcessCmdLine(base::CommandLine* cmd_line) {
--- a/third_party/blink/public/mojom/BUILD.gn
+++ b/third_party/blink/public/mojom/BUILD.gn
@@ -162,7 +162,7 @@ mojom("mojom_platform") {
     "worker/worker_options.mojom",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [ "serial/serial.mojom" ]
   }
 
--- a/ui/android/window_android.h
+++ b/ui/android/window_android.h
@@ -50,6 +50,14 @@ class UI_ANDROID_EXPORT WindowAndroid :
 
   base::android::ScopedJavaLocalRef<jobject> GetJavaObject();
 
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::PointF* point);
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::Point* point);
+
+
   // Compositor callback relay.
   void OnCompositingDidCommit();
 
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -453,6 +453,11 @@ jumbo_component("base") {
     deps += [ "//third_party/re2" ]
   }
 
+  sources += [
+    "dragdrop/os_exchange_data_provider_android.cc",
+    "dragdrop/os_exchange_data_provider_android.h",
+  ]
+
   if (!is_ios) {
     # iOS does not use Chromium-specific code for event handling.
     public_deps += [
@@ -613,7 +618,7 @@ jumbo_component("base") {
     ]
   }
 
-  if (!toolkit_views && !use_aura) {
+  if (false && !toolkit_views && !use_aura) {
     sources -= [
       "dragdrop/drag_drop_types.h",
       "dragdrop/drop_target_event.cc",
@@ -630,16 +635,6 @@ jumbo_component("base") {
   if (is_android) {
     deps += [ ":ui_base_jni_headers" ]
     libs += [ "jnigraphics" ]
-
-    sources -= [
-      "cursor/cursor_android.cc",
-      "default_theme_provider.cc",
-      "l10n/l10n_font_util.cc",
-      "models/button_menu_item_model.cc",
-      "pointer/touch_editing_controller.cc",
-      "theme_provider.cc",
-      "ui_base_types.cc",
-    ]
   }
 
   if (use_aura) {
--- a/ui/base/cursor/cursor.cc
+++ b/ui/base/cursor/cursor.cc
@@ -36,7 +36,7 @@ void Cursor::SetPlatformCursor(const Pla
     RefCustomCursor();
 }
 
-#if !defined(USE_AURA)
+#if false && !defined(USE_AURA)
 void Cursor::RefCustomCursor() {
   NOTIMPLEMENTED();
 }
--- a/ui/base/dragdrop/os_exchange_data.cc
+++ b/ui/base/dragdrop/os_exchange_data.cc
@@ -114,7 +114,7 @@ bool OSExchangeData::HasAnyFormat(
   if ((formats & FILE_CONTENTS) != 0 && provider_->HasFileContents())
     return true;
 #endif
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
   if ((formats & HTML) != 0 && provider_->HasHtml())
     return true;
 #endif
@@ -159,7 +159,7 @@ void OSExchangeData::SetDownloadFileInfo
 }
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
 bool OSExchangeData::HasHtml() const {
   return provider_->HasHtml();
 }
--- a/ui/base/dragdrop/os_exchange_data.h
+++ b/ui/base/dragdrop/os_exchange_data.h
@@ -63,7 +63,7 @@ class UI_BASE_EXPORT OSExchangeData {
 #if defined(OS_WIN)
     FILE_CONTENTS  = 1 << 4,
 #endif
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
     HTML           = 1 << 5,
 #endif
   };
@@ -138,13 +138,13 @@ class UI_BASE_EXPORT OSExchangeData {
     virtual void SetDownloadFileInfo(DownloadFileInfo* download) = 0;
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
     virtual void SetHtml(const base::string16& html, const GURL& base_url) = 0;
     virtual bool GetHtml(base::string16* html, GURL* base_url) const = 0;
     virtual bool HasHtml() const = 0;
 #endif
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if true || defined(USE_AURA) || defined(OS_MACOSX)
     virtual void SetDragImage(const gfx::ImageSkia& image,
                               const gfx::Vector2d& cursor_offset) = 0;
     virtual gfx::ImageSkia GetDragImage() const = 0;
@@ -269,7 +269,7 @@ class UI_BASE_EXPORT OSExchangeData {
   void SetDownloadFileInfo(DownloadFileInfo* download);
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
   // Adds a snippet of HTML.  |html| is just raw html but this sets both
   // text/html and CF_HTML.
   void SetHtml(const base::string16& html, const GURL& base_url);
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/dragdrop/file_info.h"
+
+namespace ui {
+
+OSExchangeDataProviderAndroid::OSExchangeDataProviderAndroid()
+    : formats_(0) {
+}
+
+OSExchangeDataProviderAndroid::~OSExchangeDataProviderAndroid() = default;
+
+std::unique_ptr<OSExchangeData::Provider>
+OSExchangeDataProviderAndroid::Clone() const {
+  OSExchangeDataProviderAndroid* ret = new OSExchangeDataProviderAndroid();
+  ret->formats_ = formats_;
+  ret->string_ = string_;
+  ret->url_ = url_;
+  ret->title_ = title_;
+  ret->filenames_ = filenames_;
+  ret->pickle_data_ = pickle_data_;
+  // We skip copying the drag images.
+  ret->html_ = html_;
+  ret->base_url_ = base_url_;
+
+  return base::WrapUnique<OSExchangeData::Provider>(ret);
+}
+
+void OSExchangeDataProviderAndroid::MarkOriginatedFromRenderer() {
+  // TODO(dcheng): Currently unneeded because ChromeOS Android correctly separates
+  // URL and filename metadata, and does not implement the DownloadURL protocol.
+}
+
+bool OSExchangeDataProviderAndroid::DidOriginateFromRenderer() const {
+  return false;
+}
+
+void OSExchangeDataProviderAndroid::SetString(const base::string16& data) {
+  if (HasString())
+    return;
+
+  string_ = data;
+  formats_ |= OSExchangeData::STRING;
+}
+
+void OSExchangeDataProviderAndroid::SetURL(const GURL& url,
+                                        const base::string16& title) {
+  url_ = url;
+  title_ = title;
+  formats_ |= OSExchangeData::URL;
+
+  SetString(base::UTF8ToUTF16(url.spec()));
+}
+
+void OSExchangeDataProviderAndroid::SetFilename(const base::FilePath& path) {
+  filenames_.clear();
+  filenames_.push_back(FileInfo(path, base::FilePath()));
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  filenames_ = filenames;
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetPickledData(
+    const ClipboardFormatType& format,
+    const base::Pickle& data) {
+  pickle_data_[format] = data;
+  formats_ |= OSExchangeData::PICKLED_DATA;
+}
+
+bool OSExchangeDataProviderAndroid::GetString(base::string16* data) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+  *data = string_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  if ((formats_ & OSExchangeData::URL) == 0) {
+    title->clear();
+    return GetPlainTextURL(url) ||
+           (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(url));
+  }
+
+  if (!url_.is_valid())
+    return false;
+
+  *url = url_;
+  *title = title_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilename(base::FilePath* path) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  DCHECK(!filenames_.empty());
+  *path = filenames_[0].path;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  *filenames = filenames_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPickledData(
+    const ClipboardFormatType& format,
+    base::Pickle* data) const {
+  PickleData::const_iterator i = pickle_data_.find(format);
+  if (i == pickle_data_.end())
+    return false;
+
+  *data = i->second;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasString() const {
+  return (formats_ & OSExchangeData::STRING) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  if ((formats_ & OSExchangeData::URL) != 0) {
+    return true;
+  }
+  // No URL, see if we have plain text that can be parsed as a URL.
+  return GetPlainTextURL(NULL) ||
+         (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(nullptr));
+}
+
+bool OSExchangeDataProviderAndroid::HasFile() const {
+  return (formats_ & OSExchangeData::FILE_NAME) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasCustomFormat(
+    const ClipboardFormatType& format) const {
+  return pickle_data_.find(format) != pickle_data_.end();
+}
+
+void OSExchangeDataProviderAndroid::SetHtml(const base::string16& html,
+                                         const GURL& base_url) {
+  formats_ |= OSExchangeData::HTML;
+  html_ = html;
+  base_url_ = base_url;
+}
+
+bool OSExchangeDataProviderAndroid::GetHtml(base::string16* html,
+                                         GURL* base_url) const {
+  if ((formats_ & OSExchangeData::HTML) == 0)
+    return false;
+  *html = html_;
+  *base_url = base_url_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasHtml() const {
+  return ((formats_ & OSExchangeData::HTML) != 0);
+}
+
+void OSExchangeDataProviderAndroid::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAndroid::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAndroid::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAndroid::GetFileURL(GURL* url) const {
+  base::FilePath file_path;
+  if (!GetFilename(&file_path))
+    return false;
+
+  GURL test_url = net::FilePathToFileURL(file_path);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPlainTextURL(GURL* url) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+
+  GURL test_url(string_);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.h
@@ -0,0 +1,101 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+struct ClipboardFormatType;
+
+// OSExchangeData::Provider implementation for Android on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAndroid
+    : public OSExchangeData::Provider {
+ public:
+  OSExchangeDataProviderAndroid();
+  ~OSExchangeDataProviderAndroid() override;
+
+  // Overridden from OSExchangeData::Provider:
+  std::unique_ptr<Provider> Clone() const override;
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const ClipboardFormatType& format,
+                      const base::Pickle& data) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const ClipboardFormatType& format,
+                      base::Pickle* data) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ private:
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a file format and the file name can be
+  // parsed as a URL.
+  bool GetFileURL(GURL* url) const;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Actual formats that have been set. See comment above |known_formats_|
+  // for details.
+  int formats_;
+
+  // String contents.
+  base::string16 string_;
+
+  // URL contents.
+  GURL url_;
+  base::string16 title_;
+
+  // File name.
+  std::vector<FileInfo> filenames_;
+
+  // PICKLED_DATA contents.
+  PickleData pickle_data_;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // For HTML format
+  base::string16 html_;
+  GURL base_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAndroid);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -16,6 +16,8 @@
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #endif
 
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
 namespace ui {
 
 //static
@@ -34,7 +36,7 @@ OSExchangeDataProviderFactory::CreatePro
   NOTIMPLEMENTED();
   return nullptr;
 #else
-#error "Unknown operating system"
+  return std::make_unique<OSExchangeDataProviderAndroid>();
 #endif
 }
 
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -29,6 +29,7 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/point_conversions.h"
 #include "ui/latency/latency_info.h"
+#include "ui/android/window_android.h"
 
 namespace gfx {
 class Transform;
--- a/ui/gfx/BUILD.gn
+++ b/ui/gfx/BUILD.gn
@@ -401,13 +401,6 @@ jumbo_component("gfx") {
     ]
   }
 
-  if ((!use_aura && !toolkit_views) || is_ios) {
-    sources -= [
-      "nine_image_painter.cc",
-      "nine_image_painter.h",
-    ]
-  }
-
   if (use_x11) {
     deps += [ "//ui/gfx/x" ]
     configs += [ "//build/config/linux:x11" ]
--- a/ui/message_center/BUILD.gn
+++ b/ui/message_center/BUILD.gn
@@ -36,7 +36,7 @@ jumbo_component("message_center") {
 
   defines = [ "MESSAGE_CENTER_IMPLEMENTATION" ]
 
-  if (enable_message_center) {
+  if (true || enable_message_center) {
     deps += [
       ":message_center_vector_icons",
       "//base:i18n",
@@ -88,7 +88,7 @@ jumbo_component("message_center") {
       ]
     }
 
-    if (toolkit_views) {
+    if (true || toolkit_views) {
       sources += [
         "views/desktop_message_popup_collection.cc",
         "views/desktop_message_popup_collection.h",
--- a/ui/native_theme/native_theme_android.cc
+++ b/ui/native_theme/native_theme_android.cc
@@ -22,8 +22,7 @@ NativeTheme* NativeTheme::GetInstanceFor
 }
 
 NativeTheme* NativeTheme::GetInstanceForNativeUi() {
-  NOTREACHED();
-  return nullptr;
+  return NativeThemeAndroid::instance();
 }
 #endif
 
--- a/ui/native_theme/native_theme_android.h
+++ b/ui/native_theme/native_theme_android.h
@@ -20,11 +20,11 @@ class NativeThemeAndroid : public Native
                         const ExtraParams& extra) const override;
   SkColor GetSystemColor(ColorId color_id,
                          ColorScheme color_scheme) const override;
+  static NativeThemeAndroid* instance();
 
  protected:
   friend class NativeTheme;
   friend class base::NoDestructor<NativeThemeAndroid>;
-  static NativeThemeAndroid* instance();
 
   // NativeThemeBase:
   void AdjustCheckboxRadioRectForPadding(SkRect* rect) const override;
--- a/ui/resources/BUILD.gn
+++ b/ui/resources/BUILD.gn
@@ -173,7 +173,7 @@ repack("repack_ui_test_pak_100_percent")
     ]
   }
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     deps += [ "//ui/views/resources" ]
     sources += [
       "$root_gen_dir/third_party/blink/public/resources/blink_resources.pak",
@@ -198,7 +198,7 @@ repack("repack_ui_test_pak_200_percent")
 
   deps = [ "//ui/resources" ]
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     deps += [ "//ui/views/resources" ]
     sources +=
         [ "$root_gen_dir/ui/views/resources/views_resources_200_percent.pak" ]
--- a/ui/resources/ui_resources.grd
+++ b/ui/resources/ui_resources.grd
@@ -78,7 +78,7 @@
         <structure type="chrome_scaled_image" name="IDR_AURA_CURSOR_ZOOM_IN" file="common/pointers/zoom_in.png" />
         <structure type="chrome_scaled_image" name="IDR_AURA_CURSOR_ZOOM_OUT" file="common/pointers/zoom_out.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2" file="close_2.png" />
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2_H" file="close_2_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2_MASK" file="close_2_mask.png" />
@@ -92,7 +92,7 @@
       </if>
       <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON" file="common/default_favicon.png" />
       <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_DARK" file="common/default_favicon_dark.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_32" file="common/default_favicon_32.png" />
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_DARK_32" file="common/default_favicon_dark_32.png" />
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_64" file="common/default_favicon_64.png" />
@@ -134,7 +134,7 @@
       <if expr="toolkit_views and not is_macosx">
         <structure type="chrome_scaled_image" name="IDR_NOTIFICATION_SETTINGS" file="common/notification_settings.png"/>
       </if>
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <structure type="chrome_scaled_image" name="IDR_NTP_DEFAULT_FAVICON" file="common/ntp_default_favicon.png" />
       </if>
       <if expr="not is_android and not is_ios">
@@ -142,7 +142,7 @@
         <structure type="chrome_scaled_image" name="IDR_OOBE_ACTION_BOX_BUTTON_NORMAL" file="cros/action_box_button_normal.png" />
         <structure type="chrome_scaled_image" name="IDR_OOBE_ACTION_BOX_BUTTON_PRESSED" file="cros/action_box_button_pressed.png" />
       </if>
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_0_BAR" file="common/signal_0_bar.png" />
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_1_BAR" file="common/signal_1_bar.png" />
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_2_BAR" file="common/signal_2_bar.png" />
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -12,7 +12,7 @@ import("//ui/base/ui_features.gni")
 import("//ui/ozone/ozone.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
+# assert(toolkit_views)
 
 # Reset sources_assignment_filter for the BUILD.gn file to prevent
 # regression during the migration of Chromium away from the feature.
@@ -253,6 +253,8 @@ jumbo_component("views") {
     "views_touch_selection_controller_factory.h",
     "widget/drop_helper.h",
     "widget/native_widget.h",
+    "widget/native_widget_aura.h",
+    "widget/native_widget_android.h",
     "widget/native_widget_delegate.h",
     "widget/native_widget_private.h",
     "widget/root_view.h",
@@ -656,6 +658,17 @@ jumbo_component("views") {
     ]
   }
 
+  sources += [
+      "native_cursor_android.cc",
+      "controls/native/native_view_host_android.cc",
+      "event_monitor_android.cc",
+      "widget/native_widget_android.cc",
+  ]
+
+  public += [
+      "controls/native/native_view_host_android.h",
+  ]
+
   if (use_aura) {
     public += [
       "accessibility/accessibility_alert_window.h",
@@ -680,6 +693,7 @@ jumbo_component("views") {
       "view_constants_aura.h",
       "widget/focus_manager_event_handler.h",
       "widget/native_widget_aura.h",
+      "widget/native_widget_android.h",
       "widget/tooltip_manager_aura.h",
       "widget/widget_aura_utils.h",
       "widget/window_reorderer.h",
--- /dev/null
+++ b/ui/views/controls/menu/menu_config_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/menu/menu_config.h"
+
+namespace views {
+
+void MenuConfig::Init() {
+  arrow_to_edge_padding = 6;
+}
+
+}  // namespace views
--- a/ui/views/controls/menu/menu_controller.cc
+++ b/ui/views/controls/menu/menu_controller.cc
@@ -497,10 +497,6 @@ void MenuController::Run(Widget* parent,
     owner_ = parent;
     if (owner_)
       owner_->AddObserver(this);
-
-    // Only create a MenuPreTargetHandler for non-nested menus. Nested menus
-    // will use the existing one.
-    menu_pre_target_handler_ = MenuPreTargetHandler::Create(this, owner_);
   }
 
 #if defined(OS_MACOSX)
@@ -862,8 +858,6 @@ void MenuController::OnGestureEvent(Subm
 #if defined(OS_MACOSX)
     NOTIMPLEMENTED();
 #else   // !defined(OS_MACOSX)
-    event->ConvertLocationToTarget(source->GetWidget()->GetNativeWindow(),
-                                   owner()->GetNativeWindow());
 #endif  // defined(OS_MACOSX)
     owner()->OnGestureEvent(event);
     // Reset |send_gesture_events_to_owner_| when the first gesture ends.
@@ -1012,42 +1006,7 @@ int MenuController::OnDragUpdated(Submen
     if (menu_item)
       over_empty_menu = true;
   }
-  MenuDelegate::DropPosition drop_position = MenuDelegate::DropPosition::kNone;
   int drop_operation = ui::DragDropTypes::DRAG_NONE;
-  if (menu_item) {
-    gfx::Point menu_item_loc(event.location());
-    View::ConvertPointToTarget(source, menu_item, &menu_item_loc);
-    MenuItemView* query_menu_item;
-    if (!over_empty_menu) {
-      int menu_item_height = menu_item->height();
-      if (menu_item->HasSubmenu() &&
-          (menu_item_loc.y() > kDropBetweenPixels &&
-           menu_item_loc.y() < (menu_item_height - kDropBetweenPixels))) {
-        drop_position = MenuDelegate::DropPosition::kOn;
-      } else {
-        drop_position = (menu_item_loc.y() < menu_item_height / 2)
-                            ? MenuDelegate::DropPosition::kBefore
-                            : MenuDelegate::DropPosition::kAfter;
-      }
-      query_menu_item = menu_item;
-    } else {
-      query_menu_item = menu_item->GetParentMenuItem();
-      drop_position = MenuDelegate::DropPosition::kOn;
-    }
-    drop_operation = menu_item->GetDelegate()->GetDropOperation(
-        query_menu_item, event, &drop_position);
-
-    // If the menu has a submenu, schedule the submenu to open.
-    SetSelection(menu_item, menu_item->HasSubmenu() ? SELECTION_OPEN_SUBMENU
-                                                    : SELECTION_DEFAULT);
-
-    if (drop_position == MenuDelegate::DropPosition::kNone ||
-        drop_operation == ui::DragDropTypes::DRAG_NONE)
-      menu_item = nullptr;
-  } else {
-    SetSelection(source->GetMenuItem(), SELECTION_OPEN_SUBMENU);
-  }
-  SetDropMenuItem(menu_item, drop_position);
   last_drop_operation_ = drop_operation;
   return drop_operation;
 }
@@ -2872,34 +2831,6 @@ void MenuController::UpdateActiveMouseVi
     if (target == target_menu || !target->GetEnabled())
       target = nullptr;
   }
-  View* active_mouse_view = active_mouse_view_tracker_->view();
-  if (target != active_mouse_view) {
-    SendMouseCaptureLostToActiveView();
-    active_mouse_view = target;
-    active_mouse_view_tracker_->SetView(active_mouse_view);
-    if (active_mouse_view) {
-      gfx::Point target_point(target_menu_loc);
-      View::ConvertPointToTarget(target_menu, active_mouse_view, &target_point);
-      ui::MouseEvent mouse_entered_event(ui::ET_MOUSE_ENTERED, target_point,
-                                         target_point, ui::EventTimeForNow(), 0,
-                                         0);
-      active_mouse_view->OnMouseEntered(mouse_entered_event);
-
-      ui::MouseEvent mouse_pressed_event(
-          ui::ET_MOUSE_PRESSED, target_point, target_point,
-          ui::EventTimeForNow(), event.flags(), event.changed_button_flags());
-      active_mouse_view->OnMousePressed(mouse_pressed_event);
-    }
-  }
-
-  if (active_mouse_view) {
-    gfx::Point target_point(target_menu_loc);
-    View::ConvertPointToTarget(target_menu, active_mouse_view, &target_point);
-    ui::MouseEvent mouse_dragged_event(
-        ui::ET_MOUSE_DRAGGED, target_point, target_point, ui::EventTimeForNow(),
-        event.flags(), event.changed_button_flags());
-    active_mouse_view->OnMouseDragged(mouse_dragged_event);
-  }
 }
 
 void MenuController::SendMouseReleaseToActiveView(SubmenuView* event_source,
--- a/ui/views/controls/menu/menu_host.cc
+++ b/ui/views/controls/menu/menu_host.cc
@@ -80,13 +80,6 @@ class PreMenuEventDispatchHandler : publ
 #endif  // OS_MACOSX
 
 void TransferGesture(Widget* source, Widget* target) {
-#if defined(OS_MACOSX)
-  NOTIMPLEMENTED();
-#else   // !defined(OS_MACOSX)
-  source->GetGestureRecognizer()->TransferEventsTo(
-      source->GetNativeView(), target->GetNativeView(),
-      ui::TransferTouchesBehavior::kDontCancel);
-#endif  // defined(OS_MACOSX)
 }
 
 }  // namespace internal
@@ -138,12 +131,6 @@ void MenuHost::InitMenuHost(Widget* pare
 #endif
   Init(std::move(params));
 
-#if !defined(OS_MACOSX)
-  pre_dispatch_handler_ =
-      std::make_unique<internal::PreMenuEventDispatchHandler>(
-          menu_controller, submenu_, GetNativeView());
-#endif
-
   DCHECK(!owner_);
   owner_ = parent;
   if (owner_)
@@ -158,32 +145,6 @@ bool MenuHost::IsMenuHostVisible() {
 }
 
 void MenuHost::ShowMenuHost(bool do_capture) {
-  // Doing a capture may make us get capture lost. Ignore it while we're in the
-  // process of showing.
-  base::AutoReset<bool> reseter(&ignore_capture_lost_, true);
-  ShowInactive();
-  if (do_capture) {
-    MenuController* menu_controller =
-        submenu_->GetMenuItem()->GetMenuController();
-    if (menu_controller && menu_controller->send_gesture_events_to_owner()) {
-      // TransferGesture when owner needs gesture events so that the incoming
-      // touch events after MenuHost is created are properly translated into
-      // gesture events instead of being dropped.
-      internal::TransferGesture(owner_, this);
-    } else {
-      GetGestureRecognizer()->CancelActiveTouchesExcept(nullptr);
-    }
-#if defined(MACOSX)
-    // Cancel existing touches, so we don't miss some touch release/cancel
-    // events due to the menu taking capture.
-    GetGestureRecognizer()->CancelActiveTouchesExcept(nullptr);
-#endif  // defined (OS_MACOSX)
-    // If MenuHost has no parent widget, it needs to call Show to get focus,
-    // so that it will get keyboard events.
-    if (owner_ == nullptr)
-      Show();
-    native_widget_private()->SetCapture();
-  }
 }
 
 void MenuHost::HideMenuHost() {
@@ -203,9 +164,6 @@ void MenuHost::DestroyMenuHost() {
   HideMenuHost();
   destroying_ = true;
   static_cast<MenuHostRootView*>(GetRootView())->ClearSubmenu();
-#if !defined(OS_MACOSX)
-  pre_dispatch_handler_.reset();
-#endif
   Close();
 }
 
--- a/ui/views/controls/menu/menu_host.h
+++ b/ui/views/controls/menu/menu_host.h
@@ -95,11 +95,6 @@ class MenuHost : public Widget, public W
   // If true and capture is lost we don't notify the delegate.
   bool ignore_capture_lost_;
 
-#if !defined(OS_MACOSX)
-  // Handles raw touch events at the moment.
-  std::unique_ptr<internal::PreMenuEventDispatchHandler> pre_dispatch_handler_;
-#endif
-
   DISALLOW_COPY_AND_ASSIGN(MenuHost);
 };
 
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/native/native_view_host_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/optional.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/base/hit_test.h"
+#include "ui/compositor/paint_recorder.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/views/controls/native/native_view_host.h"
+#include "ui/views/painter.h"
+#include "ui/views/view_class_properties.h"
+#include "ui/views/widget/widget.h"
+
+namespace views {
+
+NativeViewHostAndroid::NativeViewHostAndroid(NativeViewHost* host) : host_(host) {}
+
+NativeViewHostAndroid::~NativeViewHostAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeViewHostAura, NativeViewHostWrapper implementation:
+void NativeViewHostAndroid::AttachNativeView() {
+}
+
+void NativeViewHostAndroid::SetParentAccessible(
+    gfx::NativeViewAccessible accessible) {
+}
+
+void NativeViewHostAndroid::NativeViewDetaching(bool destroyed) {
+}
+
+void NativeViewHostAndroid::AddedToWidget() {
+}
+
+void NativeViewHostAndroid::RemovedFromWidget() {
+}
+
+bool NativeViewHostAndroid::SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) {
+  return false;
+}
+
+void NativeViewHostAndroid::SetHitTestTopInset(int top_inset) {
+}
+
+void NativeViewHostAndroid::InstallClip(int x, int y, int w, int h) {
+}
+
+int NativeViewHostAndroid::GetHitTestTopInset() const {
+  return top_inset_;
+}
+
+bool NativeViewHostAndroid::HasInstalledClip() {
+  return !!clip_rect_;
+}
+
+void NativeViewHostAndroid::UninstallClip() {
+  clip_rect_.reset();
+}
+
+void NativeViewHostAndroid::ShowWidget(int x,
+                                    int y,
+                                    int w,
+                                    int h,
+                                    int native_w,
+                                    int native_h) {
+}
+
+void NativeViewHostAndroid::HideWidget() {
+}
+
+void NativeViewHostAndroid::SetFocus() {
+}
+
+gfx::NativeView NativeViewHostAndroid::GetNativeViewContainer() const {
+  return gfx::NativeView();
+}
+
+gfx::NativeViewAccessible NativeViewHostAndroid::GetNativeViewAccessible() {
+  return nullptr;
+}
+
+gfx::NativeCursor NativeViewHostAndroid::GetCursor(int x, int y) {
+  return gfx::kNullCursor;
+}
+
+void NativeViewHostAndroid::SetVisible(bool visible) {
+}
+
+// static
+NativeViewHostWrapper* NativeViewHostWrapper::CreateWrapper(
+    NativeViewHost* host) {
+  return new NativeViewHostAndroid(host);
+}
+
+void NativeViewHostAndroid::CreateClippingWindow() {
+}
+
+void NativeViewHostAndroid::AddClippingWindow() {
+}
+
+void NativeViewHostAndroid::RemoveClippingWindow() {
+}
+
+void NativeViewHostAndroid::InstallMask() {
+}
+
+void NativeViewHostAndroid::UninstallMask() {
+}
+
+void NativeViewHostAndroid::UpdateInsets() {
+}
+
+}  // namespace views
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+#define UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "ui/compositor/layer_owner.h"
+#include "ui/gfx/transform.h"
+#include "ui/views/controls/native/native_view_host_wrapper.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+
+class NativeViewHost;
+
+// Android implementation of NativeViewHostWrapper.
+class NativeViewHostAndroid : public NativeViewHostWrapper {
+
+ public:
+  explicit NativeViewHostAndroid(NativeViewHost* host);
+  ~NativeViewHostAndroid() override;
+
+  // Overridden from NativeViewHostWrapper:
+  void AttachNativeView() override;
+  void NativeViewDetaching(bool destroyed) override;
+  void AddedToWidget() override;
+  void RemovedFromWidget() override;
+  bool SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) override;
+  void SetHitTestTopInset(int top_inset) override;
+  int GetHitTestTopInset() const override;
+  void InstallClip(int x, int y, int w, int h) override;
+  bool HasInstalledClip() override;
+  void UninstallClip() override;
+  void ShowWidget(int x, int y, int w, int h, int native_w, int native_h)
+      override;
+  void HideWidget() override;
+  void SetFocus() override;
+  gfx::NativeView GetNativeViewContainer() const override;
+  gfx::NativeViewAccessible GetNativeViewAccessible() override;
+  gfx::NativeCursor GetCursor(int x, int y) override;
+  void SetVisible(bool visible) override;
+  void SetParentAccessible(gfx::NativeViewAccessible) override;
+
+ private:
+  friend class NativeViewHostAndroidTest;
+
+  void CreateClippingWindow();
+
+  // Reparents the native view with the clipping window existing between it and
+  // its old parent, so that the fast resize path works.
+  void AddClippingWindow();
+
+  // If the native view has been reparented via AddClippingWindow, this call
+  // undoes it.
+  void RemoveClippingWindow();
+
+  // Sets or updates the mask layer on the native view's layer.
+  void InstallMask();
+
+  // Unsets the mask layer on the native view's layer.
+  void UninstallMask();
+
+  // Updates the top insets of |clipping_window_|.
+  void UpdateInsets();
+
+  // Our associated NativeViewHost.
+  NativeViewHost* host_;
+
+  // Window that exists between the native view and the parent that allows for
+  // clipping to occur. This is positioned in the coordinate space of
+  // host_->GetWidget().
+  std::unique_ptr<gfx::Rect> clip_rect_;
+
+  // This mask exists for the sake of SetCornerRadius().
+  std::unique_ptr<ui::LayerOwner> mask_;
+
+  // Set when AttachNativeView() is called. This is the original transform of
+  // the NativeView's layer. The NativeView's layer may be modified to scale
+  // when ShowWidget() is called with a native view size not equal to the
+  // region's size. When NativeViewDetaching() is called, the NativeView's
+  // transform is restored to this.
+  gfx::Transform original_transform_;
+
+  // True if a transform different from the original was set.
+  bool original_transform_changed_ = false;
+
+  // The top insets to exclude the underlying native view from the target.
+  int top_inset_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeViewHostAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
@@ -50,9 +50,6 @@ bool UnhandledKeyboardEventHandler::Hand
     ignore_next_char_event_ = false;
   }
 
-  if (event.os_event && !event.skip_in_browser)
-    return HandleNativeKeyboardEvent(event.os_event, focus_manager);
-
   return false;
 }
 
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
@@ -13,7 +13,7 @@ namespace views {
 bool UnhandledKeyboardEventHandler::HandleNativeKeyboardEvent(
     gfx::NativeEvent event,
     FocusManager* focus_manager) {
-  return !focus_manager->OnKeyEvent(*(event->AsKeyEvent()));
+  return false;
 }
 
 }  // namespace views
--- a/ui/views/controls/webview/web_dialog_view.cc
+++ b/ui/views/controls/webview/web_dialog_view.cc
@@ -350,11 +350,7 @@ void WebDialogView::SetContentsBounds(We
 // they're all browser-specific. (This may change in the future.)
 bool WebDialogView::HandleKeyboardEvent(content::WebContents* source,
                                         const NativeWebKeyboardEvent& event) {
-  if (!event.os_event)
-    return false;
-
-  return unhandled_keyboard_event_handler_.HandleKeyboardEvent(
-      event, GetFocusManager());
+  return false;
 }
 
 void WebDialogView::CloseContents(WebContents* source) {
--- /dev/null
+++ b/ui/views/event_monitor_android.cc
@@ -0,0 +1,65 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/event_monitor_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/scoped_observer.h"
+#include "ui/events/event_observer.h"
+#include "ui/events/event_target.h"
+
+namespace views {
+
+EventMonitorAndroid::EventMonitorAndroid(ui::EventObserver* event_observer,
+                                   ui::EventTarget* event_target,
+                                   const std::set<ui::EventType>& types) {
+}
+
+EventMonitorAndroid::~EventMonitorAndroid() {
+}
+
+namespace {
+
+// An EventMonitorAndroid that removes its event observer on window destruction.
+class WindowMonitorAndroid : public EventMonitorAndroid {
+ public:
+  WindowMonitorAndroid(ui::EventObserver* event_observer,
+                    ui::EventTarget* target_window,
+                    const std::set<ui::EventType>& types)
+      : EventMonitorAndroid(event_observer, target_window, types) {
+  }
+  ~WindowMonitorAndroid() override = default;
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(WindowMonitorAndroid);
+};
+
+}  // namespace
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateApplicationMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow context,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<EventMonitorAndroid>(event_observer,
+                                            nullptr, types);
+}
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateWindowMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow target_window,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<WindowMonitorAndroid>(event_observer, nullptr,
+                                             types);
+}
+
+gfx::Point EventMonitorAndroid::GetLastMouseLocation() {
+  return gfx::Point();
+}
+
+}  // namespace views
--- /dev/null
+++ b/ui/views/event_monitor_android.h
@@ -0,0 +1,37 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+#define UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+
+#include "base/macros.h"
+#include "ui/views/event_monitor.h"
+
+namespace ui {
+class EventTarget;
+}
+
+namespace views {
+
+// Observes events by installing a pre-target handler on the ui::EventTarget.
+class EventMonitorAndroid : public EventMonitor {
+ public:
+  EventMonitorAndroid(ui::EventObserver* event_observer,
+                   ui::EventTarget* event_target,
+                   const std::set<ui::EventType>& types);
+  ~EventMonitorAndroid() override;
+
+  // EventMonitor:
+  gfx::Point GetLastMouseLocation() override;
+
+ protected:
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(EventMonitorAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_EVENT_MONITOR_Android_H_
--- /dev/null
+++ b/ui/views/metrics_android.cc
@@ -0,0 +1,36 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/build_config.h"
+#include "ui/views/metrics.h"
+
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+namespace views {
+
+int GetDoubleClickInterval() {
+#if defined(OS_WIN)
+  return ::GetDoubleClickTime();
+#else
+  // TODO(jennyz): This value may need to be adjusted on different platforms.
+  const int kDefaultDoubleClickIntervalMs = 500;
+  return kDefaultDoubleClickIntervalMs;
+#endif
+}
+
+int GetMenuShowDelay() {
+#if defined(OS_WIN)
+  static DWORD delay = 0;
+  if (!delay && !SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &delay, 0))
+    delay = kDefaultMenuShowDelay;
+  return delay;
+#else
+  return 0;
+#endif
+}
+
+}  // namespace views
+
--- /dev/null
+++ b/ui/views/native_cursor_android.cc
@@ -0,0 +1,31 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/native_cursor.h"
+
+#include "ui/base/cursor/cursor.h"
+
+namespace views {
+
+gfx::NativeCursor GetNativeIBeamCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeHandCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeColumnResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeEastWestResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeNorthSouthResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+}  // namespace views
--- a/ui/views/view.cc
+++ b/ui/views/view.cc
@@ -2313,6 +2313,7 @@ void View::PropagateRemoveNotifications(
 
 void View::PropagateAddNotifications(const ViewHierarchyChangedDetails& details,
                                      bool is_added_to_widget) {
+#if 0
   {
     internal::ScopedChildrenLock lock(this);
     for (auto* child : children_)
@@ -2324,6 +2325,7 @@ void View::PropagateAddNotifications(con
     for (ViewObserver& observer : observers_)
       observer.OnViewAddedToWidget(this);
   }
+#endif
 }
 
 void View::PropagateNativeViewHierarchyChanged() {
--- /dev/null
+++ b/ui/views/views_touch_selection_controller_factory_android.cc
@@ -0,0 +1,22 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/views_touch_selection_controller_factory.h"
+
+#include "ui/base/ui_base_switches_util.h"
+#include "ui/views/touchui/touch_selection_controller_impl.h"
+
+namespace views {
+
+ViewsTouchEditingControllerFactory::ViewsTouchEditingControllerFactory() {
+}
+
+ui::TouchEditingControllerDeprecated*
+ViewsTouchEditingControllerFactory::Create(
+    ui::TouchEditable* client_view) {
+  return nullptr;
+}
+
+}  // namespace views
+
--- a/ui/views/views_touch_selection_controller_factory_aura.cc
+++ b/ui/views/views_touch_selection_controller_factory_aura.cc
@@ -15,7 +15,7 @@ ViewsTouchEditingControllerFactory::View
 ui::TouchEditingControllerDeprecated*
 ViewsTouchEditingControllerFactory::Create(
     ui::TouchEditable* client_view) {
-  return new views::TouchSelectionControllerImpl(client_view);
+  return nullptr;
 }
 
 }  // namespace views
--- /dev/null
+++ b/ui/views/widget/native_widget_android.cc
@@ -0,0 +1,491 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/native_widget_android.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/string_util.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "build/build_config.h"
+#include "ui/base/class_property.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/ui_base_types.h"
+#include "ui/compositor/layer.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/events/event.h"
+#include "ui/gfx/canvas.h"
+#include "ui/native_theme/native_theme_android.h"
+#include "ui/views/drag_utils.h"
+#include "ui/views/views_delegate.h"
+#include "ui/views/widget/drop_helper.h"
+#include "ui/views/widget/focus_manager_event_handler.h"
+#include "ui/views/widget/native_widget_delegate.h"
+#include "ui/views/widget/root_view.h"
+#include "ui/views/widget/tooltip_manager_aura.h"
+#include "ui/views/widget/widget_aura_utils.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "ui/views/widget/window_reorderer.h"
+#include "ui/wm/core/coordinate_conversion.h"
+#include "ui/wm/core/shadow_types.h"
+#include "ui/wm/core/transient_window_manager.h"
+#include "ui/wm/core/window_animations.h"
+#include "ui/wm/core/window_properties.h"
+#include "ui/wm/core/window_util.h"
+#include "ui/wm/public/activation_client.h"
+#include "ui/wm/public/window_move_client.h"
+
+#if defined(OS_WIN)
+#include "base/win/scoped_gdi_object.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
+#endif
+
+#if defined(USE_X11)
+#include "ui/views/linux_ui/linux_ui.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_x11.h"
+#endif
+
+#if !defined(OS_CHROMEOS)
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
+#endif
+
+DEFINE_UI_CLASS_PROPERTY_TYPE(views::internal::NativeWidgetPrivate*)
+
+namespace views {
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, public:
+
+NativeWidgetAndroid::NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate)
+    : delegate_(delegate),
+      ownership_(Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET),
+      destroying_(false) {
+}
+
+// static
+void NativeWidgetAndroid::RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window) {
+}
+
+// static
+void NativeWidgetAndroid::AssignIconToAuraWindow(gfx::NativeWindow window,
+                                              const gfx::ImageSkia& window_icon,
+                                              const gfx::ImageSkia& app_icon) {
+}
+
+// static
+void NativeWidgetAndroid::SetShadowElevationFromInitParams(
+    gfx::NativeWindow window,
+    const Widget::InitParams& params) {
+}
+
+// static
+void NativeWidgetAndroid::SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                                     gfx::NativeWindow window) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, internal::NativeWidgetPrivate implementation:
+
+void NativeWidgetAndroid::InitNativeWidget(Widget::InitParams params) {
+  delegate_->OnNativeWidgetCreated();
+}
+
+void NativeWidgetAndroid::OnWidgetInitDone() {}
+
+NonClientFrameView* NativeWidgetAndroid::CreateNonClientFrameView() {
+  return nullptr;
+}
+
+bool NativeWidgetAndroid::ShouldUseNativeFrame() const {
+  // There is only one frame type for aura.
+  return false;
+}
+
+bool NativeWidgetAndroid::ShouldWindowContentsBeTransparent() const {
+  return false;
+}
+
+void NativeWidgetAndroid::FrameTypeChanged() {
+  // This is called when the Theme has changed; forward the event to the root
+  // widget.
+  GetWidget()->ThemeChanged();
+  GetWidget()->GetRootView()->SchedulePaint();
+}
+
+Widget* NativeWidgetAndroid::GetWidget() {
+  return delegate_->AsWidget();
+}
+
+const Widget* NativeWidgetAndroid::GetWidget() const {
+  return delegate_->AsWidget();
+}
+
+gfx::NativeView NativeWidgetAndroid::GetNativeView() const {
+  return window_;
+}
+
+gfx::NativeWindow NativeWidgetAndroid::GetNativeWindow() const {
+  return window_;
+}
+
+Widget* NativeWidgetAndroid::GetTopLevelWidget() {
+  NativeWidgetPrivate* native_widget = GetTopLevelNativeWidget(GetNativeView());
+  return native_widget ? native_widget->GetWidget() : nullptr;
+}
+
+const ui::Compositor* NativeWidgetAndroid::GetCompositor() const {
+  return nullptr;
+}
+
+const ui::Layer* NativeWidgetAndroid::GetLayer() const {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::ReorderNativeViews() {
+}
+
+void NativeWidgetAndroid::ViewRemoved(View* view) {
+  DCHECK(drop_helper_.get() != nullptr);
+  drop_helper_->ResetTargetViewIfEquals(view);
+}
+
+void NativeWidgetAndroid::SetNativeWindowProperty(const char* name, void* value) {
+}
+
+void* NativeWidgetAndroid::GetNativeWindowProperty(const char* name) const {
+  return nullptr;
+}
+
+TooltipManager* NativeWidgetAndroid::GetTooltipManager() const {
+  return tooltip_manager_.get();
+}
+
+void NativeWidgetAndroid::SetCapture() {
+}
+
+void NativeWidgetAndroid::ReleaseCapture() {
+}
+
+bool NativeWidgetAndroid::HasCapture() const {
+  return false;
+}
+
+ui::InputMethod* NativeWidgetAndroid::GetInputMethod() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::CenterWindow(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+}
+
+bool NativeWidgetAndroid::SetWindowTitle(const base::string16& title) {
+  return true;
+}
+
+void NativeWidgetAndroid::SetWindowIcons(const gfx::ImageSkia& window_icon,
+                                      const gfx::ImageSkia& app_icon) {
+}
+
+void NativeWidgetAndroid::InitModalType(ui::ModalType modal_type) {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWindowBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetClientAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetRestoredBounds() const {
+  return gfx::Rect();
+}
+
+std::string NativeWidgetAndroid::GetWorkspace() const {
+  return std::string();
+}
+
+void NativeWidgetAndroid::SetBounds(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetBoundsConstrained(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetSize(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::StackAbove(gfx::NativeView native_view) {
+}
+
+void NativeWidgetAndroid::StackAtTop() {
+}
+
+void NativeWidgetAndroid::SetShape(std::unique_ptr<Widget::ShapeRects> shape) {
+}
+
+void NativeWidgetAndroid::Close() {
+}
+
+void NativeWidgetAndroid::CloseNow() {
+}
+
+void NativeWidgetAndroid::Show(ui::WindowShowState show_state,
+                            const gfx::Rect& restore_bounds) {
+}
+
+void NativeWidgetAndroid::Hide() {
+}
+
+bool NativeWidgetAndroid::IsVisible() const {
+  return true;
+}
+
+void NativeWidgetAndroid::Activate() {
+}
+
+void NativeWidgetAndroid::Deactivate() {
+}
+
+bool NativeWidgetAndroid::IsActive() const {
+  return true;
+}
+
+void NativeWidgetAndroid::SetZOrderLevel(ui::ZOrderLevel order) {
+}
+
+ui::ZOrderLevel NativeWidgetAndroid::GetZOrderLevel() const {
+  return ui::ZOrderLevel::kNormal;
+}
+
+void NativeWidgetAndroid::SetVisibleOnAllWorkspaces(bool always_visible) {
+  // Not implemented on chromeos or for child widgets.
+}
+
+bool NativeWidgetAndroid::IsVisibleOnAllWorkspaces() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Maximize() {
+}
+
+void NativeWidgetAndroid::Minimize() {
+}
+
+bool NativeWidgetAndroid::IsMaximized() const {
+  return true;
+}
+
+bool NativeWidgetAndroid::IsMinimized() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Restore() {
+}
+
+void NativeWidgetAndroid::SetFullscreen(bool fullscreen) {
+}
+
+bool NativeWidgetAndroid::IsFullscreen() const {
+  return false;
+}
+
+void NativeWidgetAndroid::SetCanAppearInExistingFullscreenSpaces(
+    bool can_appear_in_existing_fullscreen_spaces) {}
+
+void NativeWidgetAndroid::SetOpacity(float opacity) {
+}
+
+void NativeWidgetAndroid::SetAspectRatio(const gfx::SizeF& aspect_ratio) {
+}
+
+void NativeWidgetAndroid::FlashFrame(bool flash) {
+}
+
+void NativeWidgetAndroid::RunShellDrag(View* view,
+                                    std::unique_ptr<ui::OSExchangeData> data,
+                                    const gfx::Point& location,
+                                    int operation,
+                                    ui::DragDropTypes::DragEventSource source) {
+}
+
+void NativeWidgetAndroid::SchedulePaintInRect(const gfx::Rect& rect) {
+}
+
+void NativeWidgetAndroid::ScheduleLayout() {
+}
+
+void NativeWidgetAndroid::SetCursor(gfx::NativeCursor cursor) {
+}
+
+bool NativeWidgetAndroid::IsMouseEventsEnabled() const {
+  return true;
+}
+
+bool NativeWidgetAndroid::IsMouseButtonDown() const {
+  return false;
+}
+
+void NativeWidgetAndroid::ClearNativeFocus() {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWorkAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+Widget::MoveLoopResult NativeWidgetAndroid::RunMoveLoop(
+    const gfx::Vector2d& drag_offset,
+    Widget::MoveLoopSource source,
+    Widget::MoveLoopEscapeBehavior escape_behavior) {
+  return Widget::MOVE_LOOP_CANCELED;
+}
+
+void NativeWidgetAndroid::EndMoveLoop() {
+}
+
+void NativeWidgetAndroid::SetVisibilityChangedAnimationsEnabled(bool value) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationDuration(
+    const base::TimeDelta& duration) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationTransition(
+    Widget::VisibilityTransition transition) {
+}
+
+bool NativeWidgetAndroid::IsTranslucentWindowOpacitySupported() const {
+  return true;
+}
+
+ui::GestureRecognizer* NativeWidgetAndroid::GetGestureRecognizer() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::OnSizeConstraintsChanged() {
+}
+
+std::string NativeWidgetAndroid::GetName() const {
+  return std::string();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, protected:
+
+NativeWidgetAndroid::~NativeWidgetAndroid() {
+  destroying_ = true;
+  if (ownership_ == Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET)
+    delete delegate_;
+  else
+    CloseNow();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, private:
+
+void NativeWidgetAndroid::SetInitialFocus(ui::WindowShowState show_state) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Widget, public:
+
+namespace {
+#if defined(OS_WIN) || defined(USE_X11)
+void CloseWindow(gfx::NativeWindow window) {
+  if (window) {
+    Widget* widget = Widget::GetWidgetForNativeView(window);
+    if (widget && widget->is_secondary_widget())
+      // To avoid the delay in shutdown caused by using Close which may wait
+      // for animations, use CloseNow. Because this is only used on secondary
+      // widgets it seems relatively safe to skip the extra processing of
+      // Close.
+      widget->CloseNow();
+  }
+}
+#endif
+
+#if defined(OS_WIN)
+BOOL CALLBACK WindowCallbackProc(HWND hwnd, LPARAM lParam) {
+  gfx::NativeWindow root_window =
+      DesktopWindowTreeHostWin::GetContentWindowForHWND(hwnd);
+  CloseWindow(root_window);
+  return TRUE;
+}
+#endif
+}  // namespace
+
+// static
+void Widget::CloseAllSecondaryWidgets() {
+#if defined(OS_WIN)
+  EnumThreadWindows(GetCurrentThreadId(), WindowCallbackProc, 0);
+#endif
+
+#if defined(USE_X11)
+  DesktopWindowTreeHostX11::CleanUpWindowList(CloseWindow);
+#endif
+}
+
+namespace internal {
+
+////////////////////////////////////////////////////////////////////////////////
+// internal::NativeWidgetPrivate, public:
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::CreateNativeWidget(
+    internal::NativeWidgetDelegate* delegate) {
+  return new NativeWidgetAndroid(delegate);
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeView(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
+    gfx::NativeWindow native_window) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetTopLevelNativeWidget(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+void NativeWidgetPrivate::GetAllChildWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* children) {
+}
+
+// static
+void NativeWidgetPrivate::GetAllOwnedWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* owned) {
+}
+
+// static
+void NativeWidgetPrivate::ReparentNativeView(gfx::NativeView native_view,
+                                             gfx::NativeView new_parent) {
+}
+
+// static
+gfx::NativeView NativeWidgetPrivate::GetGlobalCapture(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+}  // namespace internal
+}  // namespace views
--- /dev/null
+++ b/ui/views/widget/native_widget_android.h
@@ -0,0 +1,192 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+#define UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/events/event_constants.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/native_widget_private.h"
+#include "ui/wm/public/activation_change_observer.h"
+#include "ui/wm/public/activation_delegate.h"
+
+#if defined(OS_MACOSX)
+#error This file must not be included on macOS; Chromium Mac doesn't use Aura.
+#endif
+
+namespace aura {
+class Window;
+}
+
+namespace views {
+
+class DropHelper;
+class FocusManagerEventHandler;
+class TooltipManagerAura;
+class WindowReorderer;
+
+class VIEWS_EXPORT NativeWidgetAndroid : public internal::NativeWidgetPrivate {
+ public:
+  explicit NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate);
+
+  // Called internally by NativeWidgetAndroid and DesktopNativeWidgetAndroid to
+  // associate |native_widget| with |window|.
+  static void RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window);
+
+  // Assign an icon to aura window.
+  static void AssignIconToAuraWindow(gfx::NativeWindow window,
+                                     const gfx::ImageSkia& window_icon,
+                                     const gfx::ImageSkia& app_icon);
+
+  // If necessary, sets the ShadowElevation of |window| from |params|.
+  static void SetShadowElevationFromInitParams(
+      gfx::NativeWindow window,
+      const Widget::InitParams& params);
+
+  // Sets the window property aura::client::kResizeBehaviorKey based on the
+  // values from the delegate.
+  static void SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                            gfx::NativeWindow window);
+
+  // Overridden from internal::NativeWidgetPrivate:
+  void InitNativeWidget(Widget::InitParams params) override;
+  void OnWidgetInitDone() override;
+  NonClientFrameView* CreateNonClientFrameView() override;
+  bool ShouldUseNativeFrame() const override;
+  bool ShouldWindowContentsBeTransparent() const override;
+  void FrameTypeChanged() override;
+  Widget* GetWidget() override;
+  const Widget* GetWidget() const override;
+  gfx::NativeView GetNativeView() const override;
+  gfx::NativeWindow GetNativeWindow() const override;
+  Widget* GetTopLevelWidget() override;
+  const ui::Compositor* GetCompositor() const override;
+  const ui::Layer* GetLayer() const override;
+  void ReorderNativeViews() override;
+  void ViewRemoved(View* view) override;
+  void SetNativeWindowProperty(const char* name, void* value) override;
+  void* GetNativeWindowProperty(const char* name) const override;
+  TooltipManager* GetTooltipManager() const override;
+  void SetCapture() override;
+  void ReleaseCapture() override;
+  bool HasCapture() const override;
+  ui::InputMethod* GetInputMethod() override;
+  void CenterWindow(const gfx::Size& size) override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* maximized) const override;
+  bool SetWindowTitle(const base::string16& title) override;
+  void SetWindowIcons(const gfx::ImageSkia& window_icon,
+                      const gfx::ImageSkia& app_icon) override;
+  void InitModalType(ui::ModalType modal_type) override;
+  gfx::Rect GetWindowBoundsInScreen() const override;
+  gfx::Rect GetClientAreaBoundsInScreen() const override;
+  gfx::Rect GetRestoredBounds() const override;
+  std::string GetWorkspace() const override;
+  void SetBounds(const gfx::Rect& bounds) override;
+  void SetBoundsConstrained(const gfx::Rect& bounds) override;
+  void SetSize(const gfx::Size& size) override;
+  void StackAbove(gfx::NativeView native_view) override;
+  void StackAtTop() override;
+  void SetShape(std::unique_ptr<Widget::ShapeRects> shape) override;
+  void Close() override;
+  void CloseNow() override;
+  void Show(ui::WindowShowState show_state,
+            const gfx::Rect& restore_bounds) override;
+  void Hide() override;
+  bool IsVisible() const override;
+  void Activate() override;
+  void Deactivate() override;
+  bool IsActive() const override;
+  void SetZOrderLevel(ui::ZOrderLevel order) override;
+  ui::ZOrderLevel GetZOrderLevel() const override;
+  void SetVisibleOnAllWorkspaces(bool always_visible) override;
+  bool IsVisibleOnAllWorkspaces() const override;
+  void Maximize() override;
+  void Minimize() override;
+  bool IsMaximized() const override;
+  bool IsMinimized() const override;
+  void Restore() override;
+  void SetFullscreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetCanAppearInExistingFullscreenSpaces(
+      bool can_appear_in_existing_fullscreen_spaces) override;
+  void SetOpacity(float opacity) override;
+  void SetAspectRatio(const gfx::SizeF& aspect_ratio) override;
+  void FlashFrame(bool flash_frame) override;
+  void RunShellDrag(View* view,
+                    std::unique_ptr<ui::OSExchangeData> data,
+                    const gfx::Point& location,
+                    int operation,
+                    ui::DragDropTypes::DragEventSource source) override;
+  void SchedulePaintInRect(const gfx::Rect& rect) override;
+  void ScheduleLayout() override;
+  void SetCursor(gfx::NativeCursor cursor) override;
+  bool IsMouseEventsEnabled() const override;
+  bool IsMouseButtonDown() const override;
+  void ClearNativeFocus() override;
+  gfx::Rect GetWorkAreaBoundsInScreen() const override;
+  Widget::MoveLoopResult RunMoveLoop(
+      const gfx::Vector2d& drag_offset,
+      Widget::MoveLoopSource source,
+      Widget::MoveLoopEscapeBehavior escape_behavior) override;
+  void EndMoveLoop() override;
+  void SetVisibilityChangedAnimationsEnabled(bool value) override;
+  void SetVisibilityAnimationDuration(const base::TimeDelta& duration) override;
+  void SetVisibilityAnimationTransition(
+      Widget::VisibilityTransition transition) override;
+  bool IsTranslucentWindowOpacitySupported() const override;
+  ui::GestureRecognizer* GetGestureRecognizer() override;
+  void OnSizeConstraintsChanged() override;
+  std::string GetName() const override;
+
+ protected:
+  ~NativeWidgetAndroid() override;
+
+  internal::NativeWidgetDelegate* delegate() { return delegate_; }
+
+ private:
+  void SetInitialFocus(ui::WindowShowState show_state);
+
+  internal::NativeWidgetDelegate* delegate_;
+
+  // WARNING: set to NULL when destroyed. As the Widget is not necessarily
+  // destroyed along with |window_| all usage of |window_| should first verify
+  // non-NULL.
+  gfx::NativeWindow window_;
+
+  // See class documentation for Widget in widget.h for a note about ownership.
+  Widget::InitParams::Ownership ownership_;
+
+  // Are we in the destructor?
+  bool destroying_;
+
+  std::unique_ptr<TooltipManagerAura> tooltip_manager_;
+
+  // Reorders child windows of |window_| associated with a view based on the
+  // order of the associated views in the widget's view hierarchy.
+  std::unique_ptr<WindowReorderer> window_reorderer_;
+
+  std::unique_ptr<DropHelper> drop_helper_;
+
+  // Native widget's handler to receive events before the event target.
+  std::unique_ptr<FocusManagerEventHandler> focus_manager_event_handler_;
+
+  // The following factory is used for calls to close the NativeWidgetAndroid
+  // instance.
+  base::WeakPtrFactory<NativeWidgetAndroid> close_widget_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWidgetAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_NATIVE_WIDGET_AURA_H_
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -33,6 +33,7 @@
 #include "ui/views/focus/widget_focus_manager.h"
 #include "ui/views/views_delegate.h"
 #include "ui/views/widget/native_widget_private.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/widget/root_view.h"
 #include "ui/views/widget/tooltip_manager.h"
 #include "ui/views/widget/widget_delegate.h"
@@ -176,6 +177,10 @@ ui::ZOrderLevel Widget::InitParams::Effe
 ////////////////////////////////////////////////////////////////////////////////
 // Widget, public:
 
+const ui::NativeTheme* Widget::GetNativeTheme() const {
+  return ui::NativeThemeAndroid::instance();
+}
+
 Widget::Widget() = default;
 
 Widget::~Widget() {
@@ -230,42 +235,35 @@ Widget* Widget::CreateWindowWithContextA
 
 // static
 Widget* Widget::GetWidgetForNativeView(gfx::NativeView native_view) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetNativeWidgetForNativeView(native_view);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 Widget* Widget::GetWidgetForNativeWindow(gfx::NativeWindow native_window) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
-          native_window);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 Widget* Widget::GetTopLevelWidgetForNativeView(gfx::NativeView native_view) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetTopLevelNativeWidget(native_view);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 void Widget::GetAllChildWidgets(gfx::NativeView native_view,
                                 Widgets* children) {
-  internal::NativeWidgetPrivate::GetAllChildWidgets(native_view, children);
+  return ;
 }
 
 // static
 void Widget::GetAllOwnedWidgets(gfx::NativeView native_view,
                                 Widgets* owned) {
-  internal::NativeWidgetPrivate::GetAllOwnedWidgets(native_view, owned);
+  return ;
 }
 
 // static
 void Widget::ReparentNativeView(gfx::NativeView native_view,
                                 gfx::NativeView new_parent) {
-  internal::NativeWidgetPrivate::ReparentNativeView(native_view, new_parent);
+  return ;
 }
 
 // static
@@ -345,13 +343,16 @@ void Widget::Init(InitParams params) {
   root_view_.reset(CreateRootView());
   default_theme_provider_ = std::make_unique<ui::DefaultThemeProvider>();
 
+#if 0
   // Copy the elements of params that will be used after it is moved.
   const InitParams::Type type = params.type;
   const gfx::Rect bounds = params.bounds;
   const ui::WindowShowState show_state = params.show_state;
   WidgetDelegate* delegate = params.delegate;
+#endif
 
   native_widget_->InitNativeWidget(std::move(params));
+#if 0
   if (type == InitParams::TYPE_MENU)
     is_mouse_button_pressed_ = native_widget_->IsMouseButtonDown();
   if (RequiresNonClientView(type)) {
@@ -398,6 +399,7 @@ void Widget::Init(InitParams params) {
 #else
   observer_manager_.Add(GetNativeTheme());
 #endif
+#endif
   native_widget_initialized_ = true;
   native_widget_->OnWidgetInitDone();
 
@@ -1256,91 +1258,6 @@ void Widget::OnKeyEvent(ui::KeyEvent* ev
 //                   RootView from anywhere in Widget. Use
 //                   SendEventToSink() instead. See crbug.com/348087.
 void Widget::OnMouseEvent(ui::MouseEvent* event) {
-  View* root_view = GetRootView();
-  switch (event->type()) {
-    case ui::ET_MOUSE_PRESSED: {
-      last_mouse_event_was_move_ = false;
-
-      // We may get deleted by the time we return from OnMousePressed. So we
-      // use an observer to make sure we are still alive.
-      WidgetDeletionObserver widget_deletion_observer(this);
-
-      gfx::NativeView current_capture =
-          internal::NativeWidgetPrivate::GetGlobalCapture(
-              native_widget_->GetNativeView());
-      // Make sure we're still visible before we attempt capture as the mouse
-      // press processing may have made the window hide (as happens with menus).
-      //
-      // It is possible that capture has changed as a result of a mouse-press.
-      // In these cases do not update internal state.
-      //
-      // A mouse-press may trigger a nested message-loop, and absorb the paired
-      // release. If so the code returns here. So make sure that that
-      // mouse-button is still down before attempting to do a capture.
-      if (root_view && root_view->OnMousePressed(*event) &&
-          widget_deletion_observer.IsWidgetAlive() && IsVisible() &&
-          native_widget_->IsMouseButtonDown() &&
-          current_capture == internal::NativeWidgetPrivate::GetGlobalCapture(
-                                 native_widget_->GetNativeView())) {
-        is_mouse_button_pressed_ = true;
-        if (!native_widget_->HasCapture())
-          native_widget_->SetCapture();
-        event->SetHandled();
-      }
-      return;
-    }
-
-    case ui::ET_MOUSE_RELEASED:
-      last_mouse_event_was_move_ = false;
-      is_mouse_button_pressed_ = false;
-      // Release capture first, to avoid confusion if OnMouseReleased blocks.
-      if (auto_release_capture_ && native_widget_->HasCapture()) {
-        base::AutoReset<bool> resetter(&ignore_capture_loss_, true);
-        native_widget_->ReleaseCapture();
-      }
-      if (root_view)
-        root_view->OnMouseReleased(*event);
-      if ((event->flags() & ui::EF_IS_NON_CLIENT) == 0 &&
-          // If none of the "normal" buttons are pressed, this event may be from
-          // one of the newer mice that have buttons bound to browser forward
-          // back actions. Don't squelch the event and let the default handler
-          // process it.
-          (event->flags() &
-           (ui::EF_LEFT_MOUSE_BUTTON | ui::EF_MIDDLE_MOUSE_BUTTON |
-            ui::EF_RIGHT_MOUSE_BUTTON)) != 0)
-        event->SetHandled();
-      return;
-
-    case ui::ET_MOUSE_MOVED:
-    case ui::ET_MOUSE_DRAGGED:
-      if (native_widget_->HasCapture() && is_mouse_button_pressed_) {
-        last_mouse_event_was_move_ = false;
-        if (root_view)
-          root_view->OnMouseDragged(*event);
-      } else if (!last_mouse_event_was_move_ ||
-                 last_mouse_event_position_ != event->location()) {
-        last_mouse_event_position_ = event->location();
-        last_mouse_event_was_move_ = true;
-        if (root_view)
-          root_view->OnMouseMoved(*event);
-      }
-      return;
-
-    case ui::ET_MOUSE_EXITED:
-      last_mouse_event_was_move_ = false;
-      if (root_view)
-        root_view->OnMouseExited(*event);
-      return;
-
-    case ui::ET_MOUSEWHEEL:
-      if (root_view && root_view->OnMouseWheel(
-          static_cast<const ui::MouseWheelEvent&>(*event)))
-        event->SetHandled();
-      return;
-
-    default:
-      return;
-  }
 }
 
 void Widget::OnMouseCaptureLost() {
--- a/ui/webui/resources/css/roboto.css
+++ b/ui/webui/resources/css/roboto.css
@@ -2,7 +2,7 @@
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file. */
 
-<if expr="not chromeos and not is_android">
+<if expr="is_android or not chromeos and not is_android">
 @font-face {
   font-family: 'Roboto';
   font-style: normal;
--- a/ui/webui/resources/webui_resources.grd
+++ b/ui/webui/resources/webui_resources.grd
@@ -135,12 +135,12 @@ without changes to the corresponding grd
                use_base_dir="false" type="BINDATA" compress="gzip"
                preprocess="true" />
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="cr_components/cr_components_images.grdp" />
         <part file="cr_elements_images.grdp" />
       </if>
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="cr_components/cr_components_resources_v3.grdp" />
         <part file="cr_elements_resources_v3.grdp" />
         <part file="cr_polymer_resources_v3.grdp" />
@@ -462,7 +462,7 @@ without changes to the corresponding grd
                    compress="gzip" />
       </if>
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="cr_components/cr_components_resources.grdp" />
         <part file="cr_elements_resources.grdp" />
         <part file="cr_polymer_resources.grdp" />
--- a/content/browser/devtools/BUILD.gn
+++ b/content/browser/devtools/BUILD.gn
@@ -7,7 +7,7 @@ import("//third_party/protobuf/proto_lib
 import("//tools/grit/grit_rule.gni")
 
 group("resources") {
-  if (!is_android) {
+  if (true || !is_android) {
     public_deps = [ ":devtools_resources" ]
   }
 }

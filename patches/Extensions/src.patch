From: Wengling Chen <feiyu2817@gmail.com>
Date: Sat, 30 May 2020 18:25:38 -0400
Subject: source code fixes for enable_extensions=true

---
 android_webview/browser/aw_browser_context.cc                                                      |    6 
 android_webview/browser/aw_browser_context.h                                                       |    2 
 chrome/android/java/src/org/chromium/chrome/browser/payments/PaymentRequestFactory.java            |    3 
 chrome/android/java/src/org/chromium/chrome/browser/payments/PaymentRequestImpl.java               |   12 
 chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc                   |  188 +++
 chrome/browser/chrome_browser_main_posix.cc                                                        |    2 
 chrome/browser/chrome_content_browser_client.cc                                                    |    3 
 chrome/browser/content_settings/host_content_settings_map_factory.cc                               |    1 
 chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc                     |    8 
 chrome/browser/custom_handlers/register_protocol_handler_permission_request.h                      |    1 
 chrome/browser/devtools/chrome_devtools_manager_delegate.h                                         |    2 
 chrome/browser/devtools/devtools_window.cc                                                         |    1 
 chrome/browser/download/download_commands.cc                                                       |    6 
 chrome/browser/download/download_commands.h                                                        |    4 
 chrome/browser/download/download_ui_model.cc                                                       |    4 
 chrome/browser/download/download_ui_model.h                                                        |    4 
 chrome/browser/download/drag_download_item_android.cc                                              |   32 
 chrome/browser/engagement/important_sites_util.cc                                                  |    5 
 chrome/browser/engagement/important_sites_util.h                                                   |    2 
 chrome/browser/extensions/api/downloads/downloads_api.cc                                           |    1 
 chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc |    5 
 chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc           |   19 
 chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc                          |   13 
 chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc          |   43 
 chrome/browser/extensions/api/tabs/windows_event_router.cc                                         |    2 
 chrome/browser/extensions/extension_system_factory.cc                                              |    3 
 chrome/browser/extensions/global_shortcut_listener_android.cc                                      |   50 +
 chrome/browser/extensions/global_shortcut_listener_android.h                                       |   36 
 chrome/browser/extensions/system_display/display_info_provider_android.cc                          |   17 
 chrome/browser/extensions/system_display/display_info_provider_android.h                           |   24 
 chrome/browser/first_run/first_run_internal_posix.cc                                               |    2 
 chrome/browser/first_run/upgrade_util.h                                                            |    2 
 chrome/browser/hid/hid_chooser_context.cc                                                          |    5 
 chrome/browser/lifetime/application_lifetime.cc                                                    |   22 
 chrome/browser/lifetime/application_lifetime.h                                                     |    4 
 chrome/browser/lifetime/browser_shutdown.cc                                                        |    6 
 chrome/browser/lifetime/browser_shutdown.h                                                         |    4 
 chrome/browser/media/router/media_router.h                                                         |    4 
 chrome/browser/media/router/media_router_base.cc                                                   |    2 
 chrome/browser/media/router/media_router_base.h                                                    |    4 
 chrome/browser/media/router/media_router_feature.cc                                                |    7 
 chrome/browser/media/router/media_router_feature.h                                                 |    3 
 chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc                                    |    9 
 chrome/browser/metrics/thread_watcher.cc                                                           |    8 
 chrome/browser/metrics/thread_watcher.h                                                            |    2 
 chrome/browser/metrics/thread_watcher_report_hang.cc                                               |    2 
 chrome/browser/metrics/thread_watcher_report_hang.h                                                |    2 
 chrome/browser/obsolete_system/obsolete_system_android.cc                                          |   25 
 chrome/browser/performance_manager/graph/policies/policy_features.cc                               |    2 
 chrome/browser/performance_manager/graph/policies/policy_features.h                                |    2 
 chrome/browser/permissions/attestation_permission_request.cc                                       |    7 
 chrome/browser/platform_util.cc                                                                    |   18 
 chrome/browser/platform_util_android.cc                                                            |    6 
 chrome/browser/policy/browser_dm_token_storage_android.cc                                          |  181 +++
 chrome/browser/policy/browser_dm_token_storage_android.h                                           |   55 +
 chrome/browser/policy/chrome_browser_policy_connector.cc                                           |   19 
 chrome/browser/policy/chrome_browser_policy_connector.h                                            |    6 
 chrome/browser/prefs/browser_prefs.cc                                                              |   15 
 chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc                                |   28 
 chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h                                 |    2 
 chrome/browser/profiles/off_the_record_profile_impl.cc                                             |    9 
 chrome/browser/profiles/off_the_record_profile_impl.h                                              |   10 
 chrome/browser/profiles/profile.cc                                                                 |   10 
 chrome/browser/profiles/profile.h                                                                  |    6 
 chrome/browser/profiles/profile_impl.cc                                                            |    5 
 chrome/browser/profiles/profile_impl.h                                                             |    6 
 chrome/browser/profiles/profile_manager.cc                                                         |   21 
 chrome/browser/profiles/profile_manager.h                                                          |    8 
 chrome/browser/profiles/profile_metrics.cc                                                         |    6 
 chrome/browser/profiles/profile_window.cc                                                          |    4 
 chrome/browser/profiles/profile_window.h                                                           |    3 
 chrome/browser/profiles/profiles_state.cc                                                          |    4 
 chrome/browser/profiles/profiles_state.h                                                           |    2 
 chrome/browser/resource_coordinator/resource_coordinator_parts.cc                                  |    4 
 chrome/browser/resource_coordinator/resource_coordinator_parts.h                                   |    8 
 chrome/browser/search/instant_service.h                                                            |    2 
 chrome/browser/search/instant_service_factory.h                                                    |    2 
 chrome/browser/search/instant_service_observer.h                                                   |    2 
 chrome/browser/search/local_ntp_source.h                                                           |    2 
 chrome/browser/search/most_visited_iframe_source.h                                                 |    2 
 chrome/browser/sessions/session_restore.cc                                                         |   25 
 chrome/browser/sharing/shared_clipboard/feature_flags.cc                                           |    2 
 chrome/browser/sharing/shared_clipboard/feature_flags.h                                            |    2 
 chrome/browser/startup_data.cc                                                                     |    5 
 chrome/browser/storage/storage_notification_service_impl.cc                                        |    2 
 chrome/browser/supervised_user/supervised_user_service_factory.cc                                  |    1 
 chrome/browser/sync/profile_sync_service_factory.cc                                                |    2 
 chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc                                              |    6 
 chrome/browser/ui/browser.h                                                                        |    4 
 chrome/browser/ui/browser_commands.cc                                                              |    1 
 chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc                                 |    3 
 chrome/browser/ui/browser_dialogs.cc                                                               |    2 
 chrome/browser/ui/browser_instant_controller.h                                                     |    2 
 chrome/browser/ui/browser_navigator_params.cc                                                      |    2 
 chrome/browser/ui/browser_navigator_params.h                                                       |    6 
 chrome/browser/ui/browser_ui_prefs.cc                                                              |    2 
 chrome/browser/ui/browser_window.h                                                                 |    2 
 chrome/browser/ui/chrome_pages.cc                                                                  |    4 
 chrome/browser/ui/chrome_pages.h                                                                   |    4 
 chrome/browser/ui/content_settings/content_setting_bubble_model.cc                                 |   11 
 chrome/browser/ui/content_settings/content_setting_bubble_model.h                                  |    2 
 chrome/browser/ui/content_settings/content_setting_image_model.cc                                  |    2 
 chrome/browser/ui/native_file_system_dialogs.cc                                                    |    2 
 chrome/browser/ui/native_window_tracker_android.cc                                                 |   26 
 chrome/browser/ui/native_window_tracker_android.h                                                  |   27 
 chrome/browser/ui/passwords/manage_passwords_view_utils.cc                                         |    4 
 chrome/browser/ui/passwords/password_generation_popup_controller_impl.cc                           |    2 
 chrome/browser/ui/passwords/password_generation_popup_controller_impl.h                            |    6 
 chrome/browser/ui/passwords/settings/password_manager_presenter.cc                                 |    6 
 chrome/browser/ui/passwords/settings/password_manager_presenter.h                                  |    2 
 chrome/browser/ui/search/instant_controller.h                                                      |    2 
 chrome/browser/ui/search/ntp_user_data_logger.h                                                    |    2 
 chrome/browser/ui/search/search_ipc_router.h                                                       |    2 
 chrome/browser/ui/search/search_ipc_router_policy_impl.h                                           |    2 
 chrome/browser/ui/search/search_tab_helper.h                                                       |    2 
 chrome/browser/ui/signin_view_controller.h                                                         |    4 
 chrome/browser/ui/tabs/tab_strip_model.h                                                           |    4 
 chrome/browser/ui/views/accelerator_utils_android.cc                                               |   23 
 chrome/browser/ui/views/autofill/payments/save_card_manage_cards_bubble_views.cc                   |   17 
 chrome/browser/ui/views/autofill/payments/save_card_sign_in_promo_bubble_views.cc                  |    2 
 chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc                                          |    9 
 chrome/browser/ui/views/browser_dialogs_views.cc                                                   |    9 
 chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc                                 |    2 
 chrome/browser/ui/views/dropdown_bar_host_android.cc                                               |   11 
 chrome/browser/ui/views/extensions/extension_installed_bubble_view.cc                              |    6 
 chrome/browser/ui/views/frame/browser_frame.cc                                                     |    5 
 chrome/browser/ui/views/frame/browser_view.cc                                                      |    3 
 chrome/browser/ui/views/frame/desktop_browser_frame_android.cc                                     |   76 +
 chrome/browser/ui/views/frame/desktop_browser_frame_android.h                                      |   63 +
 chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc                              |   13 
 chrome/browser/ui/views/intent_picker_bubble_view.cc                                               |    2 
 chrome/browser/ui/views/location_bar/location_bar_view.cc                                          |    2 
 chrome/browser/ui/views/page_action/page_action_icon_controller.cc                                 |   22 
 chrome/browser/ui/views/page_info/page_info_bubble_view.cc                                         |    1 
 chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc                         |    3 
 chrome/browser/ui/views/profiles/profile_menu_view.cc                                              |    9 
 chrome/browser/ui/views/tabs/tab_strip.cc                                                          |   12 
 chrome/browser/ui/views/tabs/window_finder_android.cc                                              |   19 
 chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc                                        |   18 
 chrome/browser/ui/webui/history/foreign_session_handler.cc                                         |    1 
 chrome/browser/ui/webui/omnibox/omnibox_ui.cc                                                      |    4 
 chrome/browser/ui/webui/omnibox/omnibox_ui.h                                                       |    6 
 chrome/browser/ui/webui/settings/printing_handler.cc                                               |    2 
 chrome/browser/ui/webui/settings/settings_ui.cc                                                    |    8 
 chrome/browser/ui/webui/settings/system_handler.cc                                                 |    1 
 chrome/browser/ui/webui/signin/inline_login_handler_impl.cc                                        |   34 
 chrome/browser/ui/webui/signin/login_ui_service.cc                                                 |   11 
 chrome/browser/ui/webui/welcome/welcome_handler.cc                                                 |    3 
 chrome/browser/ui/window_sizer/window_sizer_android.cc                                             |   16 
 chrome/browser/upgrade_detector/get_installed_version_android.cc                                   |   33 
 chrome/browser/web_applications/components/web_app_file_handler_registration.cc                    |    2 
 chrome/browser/web_applications/components/web_app_shortcut_android.cc                             |  116 ++
 chrome/browser/web_applications/components/web_app_shortcut_android.h                              |   62 +
 chrome/browser/web_applications/web_app_provider_factory.cc                                        |    1 
 chrome/common/chrome_features.cc                                                                   |    4 
 chrome/common/chrome_features.h                                                                    |    6 
 chrome/common/chrome_paths.cc                                                                      |    2 
 chrome/common/chrome_paths.h                                                                       |    2 
 chrome/common/chrome_switches.cc                                                                   |    4 
 chrome/common/chrome_switches.h                                                                    |    4 
 chrome/common/importer/firefox_importer_utils.cc                                                   |    4 
 chrome/common/pref_names.cc                                                                        |   21 
 chrome/common/pref_names.h                                                                         |   21 
 chrome/common/webui_url_constants.cc                                                               |    2 
 chrome/common/webui_url_constants.h                                                                |    2 
 chromecast/browser/cast_browser_context.cc                                                         |    2 
 chromecast/browser/cast_browser_context.h                                                          |    2 
 components/bookmarks/browser/bookmark_node_data.h                                                  |    8 
 components/feature_engagement/public/event_constants.cc                                            |    2 
 components/feature_engagement/public/event_constants.h                                             |    2 
 components/feature_engagement/public/feature_constants.cc                                          |    2 
 components/feature_engagement/public/feature_constants.h                                           |    2 
 components/omnibox/browser/autocomplete_match.cc                                                   |    4 
 components/omnibox/browser/autocomplete_match.h                                                    |    2 
 components/omnibox/browser/omnibox_pedal.cc                                                        |    4 
 components/omnibox/browser/omnibox_pedal.h                                                         |    4 
 components/omnibox/browser/omnibox_pedal_implementations.cc                                        |    4 
 components/omnibox/browser/omnibox_pedal_implementations.h                                         |    2 
 components/omnibox/browser/omnibox_popup_model.cc                                                  |    4 
 components/omnibox/browser/omnibox_popup_model.h                                                   |    2 
 components/page_info/page_info_ui.cc                                                               |    8 
 components/page_info/page_info_ui.h                                                                |    3 
 components/policy/resources/policy_templates.json                                                  |    8 
 components/search/search.cc                                                                        |    2 
 components/ui_devtools/views/overlay_agent_views.cc                                                |   34 
 components/url_formatter/elide_url.cc                                                              |    4 
 components/url_formatter/elide_url.h                                                               |    2 
 content/browser/renderer_host/native_web_keyboard_event_android.cc                                 |    2 
 content/browser/storage_partition_impl.cc                                                          |    4 
 content/browser/storage_partition_impl.h                                                           |    6 
 content/browser/web_contents/web_contents_impl.cc                                                  |    3 
 content/browser/web_contents/web_contents_impl.h                                                   |    2 
 content/public/browser/browser_context.h                                                           |    4 
 content/public/browser/content_browser_client.cc                                                   |    2 
 content/public/browser/content_browser_client.h                                                    |    2 
 content/public/browser/desktop_media_id.cc                                                         |    6 
 content/public/browser/desktop_media_id.h                                                          |    2 
 content/public/browser/native_web_keyboard_event.h                                                 |    1 
 content/public/browser/storage_partition.h                                                         |    4 
 content/shell/browser/shell_browser_context.cc                                                     |    2 
 content/shell/browser/shell_browser_context.h                                                      |    4 
 extensions/browser/api/device_permissions_prompt.cc                                                |    2 
 extensions/browser/api/hid/hid_device_manager.cc                                                   |    2 
 extensions/browser/api/system_cpu/cpu_info_provider_android.cc                                     |   77 +
 extensions/browser/guest_view/web_view/web_view_guest.cc                                           |    1 
 extensions/renderer/bindings/api_binding_util.cc                                                   |    2 
 services/network/network_context.cc                                                                |    1 
 third_party/blink/public/mojom/payments/payment_request.mojom                                      |    3 
 third_party/blink/renderer/modules/payments/payment_request.cc                                     |    2 
 third_party/skia/src/gpu/ops/GrSimpleMeshDrawOpHelper.cpp                                          |    1 
 tools/grit/grit/tool/build.py                                                                      |    2 
 ui/android/java/src/org/chromium/ui/base/SelectFileDialog.java                                     |  114 ++
 ui/android/window_android.cc                                                                       |   28 
 ui/android/window_android.h                                                                        |   17 
 ui/base/dragdrop/os_exchange_data.h                                                                |    8 
 ui/base/dragdrop/os_exchange_data_provider_android.cc                                              |  220 ++++
 ui/base/dragdrop/os_exchange_data_provider_android.h                                               |  101 ++
 ui/base/dragdrop/os_exchange_data_provider_factory.cc                                              |    4 
 ui/events/event.h                                                                                  |    1 
 ui/native_theme/native_theme_android.cc                                                            |    3 
 ui/native_theme/native_theme_android.h                                                             |    2 
 ui/shell_dialogs/select_file_dialog_android.cc                                                     |    6 
 ui/views/controls/menu/menu_config_android.cc                                                      |   11 
 ui/views/controls/menu/menu_controller.h                                                           |    1 
 ui/views/controls/menu/menu_host.cc                                                                |    8 
 ui/views/controls/menu/menu_host.h                                                                 |    2 
 ui/views/controls/menu/menu_pre_target_handler_android.cc                                          |   48 
 ui/views/controls/menu/menu_pre_target_handler_android.h                                           |   44 
 ui/views/controls/native/native_view_host_android.cc                                               |  122 ++
 ui/views/controls/native/native_view_host_android.h                                                |   98 +
 ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc                              |    2 
 ui/views/drag_utils_android.cc                                                                     |   18 
 ui/views/event_monitor_android.cc                                                                  |   76 +
 ui/views/event_monitor_android.h                                                                   |   41 
 ui/views/metrics_android.cc                                                                        |   20 
 ui/views/native_cursor_android.cc                                                                  |   31 
 ui/views/painter.cc                                                                                |    1 
 ui/views/touchui/touch_selection_controller_impl.cc                                                |   43 
 ui/views/views_touch_selection_controller_factory_android.cc                                       |   21 
 ui/views/widget/native_widget_android.cc                                                           |  496 ++++++++++
 ui/views/widget/native_widget_android.h                                                            |  194 +++
 ui/views/widget/tooltip_manager_android.cc                                                         |   72 +
 ui/views/widget/tooltip_manager_android.h                                                          |   65 +
 ui/views/widget/widget.cc                                                                          |    5 
 weblayer/browser/browser_context_impl.cc                                                           |    2 
 weblayer/browser/browser_context_impl.h                                                            |    2 
 246 files changed, 3384 insertions(+), 740 deletions(-)

--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
@@ -0,0 +1,116 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/components/web_app_shortcut_android.h"
+
+#include <fcntl.h>
+
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/i18n/file_util_icu.h"
+#include "base/nix/xdg_util.h"
+#include "base/path_service.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/shell_integration.h"
+#include "chrome/browser/web_applications/components/web_app_helpers.h"
+#include "chrome/browser/web_applications/components/web_app_shortcut.h"
+#include "chrome/common/buildflags.h"
+#include "chrome/common/chrome_constants.h"
+
+namespace {
+
+}  // namespace
+
+namespace web_app {
+
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id) {
+  DCHECK(!app_id.empty());
+
+  // Use a prefix, because xdg-desktop-menu requires it.
+  std::string filename(chrome::kBrowserProcessExecutableName);
+  filename.append("-").append(app_id).append("-").append(
+      profile_path.BaseName().value());
+  base::i18n::ReplaceIllegalCharactersInPath(&filename, '_');
+  // Spaces in filenames break xdg-desktop-menu
+  // (see https://bugs.freedesktop.org/show_bug.cgi?id=66605).
+  base::ReplaceChars(filename, " ", "_", &filename);
+  return base::FilePath(filename.append(".desktop"));
+}
+
+void DeleteShortcutOnDesktop(const base::FilePath& shortcut_filename) {
+}
+
+void DeleteShortcutInApplicationsMenu(
+    const base::FilePath& shortcut_filename,
+    const base::FilePath& directory_filename) {
+}
+
+bool CreateDesktopShortcut(
+    const web_app::ShortcutInfo& shortcut_info,
+    const web_app::ShortcutLocations& creation_locations) {
+  return false;
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id) {
+  base::FilePath desktop_path;
+  // If Get returns false, just leave desktop_path empty.
+  base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path);
+  return GetExistingShortcutLocations(env, profile_path, extension_id,
+                                      desktop_path);
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  web_app::ShortcutLocations locations;
+  return locations;
+}
+
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id) {
+}
+
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.h
@@ -0,0 +1,62 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+
+#include <string>
+
+namespace base {
+class FilePath;
+class Environment;
+}  // namespace base
+
+namespace web_app {
+
+struct ShortcutInfo;
+struct ShortcutLocations;
+
+// Create shortcuts on the desktop or in the application menu (as specified by
+// |shortcut_info|), for the web page or extension in |shortcut_info|.
+// For extensions, duplicate shortcuts are avoided, so if a requested shortcut
+// already exists it is deleted first.
+bool CreateDesktopShortcut(const ShortcutInfo& shortcut_info,
+                           const ShortcutLocations& creation_locations);
+
+// Returns filename for .desktop file based on |profile_path| and
+// |app_id|, sanitized for security.
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id);
+
+// Returns the set of locations in which shortcuts are installed for the
+// extension with |extension_id| in |profile_path|.
+// This searches the file system for .desktop files in appropriate locations. A
+// shortcut with NoDisplay=true causes hidden to become true, instead of
+// creating at APP_MENU_LOCATIONS_SUBDIR_CHROMEAPPS.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id);
+
+// Version of GetExistingShortcutLocations which takes an explicit path
+// to the user's desktop directory. Useful for testing.
+// If |desktop_path| is empty, the desktop is not searched.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// been added for the extension with |extension_id| in |profile_path|.
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// for the profile in |profile_path|.
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path);
+
+}  // namespace web_app
+
+#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/dragdrop/file_info/file_info.h"
+
+namespace ui {
+
+OSExchangeDataProviderAndroid::OSExchangeDataProviderAndroid()
+    : formats_(0) {
+}
+
+OSExchangeDataProviderAndroid::~OSExchangeDataProviderAndroid() = default;
+
+std::unique_ptr<OSExchangeData::Provider>
+OSExchangeDataProviderAndroid::Clone() const {
+  OSExchangeDataProviderAndroid* ret = new OSExchangeDataProviderAndroid();
+  ret->formats_ = formats_;
+  ret->string_ = string_;
+  ret->url_ = url_;
+  ret->title_ = title_;
+  ret->filenames_ = filenames_;
+  ret->pickle_data_ = pickle_data_;
+  // We skip copying the drag images.
+  ret->html_ = html_;
+  ret->base_url_ = base_url_;
+
+  return base::WrapUnique<OSExchangeData::Provider>(ret);
+}
+
+void OSExchangeDataProviderAndroid::MarkOriginatedFromRenderer() {
+  // TODO(dcheng): Currently unneeded because ChromeOS Android correctly separates
+  // URL and filename metadata, and does not implement the DownloadURL protocol.
+}
+
+bool OSExchangeDataProviderAndroid::DidOriginateFromRenderer() const {
+  return false;
+}
+
+void OSExchangeDataProviderAndroid::SetString(const base::string16& data) {
+  if (HasString())
+    return;
+
+  string_ = data;
+  formats_ |= OSExchangeData::STRING;
+}
+
+void OSExchangeDataProviderAndroid::SetURL(const GURL& url,
+                                        const base::string16& title) {
+  url_ = url;
+  title_ = title;
+  formats_ |= OSExchangeData::URL;
+
+  SetString(base::UTF8ToUTF16(url.spec()));
+}
+
+void OSExchangeDataProviderAndroid::SetFilename(const base::FilePath& path) {
+  filenames_.clear();
+  filenames_.push_back(FileInfo(path, base::FilePath()));
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  filenames_ = filenames;
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetPickledData(
+    const ClipboardFormatType& format,
+    const base::Pickle& data) {
+  pickle_data_[format] = data;
+  formats_ |= OSExchangeData::PICKLED_DATA;
+}
+
+bool OSExchangeDataProviderAndroid::GetString(base::string16* data) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+  *data = string_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  if ((formats_ & OSExchangeData::URL) == 0) {
+    title->clear();
+    return GetPlainTextURL(url) ||
+           (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(url));
+  }
+
+  if (!url_.is_valid())
+    return false;
+
+  *url = url_;
+  *title = title_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilename(base::FilePath* path) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  DCHECK(!filenames_.empty());
+  *path = filenames_[0].path;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  *filenames = filenames_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPickledData(
+    const ClipboardFormatType& format,
+    base::Pickle* data) const {
+  PickleData::const_iterator i = pickle_data_.find(format);
+  if (i == pickle_data_.end())
+    return false;
+
+  *data = i->second;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasString() const {
+  return (formats_ & OSExchangeData::STRING) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  if ((formats_ & OSExchangeData::URL) != 0) {
+    return true;
+  }
+  // No URL, see if we have plain text that can be parsed as a URL.
+  return GetPlainTextURL(NULL) ||
+         (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(nullptr));
+}
+
+bool OSExchangeDataProviderAndroid::HasFile() const {
+  return (formats_ & OSExchangeData::FILE_NAME) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasCustomFormat(
+    const ClipboardFormatType& format) const {
+  return pickle_data_.find(format) != pickle_data_.end();
+}
+
+void OSExchangeDataProviderAndroid::SetHtml(const base::string16& html,
+                                         const GURL& base_url) {
+  formats_ |= OSExchangeData::HTML;
+  html_ = html;
+  base_url_ = base_url;
+}
+
+bool OSExchangeDataProviderAndroid::GetHtml(base::string16* html,
+                                         GURL* base_url) const {
+  if ((formats_ & OSExchangeData::HTML) == 0)
+    return false;
+  *html = html_;
+  *base_url = base_url_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasHtml() const {
+  return ((formats_ & OSExchangeData::HTML) != 0);
+}
+
+void OSExchangeDataProviderAndroid::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAndroid::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAndroid::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAndroid::GetFileURL(GURL* url) const {
+  base::FilePath file_path;
+  if (!GetFilename(&file_path))
+    return false;
+
+  GURL test_url = net::FilePathToFileURL(file_path);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPlainTextURL(GURL* url) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+
+  GURL test_url(string_);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.h
@@ -0,0 +1,101 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+class ClipboardFormatType;
+
+// OSExchangeData::Provider implementation for Android on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAndroid
+    : public OSExchangeData::Provider {
+ public:
+  OSExchangeDataProviderAndroid();
+  ~OSExchangeDataProviderAndroid() override;
+
+  // Overridden from OSExchangeData::Provider:
+  std::unique_ptr<Provider> Clone() const override;
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const ClipboardFormatType& format,
+                      const base::Pickle& data) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const ClipboardFormatType& format,
+                      base::Pickle* data) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ private:
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a file format and the file name can be
+  // parsed as a URL.
+  bool GetFileURL(GURL* url) const;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Actual formats that have been set. See comment above |known_formats_|
+  // for details.
+  int formats_;
+
+  // String contents.
+  base::string16 string_;
+
+  // URL contents.
+  GURL url_;
+  base::string16 title_;
+
+  // File name.
+  std::vector<FileInfo> filenames_;
+
+  // PICKLED_DATA contents.
+  PickleData pickle_data_;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // For HTML format
+  base::string16 html_;
+  GURL base_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAndroid);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -16,6 +16,8 @@
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #endif
 
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
 namespace ui {
 
 //static
@@ -33,6 +35,8 @@ OSExchangeDataProviderFactory::CreatePro
   // TODO(crbug.com/980371): Implement OSExchangeDataProvider for Fuchsia.
   NOTIMPLEMENTED();
   return nullptr;
+#elif defined(OS_ANDROID)
+  return std::make_unique<OSExchangeDataProviderAndroid>();
 #else
 #error "Unknown operating system"
 #endif
--- a/chrome/browser/media/router/media_router_base.cc
+++ b/chrome/browser/media/router/media_router_base.cc
@@ -88,12 +88,10 @@ MediaRouterBase::GetFlingingController(c
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
 void MediaRouterBase::GetMediaController(
     const MediaRoute::Id& route_id,
     mojo::PendingReceiver<mojom::MediaController> controller,
     mojo::PendingRemote<mojom::MediaStatusObserver> observer) {}
-#endif  // !defined(OS_ANDROID)
 
 MediaRouterBase::MediaRouterBase() : initialized_(false) {}
 
--- a/chrome/browser/media/router/media_router_base.h
+++ b/chrome/browser/media/router/media_router_base.h
@@ -19,11 +19,9 @@
 #include "chrome/common/media_router/media_route.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
-#endif  // !defined(OS_ANDROID)
 
 namespace media_router {
 
@@ -42,12 +40,10 @@ class MediaRouterBase : public MediaRout
   std::vector<MediaRoute> GetCurrentRoutes() const override;
   std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) override;
-#if !defined(OS_ANDROID)
   void GetMediaController(
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
       mojo::PendingRemote<mojom::MediaStatusObserver> observer) override;
-#endif  // !defined(OS_ANDROID)
   void RegisterRemotingSource(SessionID tab_id,
                               CastRemotingConnector* remoting_source) override;
   void UnregisterRemotingSource(SessionID tab_id) override;
--- a/chrome/browser/media/router/media_router.h
+++ b/chrome/browser/media/router/media_router.h
@@ -28,11 +28,9 @@
 #include "media/base/flinging_controller.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
-#endif  // !defined(OS_ANDROID)
 
 namespace content {
 class WebContents;
@@ -183,7 +181,6 @@ class MediaRouter : public KeyedService
   virtual std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) = 0;
 
-#if !defined(OS_ANDROID)
   // Binds |controller| for sending media commands to a route. The controller
   // will notify |observer| whenever there is a change to the status of the
   // media. It may invalidate bindings from previous calls to this method.
@@ -191,7 +188,6 @@ class MediaRouter : public KeyedService
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
       mojo::PendingRemote<mojom::MediaStatusObserver> observer) = 0;
-#endif  // !defined(OS_ANDROID)
 
   // Registers/Unregisters a CastRemotingConnector with the |tab_id|. For a
   // given |tab_id|, only one CastRemotingConnector can be registered. The
--- a/chrome/browser/media/router/media_router_feature.cc
+++ b/chrome/browser/media/router/media_router_feature.cc
@@ -22,13 +22,10 @@
 #include "components/user_prefs/user_prefs.h"
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
 #include "components/prefs/pref_registry_simple.h"
-#endif
 
 namespace media_router {
 
-#if !defined(OS_ANDROID)
 // Controls if browser side DialMediaRouteProvider is enabled.
 const base::Feature kDialMediaRouteProvider{"DialMediaRouteProvider",
                                             base::FEATURE_ENABLED_BY_DEFAULT};
@@ -36,7 +33,6 @@ const base::Feature kCastMediaRouteProvi
                                             base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kCastAllowAllIPsFeature{"CastAllowAllIPs",
                                             base::FEATURE_DISABLED_BY_DEFAULT};
-#endif
 
 #if defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 namespace {
@@ -66,7 +62,6 @@ bool MediaRouterEnabled(content::Browser
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 }
 
-#if !defined(OS_ANDROID)
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kMediaRouterCastAllowAllIPs, false,
                                 PrefRegistry::PUBLIC);
@@ -113,6 +108,4 @@ bool CastMediaRouteProviderEnabled() {
   return base::FeatureList::IsEnabled(kCastMediaRouteProvider);
 }
 
-#endif  // !defined(OS_ANDROID)
-
 }  // namespace media_router
--- a/chrome/browser/media/router/media_router_feature.h
+++ b/chrome/browser/media/router/media_router_feature.h
@@ -19,8 +19,6 @@ namespace media_router {
 // Returns true if Media Router is enabled for |context|.
 bool MediaRouterEnabled(content::BrowserContext* context);
 
-#if !defined(OS_ANDROID)
-
 // TODO(crbug.com/1028753): Remove default-enabled kDialMediaRouteProvider after
 // tests stop disabling it.
 extern const base::Feature kDialMediaRouteProvider;
@@ -62,7 +60,6 @@ bool DialMediaRouteProviderEnabled();
 // Returns true if browser side Cast Media Route Provider and sink query are
 // enabled.
 bool CastMediaRouteProviderEnabled();
-#endif  // !defined(OS_ANDROID)
 
 }  // namespace media_router
 
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -56,10 +56,6 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class BackgroundContents;
 class BrowserContentSettingBubbleModelDelegate;
 class BrowserInstantController;
--- a/chrome/browser/ui/signin_view_controller.h
+++ b/chrome/browser/ui/signin_view_controller.h
@@ -17,10 +17,6 @@
 #include "chrome/browser/ui/webui/signin/signin_email_confirmation_dialog.h"
 #endif
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 class SigninViewControllerDelegate;
 struct CoreAccountId;
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -31,10 +31,6 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/page_transition_types.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Profile;
 class TabGroupModel;
 class TabStripModelDelegate;
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -145,6 +145,7 @@ static std::string TerminationStatusToSt
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM:
       return "oom killed";
 #endif
+    case base::TERMINATION_STATUS_OOM_PROTECTED:
     case base::TERMINATION_STATUS_OOM:
       return "oom";
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
--- a/extensions/browser/api/device_permissions_prompt.cc
+++ b/extensions/browser/api/device_permissions_prompt.cc
@@ -221,8 +221,6 @@ class HidDevicePermissionsPrompt : publi
     const auto& binder = GetHidManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
-    else
-      content::GetDeviceService().BindHidManager(std::move(receiver));
 
     hid_manager_->GetDevicesAndSetClient(
         receiver_.BindNewEndpointAndPassRemote(),
--- a/extensions/browser/api/hid/hid_device_manager.cc
+++ b/extensions/browser/api/hid/hid_device_manager.cc
@@ -296,8 +296,6 @@ void HidDeviceManager::LazyInitialize()
     const auto& binder = GetHidManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
-    else
-      content::GetDeviceService().BindHidManager(std::move(receiver));
   }
   // Enumerate HID devices and set client.
   std::vector<device::mojom::HidDeviceInfoPtr> empty_devices;
--- a/ui/base/dragdrop/os_exchange_data.h
+++ b/ui/base/dragdrop/os_exchange_data.h
@@ -63,7 +63,7 @@ class UI_BASE_EXPORT OSExchangeData {
 #if defined(OS_WIN)
     FILE_CONTENTS  = 1 << 4,
 #endif
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
     HTML           = 1 << 5,
 #endif
   };
@@ -138,13 +138,13 @@ class UI_BASE_EXPORT OSExchangeData {
     virtual void SetDownloadFileInfo(DownloadFileInfo* download) = 0;
 #endif
 
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
     virtual void SetHtml(const base::string16& html, const GURL& base_url) = 0;
     virtual bool GetHtml(base::string16* html, GURL* base_url) const = 0;
     virtual bool HasHtml() const = 0;
 #endif
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || defined(OS_ANDROID)
     virtual void SetDragImage(const gfx::ImageSkia& image,
                               const gfx::Vector2d& cursor_offset) = 0;
     virtual gfx::ImageSkia GetDragImage() const = 0;
@@ -269,7 +269,7 @@ class UI_BASE_EXPORT OSExchangeData {
   void SetDownloadFileInfo(DownloadFileInfo* download);
 #endif
 
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
   // Adds a snippet of HTML.  |html| is just raw html but this sets both
   // text/html and CF_HTML.
   void SetHtml(const base::string16& html, const GURL& base_url);
--- a/ui/views/controls/menu/menu_host.cc
+++ b/ui/views/controls/menu/menu_host.cc
@@ -30,7 +30,7 @@ namespace views {
 
 namespace internal {
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
 // This class adds itself as the pre target handler for the |window|
 // passed in. It currently handles touch events and forwards them to the
 // controller. Reason for this approach is views does not get raw touch
@@ -80,7 +80,7 @@ class PreMenuEventDispatchHandler : publ
 #endif  // OS_MACOSX
 
 void TransferGesture(Widget* source, Widget* target) {
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_ANDROID)
   NOTIMPLEMENTED();
 #else   // !defined(OS_MACOSX)
   source->GetGestureRecognizer()->TransferEventsTo(
@@ -136,7 +136,7 @@ void MenuHost::InitMenuHost(Widget* pare
 #endif
   Init(std::move(params));
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
   pre_dispatch_handler_ =
       std::make_unique<internal::PreMenuEventDispatchHandler>(
           menu_controller, submenu_, GetNativeView());
@@ -201,7 +201,7 @@ void MenuHost::DestroyMenuHost() {
   HideMenuHost();
   destroying_ = true;
   static_cast<MenuHostRootView*>(GetRootView())->ClearSubmenu();
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
   pre_dispatch_handler_.reset();
 #endif
   Close();
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -19,6 +19,7 @@
 #include "base/strings/string16.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event_constants.h"
 #include "ui/events/gesture_event_details.h"
 #include "ui/events/gestures/gesture_types.h"
--- a/ui/views/controls/menu/menu_controller.h
+++ b/ui/views/controls/menu/menu_controller.h
@@ -18,6 +18,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/timer/timer.h"
 #include "build/build_config.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event.h"
 #include "ui/events/event_constants.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
--- a/ui/views/controls/menu/menu_host.h
+++ b/ui/views/controls/menu/menu_host.h
@@ -95,7 +95,7 @@ class MenuHost : public Widget, public W
   // If true and capture is lost we don't notify the delegate.
   bool ignore_capture_lost_;
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
   // Handles raw touch events at the moment.
   std::unique_ptr<internal::PreMenuEventDispatchHandler> pre_dispatch_handler_;
 #endif
--- a/ui/android/window_android.h
+++ b/ui/android/window_android.h
@@ -17,6 +17,7 @@
 #include "base/time/time.h"
 #include "ui/android/ui_android_export.h"
 #include "ui/android/view_android.h"
+#include "ui/events/event_target.h"
 #include "ui/gfx/geometry/vector2d_f.h"
 
 namespace display {
@@ -33,7 +34,8 @@ class WindowAndroidObserver;
 
 // Android implementation of the activity window.
 // WindowAndroid is also the root of a ViewAndroid tree.
-class UI_ANDROID_EXPORT WindowAndroid : public ViewAndroid {
+class UI_ANDROID_EXPORT WindowAndroid : public ViewAndroid,
+                           public ui::EventTarget {
  public:
   static WindowAndroid* FromJavaWindowAndroid(
       const base::android::JavaParamRef<jobject>& jwindow_android);
@@ -50,6 +52,13 @@ class UI_ANDROID_EXPORT WindowAndroid :
 
   base::android::ScopedJavaLocalRef<jobject> GetJavaObject();
 
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::PointF* point);
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::Point* point);
+
   // Compositor callback relay.
   void OnCompositingDidCommit();
 
@@ -142,6 +151,12 @@ class UI_ANDROID_EXPORT WindowAndroid :
   // ViewAndroid overrides.
   WindowAndroid* GetWindowAndroid() const override;
 
+  // Overridden from ui::EventTarget:
+  bool CanAcceptEvent(const ui::Event& event) override;
+  EventTarget* GetParentTarget() override;
+  std::unique_ptr<ui::EventTargetIterator> GetChildIterator() const override;
+  ui::EventTargeter* GetEventTargeter() override;
+
   // The ID of the display that this window belongs to.
   int display_id() const { return display_id_; }
 
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -427,7 +427,7 @@
 #include "chrome/browser/chrome_browser_main_posix.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/badging/badge_manager.h"
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
@@ -1232,7 +1232,6 @@ ChromeContentBrowserClient::CreateBrowse
 #if defined(TOOLKIT_VIEWS)
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS)
   main_parts->AddParts(new ChromeBrowserMainExtraPartsViewsLinux());
-#else
   main_parts->AddParts(new ChromeBrowserMainExtraPartsViews());
 #endif
 #endif
--- a/chrome/browser/devtools/chrome_devtools_manager_delegate.h
+++ b/chrome/browser/devtools/chrome_devtools_manager_delegate.h
@@ -13,8 +13,6 @@
 #include "base/compiler_specific.h"
 #include "base/macros.h"
 #include "chrome/browser/devtools/device/devtools_device_discovery.h"
-#include "chrome/browser/devtools/protocol/forward.h"
-#include "chrome/browser/devtools/protocol/protocol.h"
 #include "content/public/browser/devtools_agent_host_observer.h"
 #include "content/public/browser/devtools_manager_delegate.h"
 #include "net/base/host_port_pair.h"
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -33,7 +33,7 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/instant_service_factory.h
+++ b/chrome/browser/search/instant_service_factory.h
@@ -10,7 +10,7 @@
 #include "build/build_config.h"
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -31,7 +31,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "url/origin.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
 
--- a/chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc
+++ b/chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc
@@ -136,19 +136,6 @@ bool NativeMessagingHostManifest::Parse(
     allowed_origins_.AddPattern(pattern);
   }
 
-  if (base::FeatureList::IsEnabled(features::kOnConnectNative)) {
-    if (const base::Value* supports_native_initiated_connections =
-            dictionary->FindKey("supports_native_initiated_connections")) {
-      if (!supports_native_initiated_connections->is_bool()) {
-        *error_message =
-            "supports_native_initiated_connections must be a boolean.";
-        return false;
-      }
-      supports_native_initiated_connections_ =
-          supports_native_initiated_connections->GetBool();
-    }
-  }
-
   return true;
 }
 
--- a/chrome/browser/extensions/api/downloads/downloads_api.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api.cc
@@ -52,6 +52,7 @@
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "chrome/common/extensions/api/downloads.h"
 #include "components/download/public/common/download_interrupt_reasons.h"
 #include "components/download/public/common/download_item.h"
--- a/chrome/browser/profiles/profile.cc
+++ b/chrome/browser/profiles/profile.cc
@@ -42,8 +42,8 @@
 #include "chromeos/constants/chromeos_switches.h"
 #endif
 
-#if !defined(OS_ANDROID)
-#include "chrome/browser/first_run/first_run.h"
+#if defined(OS_ANDROID)
+//#include "chrome/browser/first_run/first_run.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
 
@@ -163,7 +163,7 @@ TestingProfile* Profile::AsTestingProfil
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 ChromeZoomLevelPrefs* Profile::GetZoomLevelPrefs() {
   return nullptr;
 }
@@ -220,7 +220,7 @@ void Profile::RegisterProfilePrefs(user_
                                std::string());
   registry->RegisterBooleanPref(prefs::kLiveCaptionEnabled, false);
   registry->RegisterFilePathPref(prefs::kSODAPath, base::FilePath());
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   registry->RegisterDictionaryPref(prefs::kPartitionDefaultZoomLevel);
   registry->RegisterDictionaryPref(prefs::kPartitionPerHostZoomLevels);
 #endif  // !defined(OS_ANDROID)
@@ -384,7 +384,7 @@ bool ProfileCompare::operator()(Profile*
   return a->GetOriginalProfile() < b->GetOriginalProfile();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 double Profile::GetDefaultZoomLevelForProfile() {
   return GetDefaultStoragePartition(this)
       ->GetHostZoomMap()
--- a/chrome/browser/profiles/profile.h
+++ b/chrome/browser/profiles/profile.h
@@ -21,7 +21,7 @@
 #include "services/network/public/mojom/network_context.mojom-forward.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class ChromeZoomLevelPrefs;
 #endif
 
@@ -213,7 +213,7 @@ class Profile : public content::BrowserC
   virtual PrefService* GetPrefs() = 0;
   virtual const PrefService* GetPrefs() const = 0;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Retrieves a pointer to the PrefService that manages the default zoom
   // level and the per-host zoom levels for this user profile.
   // TODO(wjmaclean): Remove this when HostZoomMap migrates to StoragePartition.
@@ -412,7 +412,7 @@ class Profile : public content::BrowserC
   // correctly assigned to its owner.
   Profile* CreateOffTheRecordProfile();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Convenience method to retrieve the default zoom level for the default
   // storage partition.
   double GetDefaultZoomLevelForProfile();
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -21,7 +21,7 @@ using content::GlobalRequestID;
 using content::NavigationController;
 using content::WebContents;
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
 #else
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -25,7 +25,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "components/tab_groups/tab_group_id.h"
 #endif
@@ -63,7 +63,7 @@ struct OpenURLParams;
 
 // TODO(thestig): Split or ifdef out more fields that are not used on Android.
 struct NavigateParams {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
 #else
@@ -215,7 +215,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // [in]  Specifies a Browser object where the navigation could occur or the
   //       tab could be added. Navigate() is not obliged to use this Browser if
   //       it is not compatible with the operation being performed. This can be
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -444,24 +444,9 @@ void SafeBrowsingPrivateEventRouter::OnS
               triggered_rule.SetIntKey(kKeyTriggeredRuleId, rule.rule_id());
               triggered_rule.SetStringKey(kKeyTriggeredRuleName,
                                           rule.rule_name());
-              triggered_rule.SetStringKey(kKeyTriggeredRuleResourceName,
-                                          rule.rule_resource_name());
-              triggered_rule.SetStringKey(kKeyTriggeredRuleSeverity,
-                                          rule.rule_severity());
               triggered_rule.SetIntKey(kKeyTriggeredRuleAction, rule.action());
 
               base::ListValue matched_detectors;
-              for (const auto& detector : rule.matched_detectors()) {
-                base::Value matched_detector(base::Value::Type::DICTIONARY);
-                matched_detector.SetStringKey(kKeyMatchedDetectorId,
-                                              detector.detector_id());
-                matched_detector.SetStringKey(kKeyMatchedDetectorName,
-                                              detector.display_name());
-                matched_detector.SetStringKey(kKeyMatchedDetectorType,
-                                              detector.detector_type());
-
-                matched_detectors.Append(std::move(matched_detector));
-              }
               triggered_rule.SetKey(kKeyMatchedDetectors,
                                     std::move(matched_detectors));
 
@@ -482,35 +467,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     const std::string& mime_type,
     const std::string& trigger,
     const int64_t content_size) {
-  if (!IsRealtimeReportingEnabled())
     return;
-
-  ReportRealtimeEvent(
-      kKeySensitiveDataEvent,
-      base::BindOnce(
-          [](const std::string& url, const std::string& file_name,
-             const std::string& download_digest_sha256,
-             const std::string& profile_user_name, const std::string& mime_type,
-             const std::string& trigger, const int64_t content_size) {
-            // Create a real-time event dictionary from the arguments and
-            // report it.
-            base::Value event(base::Value::Type::DICTIONARY);
-            event.SetStringKey(kKeyUrl, url);
-            event.SetStringKey(kKeyFileName, file_name);
-            event.SetStringKey(kKeyDownloadDigestSha256,
-                               download_digest_sha256);
-            event.SetStringKey(kKeyProfileUserName, profile_user_name);
-            event.SetStringKey(kKeyContentType, mime_type);
-            // |content_size| can be set to -1 to indicate an unknown size, in
-            // which case the field is not set.
-            if (content_size >= 0)
-              event.SetIntKey(kKeyContentSize, content_size);
-            event.SetStringKey(kKeyTrigger, trigger);
-            event.SetBoolKey(kKeyClickedThrough, true);
-            return event;
-          },
-          url.spec(), file_name, download_digest_sha256, GetProfileUserName(),
-          mime_type, trigger, content_size));
 }
 
 void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -1090,7 +1090,7 @@ const char kSpeechRecognitionFilterProfa
 // permitted.
 const char kAllowDeletingBrowserHistory[] = "history.deleting_enabled";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Whether the "Click here to clear your browsing data" tooltip promo has been
 // shown on the History page.
 const char kHistoryMenuPromoShown[] = "history.menu_promo_shown";
@@ -1254,7 +1254,7 @@ const char kContentSettingsPluginWhiteli
     "profile.content_settings.plugin_whitelist";
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Double that indicates the default zoom level.
 const char kPartitionDefaultZoomLevel[] = "partition.default_zoom_level";
 
@@ -1550,7 +1550,7 @@ const char kWebRtcEventLogCollectionAllo
 // in ICE candidates.
 const char kWebRtcLocalIpsAllowedUrls[] = "webrtc.local_ips_allowed_urls";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Whether or not this profile has been shown the Welcome page.
 const char kHasSeenWelcomePage[] = "browser.has_seen_welcome_page";
 #endif
@@ -1753,7 +1753,7 @@ const char kShutdownNumProcessesSlow[] =
 // before shutting everything down.
 const char kRestartLastSessionOnShutdown[] = "restart.last.session.on.shutdown";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 // Pref name for the policy controlling presentation of full-tab promotional
 // and/or educational content.
@@ -1796,7 +1796,6 @@ const char kNtpCollapsedSnapshotDocument
 
 // Keeps track of sync promo collapsed state in the Other Devices menu.
 const char kNtpCollapsedSyncPromo[] = "ntp.collapsed_sync_promo";
-#else
 // Holds info for New Tab Page custom background
 const char kNtpCustomBackgroundDict[] = "ntp.custom_background_dict";
 const char kNtpCustomBackgroundLocalToDevice[] =
@@ -1863,7 +1862,7 @@ const char kDevToolsTCPDiscoveryConfig[]
 // A dictionary with generic DevTools settings.
 const char kDevToolsPreferences[] = "devtools.preferences";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Tracks the number of times the dice signin promo has been shown in the user
 // menu.
 const char kDiceSigninUserMenuPromoCount[] = "sync_promo.user_menu_show_count";
@@ -2368,13 +2367,13 @@ const char kSystemTimezoneAutomaticDetec
 
 // Pref name for the policy controlling whether to enable Media Router.
 const char kEnableMediaRouter[] = "media_router.enable_media_router";
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Pref name for the policy controlling whether to force the Cast icon to be
 // shown in the toolbar/overflow menu.
 const char kShowCastIconInToolbar[] = "media_router.show_cast_icon_in_toolbar";
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Pref name for the policy controlling the way in which users are notified of
 // the need to relaunch the browser for a pending update.
 const char kRelaunchNotification[] = "browser.relaunch_notification";
@@ -2487,7 +2486,7 @@ const char kCustomHandlersEnabled[] = "c
 // by the cloud policy subsystem.
 const char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
@@ -2623,7 +2622,7 @@ const char kRecoveryComponentNeedsElevat
 const char kRegisteredSupervisedUserWhitelists[] =
     "supervised_users.whitelists";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Boolean that indicates whether Chrome enterprise cloud reporting is enabled
 // or not.
 const char kCloudReportingEnabled[] =
@@ -2871,7 +2870,7 @@ const char kSitePerProcess[] = "site_iso
 const char kUserTriggeredIsolatedOrigins[] =
     "site_isolation.user_triggered_isolated_origins";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Boolean that specifies whether media (audio/video) autoplay is allowed.
 const char kAutoplayAllowed[] = "media.autoplay_allowed";
 
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -340,7 +340,7 @@ extern const char kDeviceLoginScreenWebU
 extern const char kShowHomeButton[];
 extern const char kSpeechRecognitionFilterProfanities[];
 extern const char kAllowDeletingBrowserHistory[];
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kHistoryMenuPromoShown[];
 #endif
 extern const char kForceGoogleSafeSearch[];
@@ -383,7 +383,7 @@ extern const char kUseCustomChromeFrame[
 #if BUILDFLAG(ENABLE_PLUGINS)
 extern const char kContentSettingsPluginWhitelist[];
 #endif
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kPartitionDefaultZoomLevel[];
 extern const char kPartitionPerHostZoomLevels[];
 
@@ -492,7 +492,7 @@ extern const char kWebRTCUDPPortRange[];
 extern const char kWebRtcEventLogCollectionAllowed[];
 extern const char kWebRtcLocalIpsAllowedUrls[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kHasSeenWelcomePage[];
 #endif
 
@@ -578,7 +578,7 @@ extern const char kShutdownNumProcesses[
 extern const char kShutdownNumProcessesSlow[];
 
 extern const char kRestartLastSessionOnShutdown[];
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 extern const char kPromotionalTabsEnabled[];
 extern const char kCommandLineFlagSecurityWarningsEnabled[];
@@ -595,7 +595,6 @@ extern const char kNtpCollapsedForeignSe
 extern const char kNtpCollapsedRecentlyClosedTabs[];
 extern const char kNtpCollapsedSnapshotDocument[];
 extern const char kNtpCollapsedSyncPromo[];
-#else
 extern const char kNtpCustomBackgroundDict[];
 extern const char kNtpCustomBackgroundLocalToDevice[];
 extern const char kNtpPromoBlocklist[];
@@ -620,7 +619,7 @@ extern const char kDevToolsPreferences[]
 extern const char kDevToolsDiscoverTCPTargetsEnabled[];
 extern const char kDevToolsTCPDiscoveryConfig[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kDiceSigninUserMenuPromoCount[];
 #endif
 
@@ -815,11 +814,11 @@ extern const char kSystemTimezoneAutomat
 #endif  // defined(OS_CHROMEOS)
 
 extern const char kEnableMediaRouter[];
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kShowCastIconInToolbar[];
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kRelaunchNotification[];
 extern const char kRelaunchNotificationPeriod[];
 #endif  // !defined(OS_ANDROID)
@@ -828,7 +827,7 @@ extern const char kRelaunchNotificationP
 extern const char kRelaunchHeadsUpPeriod[];
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kAttemptedToEnableAutoupdate[];
 
 extern const char kMediaGalleriesUniqueId[];
@@ -880,7 +879,7 @@ extern const char kRecoveryComponentNeed
 
 extern const char kRegisteredSupervisedUserWhitelists[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kCloudReportingEnabled[];
 extern const char kCloudExtensionRequestEnabled[];
 extern const char kCloudExtensionRequestIds[];
@@ -985,7 +984,7 @@ extern const char kIsolateOrigins[];
 extern const char kSitePerProcess[];
 extern const char kUserTriggeredIsolatedOrigins[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kAutoplayAllowed[];
 extern const char kAutoplayWhitelist[];
 extern const char kBlockAutoplayEnabled[];
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,8 +164,6 @@ WindowsEventRouter::WindowsEventRouter(P
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
-#else
-#error Unsupported
 #endif
 
   AppWindowRegistry* registry = AppWindowRegistry::Get(profile_);
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -46,7 +46,7 @@ const base::Feature kShow10_9ObsoleteInf
                                              base::FEATURE_DISABLED_BY_DEFAULT};
 #endif  // defined(OS_MACOSX)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // App Service related flags. See chrome/services/app_service/README.md.
 const base::Feature kAppServiceContextMenu{"AppServiceContextMenu",
                                            base::FEATURE_ENABLED_BY_DEFAULT};
@@ -474,7 +474,7 @@ const base::Feature kAcknowledgeNtpOverr
 const base::Feature kMixedContentSiteSetting{"MixedContentSiteSetting",
                                              base::FEATURE_ENABLED_BY_DEFAULT};
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::Feature kOnConnectNative{"OnConnectNative",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -48,7 +48,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kShow10_9ObsoleteInfobar;
 #endif  // defined(OS_MACOSX)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppServiceContextMenu;
 COMPONENT_EXPORT(CHROME_FEATURES)
@@ -216,7 +216,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSystem;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSurveysForDesktop;
 
@@ -291,7 +291,7 @@ extern const base::Feature kAcknowledgeN
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kMixedContentSiteSetting;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kOnConnectNative;
 #endif
 
--- a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
@@ -90,12 +90,7 @@ std::string GetProfileId(const Profile*
 // Returns last policy fetch timestamp of machine level user cloud policy if
 // it exists. Otherwise, returns zero.
 int64_t GetMachineLevelUserCloudPolicyFetchTimestamp() {
-  policy::MachineLevelUserCloudPolicyManager* manager =
-      g_browser_process->browser_policy_connector()
-          ->machine_level_user_cloud_policy_manager();
-  if (!manager || !manager->IsClientRegistered())
     return 0;
-  return manager->core()->client()->last_policy_timestamp().ToJavaTime();
 }
 
 void AppendAdditionalBrowserInformation(em::ChromeDesktopReportRequest* request,
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -545,7 +545,7 @@ bool PathProvider(int key, base::FilePat
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_ANDROID)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MACOSX)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -122,7 +122,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_ANDROID)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
--- a/chrome/browser/profiles/profile_window.h
+++ b/chrome/browser/profiles/profile_window.h
@@ -14,9 +14,6 @@
 #include "chrome/browser/ui/profile_chooser_constants.h"
 #include "chrome/browser/ui/startup/startup_types.h"
 
-#if defined(OS_ANDROID)
-#error "Not used on Android"
-#endif
 
 class Profile;
 
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -27,7 +27,7 @@
 #include "content/public/browser/browsing_data_remover.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -80,7 +80,7 @@ void SetLastUsedProfile(const std::strin
   local_state->SetString(prefs::kProfileLastUsed, profile_dir);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 base::string16 GetAvatarNameForProfile(const base::FilePath& profile_path) {
   if (profile_path == ProfileManager::GetGuestProfilePath()) {
     return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);
--- a/chrome/browser/profiles/profiles_state.h
+++ b/chrome/browser/profiles/profiles_state.h
@@ -42,7 +42,7 @@ void RegisterPrefs(PrefRegistrySimple* r
 // System Profile directory, which is an invalid last used profile.
 void SetLastUsedProfile(const std::string& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns the display name of the specified on-the-record profile (or guest),
 // specified by |profile_path|, used in the avatar button or user manager. If
 // |profile_path| is the guest path, it will return IDS_GUEST_PROFILE_NAME. If
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
@@ -13,7 +13,7 @@ namespace views {
 bool UnhandledKeyboardEventHandler::HandleNativeKeyboardEvent(
     gfx::NativeEvent event,
     FocusManager* focus_manager) {
-  return !focus_manager->OnKeyEvent(*(event->AsKeyEvent()));
+  return false;
 }
 
 }  // namespace views
--- /dev/null
+++ b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
@@ -0,0 +1,77 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/api/system_cpu/cpu_info_provider.h"
+
+#include <stdint.h>
+
+#include <cstdio>
+#include <sstream>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+
+namespace extensions {
+
+namespace {
+
+const char kProcStat[] = "/proc/stat";
+
+}  // namespace
+
+bool CpuInfoProvider::QueryCpuTimePerProcessor(
+    std::vector<api::system_cpu::ProcessorInfo>* infos) {
+  DCHECK(infos);
+
+  // WARNING: this method may return incomplete data because some processors may
+  // be brought offline at runtime. /proc/stat does not report statistics of
+  // offline processors. CPU usages of offline processors will be filled with
+  // zeros.
+  //
+  // An example of output of /proc/stat when processor 0 and 3 are online, but
+  // processor 1 and 2 are offline:
+  //
+  //   cpu  145292 20018 83444 1485410 995 44 3578 0 0 0
+  //   cpu0 138060 19947 78350 1479514 570 44 3576 0 0 0
+  //   cpu3 2033 32 1075 1400 52 0 1 0 0 0
+  std::string contents;
+  if (!base::ReadFileToString(base::FilePath(kProcStat), &contents))
+    return false;
+
+  std::istringstream iss(contents);
+  std::string line;
+
+  // Skip the first line because it is just an aggregated number of
+  // all cpuN lines.
+  std::getline(iss, line);
+  while (std::getline(iss, line)) {
+    if (line.compare(0, 3, "cpu") != 0)
+      continue;
+
+    uint64_t user = 0, nice = 0, sys = 0, idle = 0;
+    uint32_t pindex = 0;
+    int vals =
+        sscanf(line.c_str(),
+               "cpu%" PRIu32 " %" PRIu64 " %" PRIu64 " %" PRIu64 " %" PRIu64,
+               &pindex,
+               &user,
+               &nice,
+               &sys,
+               &idle);
+    if (vals != 5 || pindex >= infos->size()) {
+      NOTREACHED();
+      return false;
+    }
+
+    infos->at(pindex).usage.kernel = static_cast<double>(sys);
+    infos->at(pindex).usage.user = static_cast<double>(user + nice);
+    infos->at(pindex).usage.idle = static_cast<double>(idle);
+    infos->at(pindex).usage.total =
+        static_cast<double>(sys + user + nice + idle);
+  }
+
+  return true;
+}
+
+}  // namespace extensions
--- a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
+++ b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
@@ -112,15 +112,6 @@ MediaCaptureDevicesDispatcher::MediaCapt
   media_access_handlers_.push_back(
       std::make_unique<ExtensionMediaAccessHandler>());
 #endif
-  media_access_handlers_.push_back(
-      std::make_unique<DesktopCaptureAccessHandler>());
-#if defined(OS_CHROMEOS)
-  // Wrapper around TabCaptureAccessHandler used in Public Sessions.
-  media_access_handlers_.push_back(
-      std::make_unique<PublicSessionTabCaptureAccessHandler>());
-#else
-  media_access_handlers_.push_back(std::make_unique<TabCaptureAccessHandler>());
-#endif
 #endif
   media_access_handlers_.push_back(
       std::make_unique<PermissionBubbleMediaAccessHandler>());
--- /dev/null
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,188 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/apps/platform_apps/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace chrome_apps {
+namespace api {
+
+namespace {
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+    "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < base::size(kDeviceNames); i++) {
+    DiskEntries::iterator it = disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin(); it != disk_uuids.end();
+         ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value()
+                 << ", uuid=" << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {}
+
+  bool ProcessInterface(struct ifaddrs* ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  int rv = -1;
+  if (rv < 0) {
+    PLOG(ERROR) << "getifaddrs failed " << rv;
+    return "";
+  }
+
+  MacAddressProcessor processor(is_valid_mac_address);
+  return processor.mac_address();
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+                 base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTask(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace chrome_apps
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -88,6 +88,7 @@
 #include "components/services/app_service/public/mojom/types.mojom.h"
 #include "components/sessions/core/live_tab_context.h"
 #include "components/sessions/core/tab_restore_service.h"
+#include "components/signin/public/base/signin_metrics.h"
 #include "components/tab_groups/tab_group_id.h"
 #include "components/tab_groups/tab_group_visual_data.h"
 #include "components/translate/core/browser/language_state.h"
--- a/ui/native_theme/native_theme_android.cc
+++ b/ui/native_theme/native_theme_android.cc
@@ -22,8 +22,7 @@ NativeTheme* NativeTheme::GetInstanceFor
 }
 
 NativeTheme* NativeTheme::GetInstanceForNativeUi() {
-  NOTREACHED();
-  return nullptr;
+  return NativeThemeAndroid::instance();
 }
 #endif
 
--- a/ui/native_theme/native_theme_android.h
+++ b/ui/native_theme/native_theme_android.h
@@ -20,11 +20,11 @@ class NativeThemeAndroid : public Native
                         const ExtraParams& extra) const override;
   SkColor GetSystemColor(ColorId color_id,
                          ColorScheme color_scheme) const override;
+  static NativeThemeAndroid* instance();
 
  protected:
   friend class NativeTheme;
   friend class base::NoDestructor<NativeThemeAndroid>;
-  static NativeThemeAndroid* instance();
 
   // NativeThemeBase:
   void AdjustCheckboxRadioRectForPadding(SkRect* rect) const override;
--- a/content/browser/storage_partition_impl.h
+++ b/content/browser/storage_partition_impl.h
@@ -54,7 +54,7 @@
 #include "storage/browser/quota/special_storage_policy.h"
 #include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "content/browser/host_zoom_level_context.h"
 #endif
 
@@ -149,7 +149,7 @@ class CONTENT_EXPORT StoragePartitionImp
   DevToolsBackgroundServicesContextImpl* GetDevToolsBackgroundServicesContext()
       override;
   ContentIndexContextImpl* GetContentIndexContext() override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   HostZoomMap* GetHostZoomMap() override;
   HostZoomLevelContext* GetHostZoomLevelContext() override;
   ZoomLevelDelegate* GetZoomLevelDelegate() override;
@@ -475,7 +475,7 @@ class CONTENT_EXPORT StoragePartitionImp
   std::unique_ptr<SharedWorkerServiceImpl> shared_worker_service_;
   std::unique_ptr<PushMessagingContext> push_messaging_context_;
   scoped_refptr<storage::SpecialStoragePolicy> special_storage_policy_;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<HostZoomLevelContext, BrowserThread::DeleteOnUIThread>
       host_zoom_level_context_;
 #endif  // !defined(OS_ANDROID)
--- a/content/public/browser/storage_partition.h
+++ b/content/public/browser/storage_partition.h
@@ -66,7 +66,7 @@ class PlatformNotificationContext;
 class ServiceWorkerContext;
 class SharedWorkerService;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class HostZoomLevelContext;
 class HostZoomMap;
 class ZoomLevelDelegate;
@@ -136,7 +136,7 @@ class CONTENT_EXPORT StoragePartition {
   virtual DevToolsBackgroundServicesContext*
   GetDevToolsBackgroundServicesContext() = 0;
   virtual ContentIndexContext* GetContentIndexContext() = 0;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   virtual HostZoomMap* GetHostZoomMap() = 0;
   virtual HostZoomLevelContext* GetHostZoomLevelContext() = 0;
   virtual ZoomLevelDelegate* GetZoomLevelDelegate() = 0;
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -177,7 +177,6 @@
 #include "content/browser/android/nfc_host.h"
 #include "content/browser/web_contents/web_contents_android.h"
 #include "services/device/public/mojom/nfc.mojom.h"
-#else  // !OS_ANDROID
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // OS_ANDROID
 
@@ -1203,7 +1202,7 @@ FindRequestManager* WebContentsImpl::Get
   return GetFindRequestManager();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void WebContentsImpl::UpdateZoom() {
   RenderWidgetHostImpl* rwh = GetRenderViewHost()->GetWidget();
   if (rwh->GetView())
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -260,7 +260,7 @@ class CONTENT_EXPORT WebContentsImpl : p
   // bitmap.
   void AddAccessibilityMode(ui::AXMode mode);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Sets the zoom level for frames associated with this WebContents.
   void UpdateZoom();
 
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -1490,7 +1490,7 @@ void StoragePartitionImpl::Initialize()
   push_messaging_context_ = std::make_unique<PushMessagingContext>(
       browser_context_, service_worker_context_);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   host_zoom_level_context_.reset(new HostZoomLevelContext(
       browser_context_->CreateZoomLevelDelegate(partition_path_)));
 #endif  // !defined(OS_ANDROID)
@@ -1751,7 +1751,7 @@ SharedWorkerServiceImpl* StoragePartitio
   return shared_worker_service_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 HostZoomMap* StoragePartitionImpl::GetHostZoomMap() {
   DCHECK(initialized_);
   DCHECK(host_zoom_level_context_.get());
--- a/content/public/browser/browser_context.h
+++ b/content/public/browser/browser_context.h
@@ -28,7 +28,7 @@
 #include "third_party/blink/public/mojom/blob/blob.mojom-forward.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-forward.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "content/public/browser/zoom_level_delegate.h"
 #endif
 
@@ -255,7 +255,7 @@ class CONTENT_EXPORT BrowserContext : pu
   // StoragePartition can have time to do necessary cleanups on IO thread.
   void ShutdownStoragePartitions();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Creates a delegate to initialize a HostZoomMap and persist its information.
   // This is called during creation of each StoragePartition.
   virtual std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -188,7 +188,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/profile_key_startup_accessor.h"
-#else
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/common/page_zoom.h"
 #endif
@@ -812,7 +811,7 @@ Profile::ProfileType ProfileImpl::GetPro
   return REGULAR_PROFILE;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 ProfileImpl::CreateZoomLevelDelegate(const base::FilePath& partition_path) {
   return std::make_unique<ChromeZoomLevelPrefs>(
@@ -1058,7 +1057,7 @@ const PrefService* ProfileImpl::GetPrefs
   return prefs_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 ChromeZoomLevelPrefs* ProfileImpl::GetZoomLevelPrefs() {
   return static_cast<ChromeZoomLevelPrefs*>(
       GetDefaultStoragePartition(this)->GetZoomLevelDelegate());
--- a/chrome/browser/profiles/profile_impl.h
+++ b/chrome/browser/profiles/profile_impl.h
@@ -26,7 +26,7 @@
 #include "content/public/browser/content_browser_client.h"
 #include "extensions/buildflags/buildflags.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -71,7 +71,7 @@ class ProfileImpl : public Profile {
   static void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);
 
   // content::BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif
@@ -128,7 +128,7 @@ class ProfileImpl : public Profile {
   ExtensionSpecialStoragePolicy* GetExtensionSpecialStoragePolicy() override;
   PrefService* GetPrefs() override;
   const PrefService* GetPrefs() const override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   ChromeZoomLevelPrefs* GetZoomLevelPrefs() override;
 #endif
   PrefService* GetOffTheRecordPrefs() override;
--- a/content/shell/browser/shell_browser_context.cc
+++ b/content/shell/browser/shell_browser_context.cc
@@ -139,7 +139,7 @@ void ShellBrowserContext::FinishInitWhil
   SimpleKeyMap::GetInstance()->Associate(this, key_.get());
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<ZoomLevelDelegate> ShellBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath&) {
   return std::unique_ptr<ZoomLevelDelegate>();
--- a/content/shell/browser/shell_browser_context.h
+++ b/content/shell/browser/shell_browser_context.h
@@ -25,7 +25,7 @@ class ClientHintsControllerDelegate;
 class DownloadManagerDelegate;
 class PermissionControllerDelegate;
 class ShellDownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class ZoomLevelDelegate;
 #endif  // !defined(OS_ANDROID)
 
@@ -44,7 +44,7 @@ class ShellBrowserContext : public Brows
 
   // BrowserContext implementation.
   base::FilePath GetPath() override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
--- a/chromecast/browser/cast_browser_context.cc
+++ b/chromecast/browser/cast_browser_context.cc
@@ -80,7 +80,7 @@ void CastBrowserContext::InitWhileIOAllo
   BrowserContext::Initialize(this, path_);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 CastBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
--- a/chromecast/browser/cast_browser_context.h
+++ b/chromecast/browser/cast_browser_context.h
@@ -25,7 +25,7 @@ class CastBrowserContext final : public
   ~CastBrowserContext() override;
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
--- a/chrome/browser/profiles/off_the_record_profile_impl.cc
+++ b/chrome/browser/profiles/off_the_record_profile_impl.cc
@@ -75,7 +75,6 @@
 
 #if defined(OS_ANDROID)
 #include "components/prefs/scoped_user_pref_update.h"
-#else  // !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_otr_delegate.h"
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/browser/host_zoom_map.h"
@@ -109,7 +108,7 @@
 
 using content::BrowserThread;
 using content::DownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 using content::HostZoomMap;
 #endif
 
@@ -219,7 +218,7 @@ OffTheRecordProfileImpl::~OffTheRecordPr
   }
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void OffTheRecordProfileImpl::TrackZoomLevelsFromParent() {
   DCHECK(!profile_->IsIncognitoProfile());
 
@@ -273,7 +272,7 @@ base::Time OffTheRecordProfileImpl::GetC
   return start_time_;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 OffTheRecordProfileImpl::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
@@ -618,7 +617,7 @@ Profile* Profile::CreateOffTheRecordProf
   return profile;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void OffTheRecordProfileImpl::OnParentZoomLevelChanged(
     const HostZoomMap::ZoomLevelChange& change) {
   HostZoomMap* host_zoom_map = HostZoomMap::GetDefaultForBrowserContext(this);
--- a/chrome/browser/profiles/off_the_record_profile_impl.h
+++ b/chrome/browser/profiles/off_the_record_profile_impl.h
@@ -17,7 +17,7 @@
 #include "components/domain_reliability/clear_mode.h"
 #include "content/public/browser/content_browser_client.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -93,7 +93,7 @@ class OffTheRecordProfileImpl : public P
   base::FilePath GetPath() override;
   base::FilePath GetPath() const override;
   base::Time GetCreationTime() const override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
@@ -127,12 +127,12 @@ class OffTheRecordProfileImpl : public P
   GetNativeFileSystemPermissionContext() override;
 
  private:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Allows a profile to track changes in zoom levels in its parent profile.
   void TrackZoomLevelsFromParent();
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Callback function for tracking parent's zoom level changes.
   void OnParentZoomLevelChanged(
       const content::HostZoomMap::ZoomLevelChange& change);
@@ -144,7 +144,7 @@ class OffTheRecordProfileImpl : public P
 
   std::unique_ptr<sync_preferences::PrefServiceSyncable> prefs_;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::HostZoomMap::Subscription> track_zoom_subscription_;
   std::unique_ptr<ChromeZoomLevelPrefs::DefaultZoomLevelSubscription>
       parent_default_zoom_level_subscription_;
--- a/weblayer/browser/browser_context_impl.cc
+++ b/weblayer/browser/browser_context_impl.cc
@@ -106,7 +106,7 @@ base::FilePath BrowserContextImpl::GetDe
   return download_dir;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 BrowserContextImpl::CreateZoomLevelDelegate(const base::FilePath&) {
   return nullptr;
--- a/weblayer/browser/browser_context_impl.h
+++ b/weblayer/browser/browser_context_impl.h
@@ -31,7 +31,7 @@ class BrowserContextImpl : public conten
   static base::FilePath GetDefaultDownloadDirectory();
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath&) override;
 #endif  // !defined(OS_ANDROID)
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -193,6 +193,11 @@ Widget::~Widget() {
 }
 
 // static
+const ui::NativeTheme* Widget::GetNativeTheme() const {
+  return ui::NativeTheme::GetInstanceForNativeUi();
+}
+
+// static
 Widget* Widget::CreateWindowWithParent(WidgetDelegate* delegate,
                                        gfx::NativeView parent,
                                        const gfx::Rect& bounds) {
--- a/chrome/browser/ui/browser_dialogs.cc
+++ b/chrome/browser/ui/browser_dialogs.cc
@@ -29,7 +29,7 @@ bool IsDeviceChooserShowingForTesting()
 
 }  // namespace chrome
 
-#if !defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS)
 // There's no dialog version of this available outside views, run callback as if
 // the dialog was instantly accepted.
 void ShowFolderUploadConfirmationDialog(
--- a/chrome/browser/search/instant_service_observer.h
+++ b/chrome/browser/search/instant_service_observer.h
@@ -9,7 +9,7 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/local_ntp_source.h
+++ b/chrome/browser/search/local_ntp_source.h
@@ -26,7 +26,7 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/most_visited_iframe_source.h
+++ b/chrome/browser/search/most_visited_iframe_source.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/browser_instant_controller.h
+++ b/chrome/browser/ui/browser_instant_controller.h
@@ -13,7 +13,7 @@
 #include "chrome/browser/search/search_engine_base_url_tracker.h"
 #include "chrome/browser/ui/search/instant_controller.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/instant_controller.h
+++ b/chrome/browser/ui/search/instant_controller.h
@@ -12,7 +12,7 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/search_ipc_router.h
+++ b/chrome/browser/ui/search/search_ipc_router.h
@@ -21,7 +21,7 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/associated_receiver.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/search_tab_helper.h
+++ b/chrome/browser/ui/search/search_tab_helper.h
@@ -32,7 +32,7 @@
 #include "content/public/browser/web_contents_user_data.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
@@ -28,6 +28,7 @@ class RegisterProtocolHandlerPermissionR
  private:
   // permissions::PermissionRequest:
   IconId GetIconId() const override;
+  base::string16 GetMessageText() const override;
   base::string16 GetMessageTextFragment() const override;
   GURL GetOrigin() const override;
   void PermissionGranted() override;
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.cc
@@ -0,0 +1,17 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/system_display/display_info_provider_android.h"
+
+#include "chrome/browser/extensions/system_display/display_info_provider.h"
+
+namespace extensions {
+
+DisplayInfoProviderAndroid::DisplayInfoProviderAndroid() = default;
+
+std::unique_ptr<DisplayInfoProvider> CreateChromeDisplayInfoProvider() {
+  return std::make_unique<DisplayInfoProviderAndroid>();
+}
+
+}  // namespace extensions
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.h
@@ -0,0 +1,24 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
+#include "base/macros.h"
+#include "extensions/browser/api/system_display/display_info_provider.h"
+
+namespace extensions {
+
+class DisplayInfoProviderAndroid : public DisplayInfoProvider {
+ public:
+  DisplayInfoProviderAndroid();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DisplayInfoProviderAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
--- /dev/null
+++ b/chrome/browser/ui/views/accelerator_utils_android.cc
@@ -0,0 +1,23 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include "chrome/browser/ui/views/accelerator_table.h"
+#include "ui/base/accelerators/accelerator.h"
+
+namespace chrome {
+
+bool IsChromeAccelerator(const ui::Accelerator& accelerator) {
+  const std::vector<AcceleratorMapping> accelerators = GetAcceleratorList();
+  for (const auto& entry : accelerators) {
+    if (entry.keycode == accelerator.key_code() &&
+        entry.modifiers == accelerator.modifiers())
+      return true;
+  }
+
+  return false;
+}
+
+}  // namespace chrome
--- /dev/null
+++ b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
@@ -0,0 +1,19 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include "base/files/file_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace extensions {
+// static
+scoped_refptr<StorageDeviceList>
+RemovableStorageProvider::PopulateDeviceList() {
+  return nullptr;
+}
+
+}  // namespace extensions
--- a/chrome/browser/download/download_ui_model.cc
+++ b/chrome/browser/download/download_ui_model.cc
@@ -24,7 +24,7 @@
 #include "ui/base/text/bytes_formatting.h"
 #include "ui/gfx/text_elider.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -531,7 +531,7 @@ bool DownloadUIModel::ShouldPromoteOrigi
   return false;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 bool DownloadUIModel::IsCommandEnabled(
     const DownloadCommands* download_commands,
     DownloadCommands::Command command) const {
--- a/chrome/browser/download/download_ui_model.h
+++ b/chrome/browser/download/download_ui_model.h
@@ -18,7 +18,7 @@
 #include "components/offline_items_collection/core/offline_item.h"
 #include "components/safe_browsing/buildflags.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/download/download_commands.h"
 #endif
 
@@ -285,7 +285,7 @@ class DownloadUIModel {
   // security reasons.
   virtual bool ShouldPromoteOrigin() const;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Methods related to DownloadCommands.
   // Returns whether the given download command is enabled for this download.
   virtual bool IsCommandEnabled(const DownloadCommands* download_commands,
--- a/chrome/browser/download/download_commands.h
+++ b/chrome/browser/download/download_commands.h
@@ -11,7 +11,7 @@
 #include "content/public/browser/page_navigator.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class Browser;
 #endif
 
@@ -48,7 +48,7 @@ class DownloadCommands {
   bool IsCommandVisible(Command command) const;
   void ExecuteCommand(Command command);
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_ANDROID)
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
   Browser* GetBrowser() const;
--- a/chrome/browser/lifetime/application_lifetime.cc
+++ b/chrome/browser/lifetime/application_lifetime.cc
@@ -34,7 +34,7 @@
 #include "content/public/browser/navigation_details.h"
 #include "content/public/browser/notification_service.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/lifetime/termination_notification.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -51,7 +51,7 @@
 #include "third_party/cros_system_api/dbus/service_constants.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/ui/user_manager.h"
 #endif
 
@@ -63,7 +63,7 @@ namespace chrome {
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns true if all browsers can be closed without user interaction.
 // This currently checks if there is pending download, or if it needs to
 // handle unload handler.
@@ -121,7 +121,7 @@ bool SetLocaleForNextStart(PrefService*
 bool g_send_stop_request_to_session_manager = false;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 using IgnoreUnloadHandlers =
     util::StrongAlias<class IgnoreUnloadHandlersTag, bool>;
 
@@ -155,7 +155,7 @@ void AttemptRestartInternal(IgnoreUnload
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void MarkAsCleanShutdown() {
   // TODO(beng): Can this use ProfileManager::GetLoadedProfiles() instead?
   for (auto* browser : *BrowserList::GetInstance())
@@ -178,7 +178,7 @@ void AttemptExitInternal(bool try_to_qui
   g_browser_process->platform_part()->AttemptExit(try_to_quit_application);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void CloseAllBrowsersAndQuit() {
   browser_shutdown::SetTryingToQuit(true);
   CloseAllBrowsers();
@@ -270,7 +270,7 @@ void AttemptRelaunch() {
   AttemptRestart();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void RelaunchIgnoreUnloadHandlers() {
 #if defined(OS_CHROMEOS)
   chromeos::PowerManagerClient::Get()->RequestRestart(
@@ -290,7 +290,7 @@ void AttemptExit() {
   // don't notify users of crashes beyond this point.
   // Note that MarkAsCleanShutdown() does not set UMA's exit cleanly bit
   // so crashes during shutdown are still reported in UMA.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Android doesn't use Browser.
   if (AreAllBrowsersCloseable())
     MarkAsCleanShutdown();
@@ -301,7 +301,7 @@ void AttemptExit() {
 
 void ExitIgnoreUnloadHandlers() {
   VLOG(1) << "ExitIgnoreUnloadHandlers";
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // We always mark exit cleanly.
   MarkAsCleanShutdown();
 
@@ -328,7 +328,7 @@ bool IsAttemptingShutdown() {
 }
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void SessionEnding() {
   // This is a time-limited shutdown where we need to write as much to
   // disk as we can as soon as we can, and where we must kill the
@@ -396,6 +396,8 @@ void OnAppExiting() {
   notified = true;
   HandleAppExitingForPlatform();
 }
+
+void HandleAppExitingForPlatform() {}
 #endif  // !defined(OS_ANDROID)
 
 }  // namespace chrome
--- a/chrome/browser/ui/chrome_pages.cc
+++ b/chrome/browser/ui/chrome_pages.cc
@@ -71,7 +71,7 @@
 #include "chrome/browser/ui/signin_view_controller.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #endif
@@ -490,7 +490,7 @@ GURL GetOSSettingsUrl(const std::string&
 }
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point) {
 }
--- a/chrome/browser/ui/chrome_pages.h
+++ b/chrome/browser/ui/chrome_pages.h
@@ -13,7 +13,7 @@
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/signin/signin_promo.h"
 #endif
 
@@ -138,7 +138,7 @@ void ShowEnterpriseManagementPageInTabbe
 GURL GetOSSettingsUrl(const std::string& sub_page);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 // Initiates signin in a new browser tab.
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point);
--- a/chrome/browser/metrics/thread_watcher.cc
+++ b/chrome/browser/metrics/thread_watcher.cc
@@ -36,7 +36,7 @@
 #include "content/public/browser/notification_registrar.h"
 #include "content/public/browser/notification_service.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/metrics/browser_activity_watcher.h"
 #endif
 
@@ -68,7 +68,7 @@ class ThreadWatcherObserver : public con
   // Called when user activity is detected.
   void OnUserActivityDetected();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<BrowserActivityWatcher> browser_activity_watcher_;
 #endif
 
@@ -97,7 +97,7 @@ ThreadWatcherObserver::ThreadWatcherObse
   DCHECK(!g_thread_watcher_observer_);
   g_thread_watcher_observer_ = this;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   browser_activity_watcher_ = std::make_unique<BrowserActivityWatcher>(
       base::BindRepeating(&ThreadWatcherObserver::OnUserActivityDetected,
                           base::Unretained(this)));
@@ -832,7 +832,7 @@ void WatchDogThread::CleanUp() {
 }
 
 // ShutdownWatcherHelper is not available on Android.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 namespace {
 
--- a/chrome/browser/metrics/thread_watcher.h
+++ b/chrome/browser/metrics/thread_watcher.h
@@ -498,7 +498,7 @@ class WatchDogThread : public base::Thre
 // ShutdownWatcherHelper is useless on Android because there is no shutdown,
 // Chrome is always killed one way or another (swiped away in the task
 // switcher, OOM-killed, etc.).
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // This is a wrapper class for detecting hangs during shutdown.
 class ShutdownWatcherHelper {
  public:
--- a/chrome/browser/lifetime/browser_shutdown.cc
+++ b/chrome/browser/lifetime/browser_shutdown.cc
@@ -46,7 +46,7 @@
 #include "chrome/browser/win/browser_util.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/first_run/upgrade_util.h"
 #endif
 
@@ -157,7 +157,7 @@ ShutdownType GetShutdownType() {
   return g_shutdown_type;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 bool ShutdownPreThreadsStop() {
 #if defined(OS_CHROMEOS)
   chromeos::BootTimesRecorder::Get()->AddLogoutTimeMarker(
@@ -380,7 +380,7 @@ void SetTryingToQuit(bool quitting) {
   // attempt is cancelled.
   PrefService* pref_service = g_browser_process->local_state();
   if (pref_service) {
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     pref_service->ClearPref(prefs::kWasRestarted);
 #endif  // !defined(OS_ANDROID)
     pref_service->ClearPref(prefs::kRestartLastSessionOnShutdown);
--- a/chrome/browser/lifetime/browser_shutdown.h
+++ b/chrome/browser/lifetime/browser_shutdown.h
@@ -13,7 +13,7 @@ class PrefRegistrySimple;
 
 namespace browser_shutdown {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 // The type of restart to perform during shutdown; see ShutdownPostThreadsStop.
 enum class RestartMode {
@@ -75,7 +75,7 @@ bool ShouldIgnoreUnloadHandlers();
 // Get the current shutdown type.
 ShutdownType GetShutdownType();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Performs the shutdown tasks that need to be done before
 // BrowserProcess and the various threads go away.
 //
--- a/chrome/browser/metrics/thread_watcher_report_hang.cc
+++ b/chrome/browser/metrics/thread_watcher_report_hang.cc
@@ -34,7 +34,7 @@ NOINLINE void ReportThreadHang() {
 #endif
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 NOINLINE void StartupHang() {
   volatile int inhibit_comdat = __LINE__;
--- a/chrome/browser/metrics/thread_watcher_report_hang.h
+++ b/chrome/browser/metrics/thread_watcher_report_hang.h
@@ -11,7 +11,7 @@
 
 namespace metrics {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 // This function makes it possible to tell from the callstack why startup is
 // taking too long.
--- a/chrome/browser/first_run/upgrade_util.h
+++ b/chrome/browser/first_run/upgrade_util.h
@@ -10,7 +10,7 @@
 #include "base/callback_forward.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
+#if !defined(OS_ANDROID) || defined(OS_CHROMEOS)
 #error Not used on Android or ChromeOS
 #endif
 
--- a/chrome/browser/profiles/profile_metrics.cc
+++ b/chrome/browser/profiles/profile_metrics.cc
@@ -25,13 +25,13 @@
 #include "components/signin/core/browser/signin_header_helper.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #endif
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 constexpr base::TimeDelta kProfileActivityThreshold =
     base::TimeDelta::FromDays(28);  // Should be integral number of weeks.
 #endif
@@ -133,7 +133,7 @@ enum ProfileAvatar {
 
 // static
 bool ProfileMetrics::IsProfileActive(const ProfileAttributesEntry* entry) {
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // TODO(mlerman): iOS and Android should set an ActiveTime in the
   // ProfileAttributesStorage. (see ProfileManager::OnBrowserSetLastActive)
   if (base::Time::Now() - entry->GetActiveTime() > kProfileActivityThreshold)
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -27,7 +27,7 @@
 #include "net/base/url_util.h"
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -154,7 +154,7 @@ void DownloadCommands::ExecuteCommand(Co
   model_->ExecuteCommand(this, command);
 }
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_ANDROID)
 
 Browser* DownloadCommands::GetBrowser() const {
   chrome::ScopedTabbedBrowserDisplayer browser_displayer(model_->profile());
@@ -177,7 +177,7 @@ bool DownloadCommands::CanOpenPdfInSyste
   return IsDownloadPdf() &&
          (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
                                           : true);
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
+#elif defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_ANDROID)
   return IsDownloadPdf();
 #endif
 }
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
@@ -29,7 +29,13 @@ RegisterProtocolHandlerPermissionRequest
 
 permissions::PermissionRequest::IconId
 RegisterProtocolHandlerPermissionRequest::GetIconId() const {
-  return vector_icons::kProtocolHandlerIcon;
+  return 0;
+}
+
+base::string16 RegisterProtocolHandlerPermissionRequest::GetMessageText() const {
+  return l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM,
+                   handler_.GetProtocolDisplayName());
 }
 
 base::string16
--- a/chrome/browser/policy/chrome_browser_policy_connector.cc
+++ b/chrome/browser/policy/chrome_browser_policy_connector.cc
@@ -33,22 +33,10 @@
 #include "extensions/buildflags/buildflags.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
-#if defined(OS_WIN)
-#include "base/win/registry.h"
-#include "components/policy/core/common/policy_loader_win.h"
-#elif defined(OS_MACOSX)
-#include <CoreFoundation/CoreFoundation.h>
-#include "base/mac/foundation_util.h"
-#include "base/strings/sys_string_conversions.h"
-#include "components/policy/core/common/policy_loader_mac.h"
-#include "components/policy/core/common/preferences_mac.h"
-#elif defined(OS_POSIX) && !defined(OS_ANDROID)
 #include "components/policy/core/common/config_dir_policy_loader.h"
-#elif defined(OS_ANDROID)
 #include "components/policy/core/browser/android/android_combined_policy_provider.h"
-#endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID)
 #include "chrome/browser/policy/chrome_browser_cloud_management_controller.h"
 #include "components/policy/core/common/cloud/machine_level_user_cloud_policy_manager.h"
 #endif
@@ -96,7 +84,7 @@ bool ChromeBrowserPolicyConnector::IsEnt
 bool ChromeBrowserPolicyConnector::HasMachineLevelPolicies() {
   if (ProviderHasPolicies(GetPlatformProvider()))
     return true;
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   if (ProviderHasPolicies(machine_level_user_cloud_policy_manager_))
     return true;
 #endif  // !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
@@ -104,7 +92,7 @@ bool ChromeBrowserPolicyConnector::HasMa
 }
 
 void ChromeBrowserPolicyConnector::Shutdown() {
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   // Reset the controller before calling base class so that
   // shutdown occurs in correct sequence.
   chrome_browser_cloud_management_controller_.reset();
@@ -184,7 +172,6 @@ ChromeBrowserPolicyConnector::CreatePlat
   } else {
     return nullptr;
   }
-#elif defined(OS_ANDROID)
   return std::make_unique<policy::android::AndroidCombinedPolicyProvider>(
       GetSchemaRegistry());
 #else
--- a/chrome/browser/policy/chrome_browser_policy_connector.h
+++ b/chrome/browser/policy/chrome_browser_policy_connector.h
@@ -20,7 +20,7 @@ class PrefService;
 namespace policy {
 class ConfigurationPolicyProvider;
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 class ChromeBrowserCloudManagementController;
 class MachineLevelUserCloudPolicyManager;
 #endif
@@ -55,7 +55,7 @@ class ChromeBrowserPolicyConnector : pub
 
   ConfigurationPolicyProvider* GetPlatformProvider();
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   ChromeBrowserCloudManagementController*
   chrome_browser_cloud_management_controller() {
     return chrome_browser_cloud_management_controller_.get();
@@ -77,7 +77,7 @@ class ChromeBrowserPolicyConnector : pub
   // Owned by base class.
   ConfigurationPolicyProvider* platform_provider_ = nullptr;
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   std::unique_ptr<ChromeBrowserCloudManagementController>
       chrome_browser_cloud_management_controller_;
   // Owned by base class.
--- a/chrome/browser/hid/hid_chooser_context.cc
+++ b/chrome/browser/hid/hid_chooser_context.cc
@@ -179,11 +179,6 @@ base::WeakPtr<HidChooserContext> HidChoo
 void HidChooserContext::EnsureHidManagerConnection() {
   if (hid_manager_)
     return;
-
-  mojo::PendingRemote<device::mojom::HidManager> manager;
-  content::GetDeviceService().BindHidManager(
-      manager.InitWithNewPipeAndPassReceiver());
-  SetUpHidManagerConnection(std::move(manager));
 }
 
 void HidChooserContext::SetUpHidManagerConnection(
--- a/chrome/browser/permissions/attestation_permission_request.cc
+++ b/chrome/browser/permissions/attestation_permission_request.cc
@@ -26,9 +26,14 @@ class AttestationPermissionRequest : pub
       : origin_(origin), callback_(std::move(callback)) {}
 
   permissions::PermissionRequest::IconId GetIconId() const override {
-    return kUsbSecurityKeyIcon;
+    return 0;
   }
 
+  base::string16 GetMessageText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
+   }
+
   base::string16 GetMessageTextFragment() const override {
     return l10n_util::GetStringUTF16(
         IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
--- a/chrome/browser/profiles/profile_window.cc
+++ b/chrome/browser/profiles/profile_window.cc
@@ -53,7 +53,7 @@
 #include "extensions/browser/extension_system.h"
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_list_observer.h"
@@ -252,7 +252,7 @@ void OpenBrowserWindowForProfile(Profile
                                             is_first_run, true);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 void LoadProfileAsync(const base::FilePath& path,
                       ProfileManager::CreateCallback callback) {
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
@@ -9,13 +9,13 @@
 namespace resource_coordinator {
 
 ResourceCoordinatorParts::ResourceCoordinatorParts()
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     : tab_manager_(&tab_load_tracker_),
       tab_lifecycle_unit_source_(tab_manager_.intervention_policy_database(),
                                  tab_manager_.usage_clock())
 #endif
 {
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   tab_lifecycle_unit_source_.AddObserver(&tab_manager_);
 #endif
 }
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.h
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
@@ -10,7 +10,7 @@
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
 #include "chrome/browser/resource_coordinator/tab_memory_metrics_reporter.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_source.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -39,7 +39,7 @@ class ResourceCoordinatorParts {
   TabLoadTracker* tab_load_tracker() { return &tab_load_tracker_; }
 
   TabManager* tab_manager() {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
     return nullptr;
 #else
     return &tab_manager_;
@@ -47,7 +47,7 @@ class ResourceCoordinatorParts {
   }
 
   TabLifecycleUnitSource* tab_lifecycle_unit_source() {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
     return nullptr;
 #else
     return &tab_lifecycle_unit_source_;
@@ -62,7 +62,7 @@ class ResourceCoordinatorParts {
   // Created on demand the first time it's being accessed.
   std::unique_ptr<TabMemoryMetricsReporter> tab_memory_metrics_reporter_;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Any change to this #ifdef must be reflected as well in
   // chrome/browser/resource_coordinator/tab_manager_browsertest.cc
   //
--- a/chrome/browser/performance_manager/graph/policies/policy_features.cc
+++ b/chrome/browser/performance_manager/graph/policies/policy_features.cc
@@ -80,7 +80,7 @@ const base::FeatureParam<int> kDynamicTu
 
 #endif  // defined(OS_LINUX)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::Feature kPageFreezingFromPerformanceManager{
     "PageFreezingFromPerformanceManager", base::FEATURE_DISABLED_BY_DEFAULT};
 
--- a/chrome/browser/performance_manager/graph/policies/policy_features.h
+++ b/chrome/browser/performance_manager/graph/policies/policy_features.h
@@ -76,7 +76,7 @@ extern const base::FeatureParam<int> kDy
 
 #endif  // defined(OS_LINUX)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Enables freezing pages directly from PerformanceManager rather than via
 // TabManager.
 extern const base::Feature kPageFreezingFromPerformanceManager;
--- a/chrome/browser/storage/storage_notification_service_impl.cc
+++ b/chrome/browser/storage/storage_notification_service_impl.cc
@@ -11,7 +11,7 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/chrome_switches.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/storage_pressure_bubble.h"
 #endif
 
--- a/chrome/browser/chrome_browser_main_posix.cc
+++ b/chrome/browser/chrome_browser_main_posix.cc
@@ -173,7 +173,5 @@ void ChromeBrowserMainPartsPosix::ShowMi
   // TODO(port): We may want a views based message dialog here eventually, but
   // for now, crash.
   NOTREACHED();
-#else
-#error "Need MessageBox implementation."
 #endif
 }
--- a/chrome/browser/first_run/first_run_internal_posix.cc
+++ b/chrome/browser/first_run/first_run_internal_posix.cc
@@ -96,7 +96,7 @@ void ForceFirstRunDialogShownForTesting(
 }
 
 void DoPostImportPlatformSpecificTasks(Profile* profile) {
-#if !defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS)
   if (!ShouldShowFirstRunDialog())
     return;
 
--- a/chrome/browser/ui/search/search_ipc_router_policy_impl.h
+++ b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/search/search_ipc_router.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/ntp_user_data_logger.h
+++ b/chrome/browser/ui/search/ntp_user_data_logger.h
@@ -21,7 +21,7 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/engagement/important_sites_util.h
+++ b/chrome/browser/engagement/important_sites_util.h
@@ -76,7 +76,7 @@ class ImportantSitesUtil {
       Profile* profile,
       size_t max_results);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Return the top |<=max_results| important registrable domains that have an
   // associated installed app. |max_results| is assumed to be small.
   static std::vector<ImportantDomainInfo> GetInstalledRegisterableDomains(
--- a/chrome/browser/engagement/important_sites_util.cc
+++ b/chrome/browser/engagement/important_sites_util.cc
@@ -38,7 +38,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
-#else
 #include "chrome/browser/web_applications/components/web_app_id.h"
 #include "chrome/browser/web_applications/web_app_provider.h"
 #include "chrome/browser/web_applications/web_app_registrar.h"
@@ -365,7 +364,7 @@ void PopulateInfoMapWithBookmarks(
 // about clearing data for installed apps, so this and any functions explicitly
 // used to warn about clearing data for installed apps can be excluded from the
 // Android build.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void PopulateInfoMapWithInstalled(
     browsing_data::TimePeriod time_period,
     Profile* profile,
@@ -482,7 +481,7 @@ ImportantSitesUtil::GetImportantRegister
   return final_list;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::vector<ImportantDomainInfo>
 ImportantSitesUtil::GetInstalledRegisterableDomains(
     browsing_data::TimePeriod time_period,
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -259,12 +259,12 @@ extern const char kAllowNaClFileHandleAP
 extern const char kAllowNaClSocketAPI[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_ANDROID)
 extern const char kEnableNewAppMenuIcon[];
 extern const char kGuest[];
 #endif
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 // Only has an effect in branded builds.
 extern const char kEnableChromeBrowserCloudManagement[];
 extern const char kUseSystemDefaultPrinter[];
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -850,14 +850,14 @@ const char kAllowNaClFileHandleAPI[]
 const char kAllowNaClSocketAPI[]            = "allow-nacl-socket-api";
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_ANDROID)
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 
 // Causes the browser to launch directly in guest mode.
 const char kGuest[] = "guest";
 #endif
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 // Enables Machine level user cloud policy on Chromium build. This policy is
 // always enabled on the branded builds.
 const char kEnableChromeBrowserCloudManagement[] =
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -335,7 +335,7 @@ const char kChromeUILinuxProxyConfigHost
 const char kChromeUISandboxHost[] = "sandbox";
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || \
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_ANDROID) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -299,7 +299,7 @@ extern const char kChromeUILinuxProxyCon
 extern const char kChromeUISandboxHost[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || \
+#if defined(OS_WIN) || defined(OS_ANDROID) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
--- a/chrome/browser/profiles/profile_manager.cc
+++ b/chrome/browser/profiles/profile_manager.cc
@@ -126,7 +126,6 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/metrics/android_profile_session_durations_service_factory.h"
 #include "chrome/browser/ntp_snippets/content_suggestions_service_factory.h"
-#else
 #include "chrome/browser/first_run/first_run.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -148,7 +147,7 @@
 #include "components/user_manager/user_type.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/profiles/profile_statistics.h"
 #include "chrome/browser/profiles/profile_statistics_factory.h"
 #endif
@@ -238,7 +237,7 @@ void ProfileSizeTask(const base::FilePat
     UMA_HISTOGRAM_COUNTS_10000("Profile.AppCount", enabled_app_count);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Schedule a profile for deletion if it isn't already scheduled.
 // Returns whether the profile has been newly scheduled.
 bool ScheduleProfileDirectoryForDeletion(const base::FilePath& path) {
@@ -337,7 +336,7 @@ void OnProfileLoaded(ProfileManager::Pro
       .Run(incognito ? profile->GetOffTheRecordProfile() : profile);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Helper function for ScheduleForcedEphemeralProfileForDeletion.
 bool IsProfileEphemeral(ProfileAttributesStorage* storage,
                         const base::FilePath& profile_dir) {
@@ -818,7 +817,7 @@ ProfileShortcutManager* ProfileManager::
   return profile_shortcut_manager_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileManager::MaybeScheduleProfileForDeletion(
     const base::FilePath& profile_dir,
     ProfileLoadedCallback callback,
@@ -1035,7 +1034,7 @@ void ProfileManager::InitProfileUserPref
     } else if (profile->GetPath() ==
                    profiles::GetDefaultProfileDir(user_data_dir())) {
       avatar_index = profiles::GetPlaceholderAvatarIndex();
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
       profile_name =
           base::UTF16ToUTF8(storage.ChooseNameForNewProfile(avatar_index));
 #else
@@ -1259,7 +1258,7 @@ void ProfileManager::DoFinalInitForServi
   ChildAccountServiceFactory::GetForProfile(profile)->Init();
   SupervisedUserServiceFactory::GetForProfile(profile)->Init();
 #endif
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   // If the lock enabled algorithm changed, update this profile's lock status.
   // This depends on services which shouldn't be initialized until
   // DoFinalInitForServices.
@@ -1439,7 +1438,7 @@ Profile* ProfileManager::CreateAndInitia
   return profile_ptr;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileManager::EnsureActiveProfileExistsBeforeDeletion(
     ProfileLoadedCallback callback,
     const base::FilePath& profile_dir) {
@@ -1630,7 +1629,7 @@ void ProfileManager::AddProfileToStorage
     bool has_entry = storage.GetProfileAttributesWithPath(profile->GetPath(),
                                                           &entry);
     if (has_entry) {
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
       bool was_authenticated_status = entry->IsAuthenticated();
 #endif
       // The ProfileAttributesStorage's info must match the Identity Manager.
@@ -1639,7 +1638,7 @@ void ProfileManager::AddProfileToStorage
 
       entry->SetSignedInWithCredentialProvider(false);
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
       // Sign out if force-sign-in policy is enabled and profile is not signed
       // in.
       VLOG(1) << "ForceSigninCheck: " << signin_util::IsForceSigninEnabled()
@@ -1759,7 +1758,7 @@ void ProfileManager::SaveActiveProfiles(
   }
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileManager::OnBrowserOpened(Browser* browser) {
   DCHECK(browser);
   Profile* profile = browser->profile();
--- a/chrome/browser/profiles/profile_manager.h
+++ b/chrome/browser/profiles/profile_manager.h
@@ -201,7 +201,7 @@ class ProfileManager : public content::N
   // profile specfic desktop shortcuts.
   ProfileShortcutManager* profile_shortcut_manager();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Less strict version of ScheduleProfileForDeletion(), silently exits if
   // profile is either scheduling or marked for deletion.
   void MaybeScheduleProfileForDeletion(
@@ -317,7 +317,7 @@ class ProfileManager : public content::N
   // null if creation fails.
   Profile* CreateAndInitializeProfile(const base::FilePath& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Continues the scheduled profile deletion after closing all the profile's
   // browsers tabs. Creates a new profile if the profile to be deleted is the
   // last non-supervised profile. In the Mac, loads the next non-supervised
@@ -372,7 +372,7 @@ class ProfileManager : public content::N
 
   void SaveActiveProfiles();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   void OnBrowserOpened(Browser* browser);
   void OnBrowserClosed(Browser* browser);
 
@@ -436,7 +436,7 @@ class ProfileManager : public content::N
   // default.
   bool logged_in_ = false;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   BrowserListObserver browser_list_observer_{this};
 #endif  // !defined(OS_ANDROID)
 
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.cc
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/native_window_tracker_android.h"
+
+#include "ui/android/window_android.h"
+
+NativeWindowTrackerAndroid::NativeWindowTrackerAndroid(
+    gfx::NativeWindow window)
+    : window_(window) {
+}
+
+NativeWindowTrackerAndroid::~NativeWindowTrackerAndroid() {
+}
+
+bool NativeWindowTrackerAndroid::WasNativeWindowClosed() const {
+  return window_ == nullptr;
+}
+
+// static
+std::unique_ptr<NativeWindowTracker> NativeWindowTracker::Create(
+    gfx::NativeWindow window) {
+  return std::unique_ptr<NativeWindowTracker>(
+      new NativeWindowTrackerAndroid(window));
+}
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.h
@@ -0,0 +1,27 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+#define CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/ui/native_window_tracker.h"
+#include "ui/android/window_android.h"
+
+class NativeWindowTrackerAndroid : public NativeWindowTracker {
+ public:
+  explicit NativeWindowTrackerAndroid(gfx::NativeWindow window);
+  ~NativeWindowTrackerAndroid() override;
+
+  // NativeWindowTracker:
+  bool WasNativeWindowClosed() const override;
+
+ private:
+
+  ui::WindowAndroid* window_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowTrackerAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_AURA_H_
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.cc
@@ -0,0 +1,181 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/policy/browser_dm_token_storage_android.h"
+
+#include <string>
+
+#include "base/base64url.h"
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/callback.h"
+#include "base/files/file_util.h"
+#include "base/files/important_file_writer.h"
+#include "base/hash/sha1.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/syslog_logging.h"
+#include "base/task/post_task.h"
+#include "base/task/task_traits.h"
+#include "base/task_runner_util.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/sequenced_task_runner_handle.h"
+#include "chrome/common/chrome_paths.h"
+
+namespace policy {
+
+namespace {
+
+const char kDmTokenBaseDir[] = FILE_PATH_LITERAL("Policy/Enrollment/");
+const char kEnrollmentTokenFilename[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentToken");
+const char kMachineIdFilename[] = FILE_PATH_LITERAL("/etc/machine-id");
+
+// Enrollment Mandatory Option.
+const char kEnrollmentOptionsFilePath[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentOptions");
+const char kEnrollmentMandatoryOption[] = "Mandatory";
+
+bool GetDmTokenFilePath(base::FilePath* token_file_path,
+                        const std::string& client_id,
+                        bool create_dir) {
+  if (!base::PathService::Get(chrome::DIR_USER_DATA, token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(kDmTokenBaseDir);
+
+  if (create_dir && !base::CreateDirectory(*token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(client_id);
+
+  return true;
+}
+
+bool StoreDMTokenInUserDataDir(const std::string& token,
+                               const std::string& client_id) {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, client_id, true)) {
+    NOTREACHED();
+    return false;
+  }
+
+  return base::ImportantFileWriter::WriteFileAtomically(token_file_path, token);
+}
+
+}  // namespace
+
+// static
+BrowserDMTokenStorage* BrowserDMTokenStorage::Get() {
+  if (storage_for_testing_)
+    return storage_for_testing_;
+
+  static base::NoDestructor<BrowserDMTokenStorageAndroid> storage;
+  return storage.get();
+}
+
+BrowserDMTokenStorageAndroid::BrowserDMTokenStorageAndroid()
+    : task_runner_(
+          base::CreateTaskRunner({base::ThreadPool(), base::MayBlock()})) {}
+
+BrowserDMTokenStorageAndroid::~BrowserDMTokenStorageAndroid() {}
+
+std::string BrowserDMTokenStorageAndroid::InitClientId() {
+  // The client ID is derived from /etc/machine-id
+  // (https://www.freedesktop.org/software/systemd/man/machine-id.html). As per
+  // guidelines, this ID must not be transmitted outside of the machine, which
+  // is why we hash it first and then encode it in base64 before transmitting
+  // it.
+  const int machine_id_size = 32;
+  std::string machine_id;
+  machine_id = ReadMachineIdFile();
+  base::StringPiece machine_id_trimmed =
+      base::TrimWhitespaceASCII(machine_id, base::TRIM_TRAILING);
+  if (machine_id_trimmed.size() != machine_id_size) {
+    SYSLOG(ERROR) << "Error: /etc/machine-id contains "
+                  << machine_id_trimmed.size() << " characters ("
+                  << machine_id_size << " were expected).";
+    return std::string();
+  }
+
+  std::string machine_id_base64;
+  base::Base64UrlEncode(base::SHA1HashString(std::string(machine_id_trimmed)),
+                        base::Base64UrlEncodePolicy::OMIT_PADDING,
+                        &machine_id_base64);
+  return machine_id_base64;
+}
+
+std::string BrowserDMTokenStorageAndroid::InitEnrollmentToken() {
+  std::string enrollment_token;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return std::string();
+  }
+
+  base::FilePath token_file_path =
+      dir_policy_files_path.Append(kEnrollmentTokenFilename);
+
+  if (!base::ReadFileToString(token_file_path, &enrollment_token))
+    return std::string();
+
+  return base::TrimWhitespaceASCII(enrollment_token, base::TRIM_ALL)
+      .as_string();
+}
+
+std::string BrowserDMTokenStorageAndroid::InitDMToken() {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, RetrieveClientId(), false))
+    return std::string();
+
+  std::string token;
+  if (!base::ReadFileToString(token_file_path, &token))
+    return std::string();
+
+  return base::TrimWhitespaceASCII(token, base::TRIM_ALL).as_string();
+}
+
+bool BrowserDMTokenStorageAndroid::InitEnrollmentErrorOption() {
+  std::string options;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return false;
+  }
+
+  base::FilePath options_file_path =
+      dir_policy_files_path.Append(kEnrollmentOptionsFilePath);
+
+  if (!base::ReadFileToString(options_file_path, &options))
+    return false;
+
+  return base::TrimWhitespaceASCII(options, base::TRIM_ALL).as_string() ==
+         kEnrollmentMandatoryOption;
+}
+
+BrowserDMTokenStorage::StoreTask BrowserDMTokenStorageAndroid::SaveDMTokenTask(
+    const std::string& token,
+    const std::string& client_id) {
+  return base::BindOnce(&StoreDMTokenInUserDataDir, token, client_id);
+}
+
+scoped_refptr<base::TaskRunner>
+BrowserDMTokenStorageAndroid::SaveDMTokenTaskRunner() {
+  return task_runner_;
+}
+
+std::string BrowserDMTokenStorageAndroid::ReadMachineIdFile() {
+  std::string machine_id;
+  if (!base::ReadFileToString(base::FilePath(kMachineIdFilename), &machine_id))
+    return std::string();
+  return machine_id;
+}
+
+}  // namespace policy
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.h
@@ -0,0 +1,55 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+
+#include "chrome/browser/policy/browser_dm_token_storage.h"
+
+#include <string>
+
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/sequence_checker.h"
+#include "base/single_thread_task_runner.h"
+
+namespace policy {
+
+// Implementation of BrowserDMTokenStorage for Android. The global singleton
+// instance can be retrieved by calling BrowserDMTokenStorage::Get().
+class BrowserDMTokenStorageAndroid : public BrowserDMTokenStorage {
+ public:
+  // Get the global singleton instance by calling BrowserDMTokenStorage::Get().
+  BrowserDMTokenStorageAndroid();
+  ~BrowserDMTokenStorageAndroid() override;
+
+ private:
+  // override BrowserDMTokenStorage
+  std::string InitClientId() override;
+  std::string InitEnrollmentToken() override;
+  std::string InitDMToken() override;
+  bool InitEnrollmentErrorOption() override;
+  StoreTask SaveDMTokenTask(const std::string& token,
+                            const std::string& client_id) override;
+  scoped_refptr<base::TaskRunner> SaveDMTokenTaskRunner() override;
+
+  // Returns the content of "/etc/machine-id". Virtual for tests.
+  virtual std::string ReadMachineIdFile();
+
+  scoped_refptr<base::TaskRunner> task_runner_;
+
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitClientId);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitEnrollmentToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitDMToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitDMTokenWithoutDirectory);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, SaveDMToken);
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageAndroid);
+};
+
+}  // namespace policy
+#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
--- a/components/ui_devtools/views/overlay_agent_views.cc
+++ b/components/ui_devtools/views/overlay_agent_views.cc
@@ -19,6 +19,8 @@
 #include "ui/views/background.h"
 #include "ui/views/border.h"
 
+#include "ui/android/window_android.h"
+
 #if defined(USE_AURA)
 #include "ui/aura/window.h"
 #include "ui/wm/core/window_util.h"
@@ -567,7 +569,6 @@ void OverlayAgentViews::OnPaintLayer(con
   gfx::Canvas* canvas = recorder.canvas();
   // Convert the hovered rect from screen coordinates to layer coordinates.
   gfx::RectF hovered_rect_f(hovered_rect_);
-  hovered_rect_f.Offset(-layer_for_highlighting_screen_offset_);
 
   cc::PaintFlags flags;
   flags.setStrokeWidth(1.0f);
@@ -601,7 +602,6 @@ void OverlayAgentViews::OnPaintLayer(con
 
   // Convert the pinned rect from screen coordinates to layer coordinates.
   gfx::RectF pinned_rect_f(pinned_rect_);
-  pinned_rect_f.Offset(-layer_for_highlighting_screen_offset_);
 
   // Draw |pinned_rect_f| bounds in blue.
   canvas->DrawRect(pinned_rect_f, flags);
@@ -706,35 +706,7 @@ void OverlayAgentViews::OnPaintLayer(con
 
 bool OverlayAgentViews::UpdateHighlight(
     const std::pair<gfx::NativeWindow, gfx::Rect>& window_and_bounds) {
-  if (window_and_bounds.second.IsEmpty()) {
-    hovered_rect_.SetRect(0, 0, 0, 0);
-    return false;
-  }
-  ui::Layer* root_layer = nullptr;
-#if defined(OS_MACOSX)
-  views::Widget* widget =
-      views::Widget::GetWidgetForNativeWindow(window_and_bounds.first);
-  root_layer = widget->GetLayer();
-  layer_for_highlighting_screen_offset_ =
-      widget->GetContentsView()->GetBoundsInScreen().OffsetFromOrigin();
-#else
-  gfx::NativeWindow root = window_and_bounds.first->GetRootWindow();
-  root_layer = root->layer();
-  layer_for_highlighting_screen_offset_ =
-      root->GetBoundsInScreen().OffsetFromOrigin();
-#endif  // defined(OS_MACOSX)
-  DCHECK(root_layer);
-
-  layer_for_highlighting_->SetBounds(root_layer->bounds());
-  layer_for_highlighting_->SchedulePaint(root_layer->bounds());
-
-  if (root_layer != layer_for_highlighting_->parent())
-    root_layer->Add(layer_for_highlighting_.get());
-  else
-    root_layer->StackAtTop(layer_for_highlighting_.get());
-
-  hovered_rect_ = window_and_bounds.second;
-  return true;
+  return false;
 }
 
 }  // namespace ui_devtools
--- a/components/url_formatter/elide_url.cc
+++ b/components/url_formatter/elide_url.cc
@@ -26,7 +26,7 @@
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::char16 kDot = '.';
 
 // Build a path from the first |num_components| elements in |path_elements|.
@@ -145,7 +145,7 @@ base::string16 HostForDisplay(base::Stri
 
 namespace url_formatter {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 // TODO(pkasting): http://crbug.com/77883 This whole function gets
 // kerning/ligatures/etc. issues potentially wrong by assuming that the width of
--- a/components/url_formatter/elide_url.h
+++ b/components/url_formatter/elide_url.h
@@ -26,7 +26,7 @@ namespace url_formatter {
 
 // ElideUrl and Elide host require
 // gfx::GetStringWidthF which is not implemented in Android
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // This function takes a GURL object and elides it. It returns a string
 // composed of parts from subdomain, domain, path, filename and query.
 // A "..." is added automatically at the end if the elided string is bigger
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -27,22 +27,20 @@ const DesktopMediaID::Id DesktopMediaID:
 // static
 const DesktopMediaID::Id DesktopMediaID::kFakeId = -3;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || defined(OS_ANDROID)
 // static
 DesktopMediaID DesktopMediaID::RegisterNativeWindow(DesktopMediaID::Type type,
                                                     gfx::NativeWindow window) {
   DCHECK(type == TYPE_SCREEN || type == TYPE_WINDOW);
   DCHECK(window);
   DesktopMediaID media_id(type, kNullId);
-  media_id.window_id =
-      DesktopMediaWindowRegistry::GetInstance()->RegisterWindow(window);
   return media_id;
 }
 
 // static
 gfx::NativeWindow DesktopMediaID::GetNativeWindowById(
     const DesktopMediaID& id) {
-  return DesktopMediaWindowRegistry::GetInstance()->GetWindowById(id.window_id);
+  return nullptr;
 }
 #endif
 
--- a/content/public/browser/desktop_media_id.h
+++ b/content/public/browser/desktop_media_id.h
@@ -28,7 +28,7 @@ struct CONTENT_EXPORT DesktopMediaID {
   // Represents a fake id to create a dummy capturer for autotests.
   static const Id kFakeId;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || defined(OS_ANDROID)
   // Assigns integer identifier to the |window| and returns its DesktopMediaID.
   static DesktopMediaID RegisterNativeWindow(Type type,
                                              gfx::NativeWindow window);
--- a/chrome/browser/ui/passwords/password_generation_popup_controller_impl.cc
+++ b/chrome/browser/ui/passwords/password_generation_popup_controller_impl.cc
@@ -271,7 +271,7 @@ void PasswordGenerationPopupControllerIm
   }
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void PasswordGenerationPopupControllerImpl::OnZoomChanged(
     const zoom::ZoomController::ZoomChangedEventData& data) {
   Hide(PopupHidingReason::kContentAreaMoved);
--- a/chrome/browser/ui/passwords/password_generation_popup_controller_impl.h
+++ b/chrome/browser/ui/passwords/password_generation_popup_controller_impl.h
@@ -24,7 +24,7 @@
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "components/zoom/zoom_observer.h"
 #endif  // !defined(OS_ANDROID)
 
@@ -59,7 +59,7 @@ class PasswordGenerationPopupView;
 class PasswordGenerationPopupControllerImpl
     : public PasswordGenerationPopupController,
       public content::WebContentsObserver
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     ,
       public zoom::ZoomObserver
 #endif  // !defined(OS_ANDROID)
@@ -106,7 +106,7 @@ class PasswordGenerationPopupControllerI
   void DidFinishNavigation(
       content::NavigationHandle* navigation_handle) override;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // ZoomObserver implementation.
   void OnZoomChanged(
       const zoom::ZoomController::ZoomChangedEventData& data) override;
--- a/content/public/browser/native_web_keyboard_event.h
+++ b/content/public/browser/native_web_keyboard_event.h
@@ -48,7 +48,6 @@ struct CONTENT_EXPORT NativeWebKeyboardE
       int scancode,
       int unicode_character,
       bool is_system_key);
-#else
   explicit NativeWebKeyboardEvent(const ui::KeyEvent& key_event);
 #if defined(USE_AURA)
   // Create a legacy keypress event specified by |character|.
--- a/content/browser/renderer_host/native_web_keyboard_event_android.cc
+++ b/content/browser/renderer_host/native_web_keyboard_event_android.cc
@@ -64,6 +64,8 @@ NativeWebKeyboardEvent& NativeWebKeyboar
   return *this;
 }
 
+NativeWebKeyboardEvent::NativeWebKeyboardEvent(const ui::KeyEvent& key_event) {}
+
 NativeWebKeyboardEvent::~NativeWebKeyboardEvent() {}
 
 }  // namespace content
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1699,7 +1699,6 @@ void BrowserView::UserChangedTheme(Brows
   // In Incognito, the usage of dark or normal hinges on the browser theme.
   if (theme_change_type == BrowserThemeChangeType::kBrowserTheme &&
       !IsRegularOrGuestSession()) {
-    ui::NativeTheme::GetInstanceForDarkUI()->NotifyObservers();
     ui::NativeTheme::GetInstanceForNativeUi()->NotifyObservers();
 
     // Early exit. A native theme change will update all the
@@ -3215,7 +3214,7 @@ void BrowserView::ShowAvatarBubbleFromAv
   profiles::BubbleViewMode bubble_view_mode;
   profiles::BubbleViewModeFromAvatarBubbleMode(mode, GetProfile(),
                                                &bubble_view_mode);
-#if !defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS)
   if (SigninViewController::ShouldShowSigninForMode(bubble_view_mode)) {
     browser_->signin_view_controller()->ShowSignin(bubble_view_mode,
                                                    access_point);
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -235,7 +235,7 @@ void LocationBarView::Init() {
     // The send tab to self icon is intentionally the first one added so it is
     // the left most icon.
     params.types_enabled.push_back(PageActionIconType::kSendTabToSelf);
-    if (base::FeatureList::IsEnabled(kClickToCallUI))
+    if (false)
       params.types_enabled.push_back(PageActionIconType::kClickToCall);
     if (base::FeatureList::IsEnabled(kSharingQRCodeGenerator))
       params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
--- a/components/omnibox/browser/omnibox_popup_model.cc
+++ b/components/omnibox/browser/omnibox_popup_model.cc
@@ -21,7 +21,7 @@
 #include "third_party/icu/source/common/unicode/ubidi.h"
 #include "ui/gfx/geometry/rect.h"
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #include "ui/gfx/paint_vector_icon.h"
 #include "ui/gfx/vector_icon_types.h"
@@ -328,7 +328,7 @@ void OmniboxPopupModel::SetRichSuggestio
 }
 
 // Android and iOS have their own platform-specific icon logic.
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
 gfx::Image OmniboxPopupModel::GetMatchIcon(const AutocompleteMatch& match,
                                            SkColor vector_icon_color) {
   gfx::Image extension_icon =
--- a/components/omnibox/browser/omnibox_popup_model.h
+++ b/components/omnibox/browser/omnibox_popup_model.h
@@ -188,7 +188,7 @@ class OmniboxPopupModel {
   // Stores the image in a local data member and schedules a repaint.
   void SetRichSuggestionBitmap(int result_index, const SkBitmap& bitmap);
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   // Gets the icon for the match index.
   gfx::Image GetMatchIcon(const AutocompleteMatch& match,
                           SkColor vector_icon_color);
--- a/third_party/blink/public/mojom/payments/payment_request.mojom
+++ b/third_party/blink/public/mojom/payments/payment_request.mojom
@@ -214,8 +214,7 @@ interface PaymentRequest {
   Init(pending_remote<PaymentRequestClient> client,
        array<PaymentMethodData> method_data,
        PaymentDetails details,
-       PaymentOptions options,
-       [EnableIf=is_android] bool google_pay_bridge_eligible);
+       PaymentOptions options);
 
   // Shows the user interface with the payment details.
   Show(bool is_user_gesture, bool wait_for_updated_details);
--- a/third_party/blink/renderer/modules/payments/payment_request.cc
+++ b/third_party/blink/renderer/modules/payments/payment_request.cc
@@ -1148,7 +1148,7 @@ PaymentRequest::PaymentRequest(
   UseCounter::Count(execution_context, WebFeature::kPaymentRequestInitialized);
   mojo::PendingRemote<payments::mojom::blink::PaymentRequestClient> client;
   client_receiver_.Bind(client.InitWithNewPipeAndPassReceiver(), task_runner);
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   payment_provider_->Init(
       std::move(client), std::move(validated_method_data),
       std::move(validated_details),
--- a/chrome/android/java/src/org/chromium/chrome/browser/payments/PaymentRequestImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/payments/PaymentRequestImpl.java
@@ -613,7 +613,7 @@ public class PaymentRequestImpl
      */
     @Override
     public void init(PaymentRequestClient client, PaymentMethodData[] methodData,
-            PaymentDetails details, PaymentOptions options, boolean googlePayBridgeEligible) {
+            PaymentDetails details, PaymentOptions options) {
         if (mClient != null) {
             mJourneyLogger.setAborted(AbortReason.INVALID_DATA_FROM_RENDERER);
             disconnectFromClientWithDebugMessage(ErrorStrings.ATTEMPTED_INITIALIZATION_TWICE);
@@ -672,21 +672,13 @@ public class PaymentRequestImpl
             return;
         }
 
-        boolean googlePayBridgeActivated = googlePayBridgeEligible
-                && SkipToGPayHelper.canActivateExperiment(mWebContents, methodData);
-
-        mMethodData = getValidatedMethodData(methodData, googlePayBridgeActivated, mCardEditor);
+        mMethodData = getValidatedMethodData(methodData, false, mCardEditor);
         if (mMethodData == null) {
             mJourneyLogger.setAborted(AbortReason.INVALID_DATA_FROM_RENDERER);
             disconnectFromClientWithDebugMessage(ErrorStrings.INVALID_PAYMENT_METHODS_OR_DATA);
             return;
         }
 
-        if (googlePayBridgeActivated) {
-            PaymentMethodData data = mMethodData.get(MethodStrings.GOOGLE_PAY);
-            mSkipToGPayHelper = new SkipToGPayHelper(options, data.gpayBridgeData);
-        }
-
         mQueryForQuota = new HashMap<>(mMethodData);
         if (mQueryForQuota.containsKey(MethodStrings.BASIC_CARD)
                 && PaymentsExperimentalFeatures.isEnabled(
--- a/chrome/android/java/src/org/chromium/chrome/browser/payments/PaymentRequestFactory.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/payments/PaymentRequestFactory.java
@@ -48,8 +48,7 @@ public class PaymentRequestFactory imple
 
         @Override
         public void init(PaymentRequestClient client, PaymentMethodData[] methodData,
-                PaymentDetails details, PaymentOptions options,
-                boolean unusedGooglePayBridgeEligible) {
+                PaymentDetails details, PaymentOptions options) {
             mClient = client;
         }
 
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
@@ -108,12 +108,9 @@ void PermissionPromptBubbleView::AddPerm
 
   auto* icon =
       line_container->AddChildView(std::make_unique<views::ImageView>());
-  const gfx::VectorIcon& vector_id = request->GetIconId();
   const SkColor icon_color = icon->GetNativeTheme()->GetSystemColor(
       ui::NativeTheme::kColorId_DefaultIconColor);
   constexpr int kPermissionIconSize = 18;
-  icon->SetImage(
-      gfx::CreateVectorIcon(vector_id, kPermissionIconSize, icon_color));
   icon->SetVerticalAlignment(views::ImageView::Alignment::kLeading);
 
   auto* label = line_container->AddChildView(
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -136,21 +136,9 @@ class TabHoverCardEventSniffer : public
       : hover_card_(hover_card),
         tab_strip_(tab_strip),
         widget_(tab_strip->GetWidget()) {
-#if defined(OS_MACOSX)
-    if (widget_->GetRootView())
-      widget_->GetRootView()->AddPreTargetHandler(this);
-#else
-    if (widget_->GetNativeWindow())
-      widget_->GetNativeWindow()->AddPreTargetHandler(this);
-#endif
   }
 
   ~TabHoverCardEventSniffer() override {
-#if defined(OS_MACOSX)
-    widget_->GetRootView()->RemovePreTargetHandler(this);
-#else
-    widget_->GetNativeWindow()->RemovePreTargetHandler(this);
-#endif
   }
 
  protected:
--- a/components/omnibox/browser/autocomplete_match.cc
+++ b/components/omnibox/browser/autocomplete_match.cc
@@ -34,7 +34,7 @@
 #include "ui/gfx/vector_icon_types.h"
 #include "url/third_party/mozilla/url_parse.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #include "components/vector_icons/vector_icons.h"     // nogncheck
 #endif
@@ -228,7 +228,7 @@ AutocompleteMatch& AutocompleteMatch::op
   return *this;
 }
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 const gfx::VectorIcon& AutocompleteMatch::GetVectorIcon(
     bool is_bookmark) const {
   if (is_bookmark)
--- a/components/omnibox/browser/autocomplete_match.h
+++ b/components/omnibox/browser/autocomplete_match.h
@@ -159,7 +159,7 @@ struct AutocompleteMatch {
 
   AutocompleteMatch& operator=(const AutocompleteMatch& match);
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
   // Gets the vector icon identifier for the icon to be shown for this match. If
   // |is_bookmark| is true, returns a bookmark icon rather than what the type
   // would normally determine.  Note that in addition to |type|, the icon chosen
--- a/components/omnibox/browser/omnibox_pedal.cc
+++ b/components/omnibox/browser/omnibox_pedal.cc
@@ -13,7 +13,7 @@
 #include "components/omnibox/browser/omnibox_field_trial.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #endif
 
@@ -117,7 +117,7 @@ bool OmniboxPedal::IsReadyToTrigger(
   return true;
 }
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 const gfx::VectorIcon& OmniboxPedal::GetVectorIcon() const {
   return omnibox::kPedalIcon;
 }
--- a/components/omnibox/browser/omnibox_pedal.h
+++ b/components/omnibox/browser/omnibox_pedal.h
@@ -15,7 +15,7 @@
 #include "components/omnibox/browser/buildflags.h"
 #include "url/gurl.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 namespace gfx {
 struct VectorIcon;
 }
@@ -132,7 +132,7 @@ class OmniboxPedal {
   // Pedal may not be ready to trigger if no update is available.)
   virtual bool IsReadyToTrigger(const AutocompleteProviderClient& client) const;
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
   // Returns the vector icon to represent this Pedal's action in suggestion.
   virtual const gfx::VectorIcon& GetVectorIcon() const;
 #endif
--- a/components/omnibox/browser/omnibox_pedal_implementations.cc
+++ b/components/omnibox/browser/omnibox_pedal_implementations.cc
@@ -12,7 +12,7 @@
 #include "components/omnibox/browser/omnibox_pedal.h"
 #include "components/strings/grit/components_strings.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #endif
 
@@ -26,7 +26,7 @@ OmniboxPedalClearBrowsingData::OmniboxPe
               IDS_OMNIBOX_PEDAL_CLEAR_BROWSING_DATA_SUGGESTION_CONTENTS),
           GURL("chrome://settings/clearBrowserData")) {}
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 const gfx::VectorIcon& OmniboxPedalClearBrowsingData::GetVectorIcon() const {
   return omnibox::kAnswerWhenIsIcon;
 }
--- a/components/omnibox/browser/omnibox_pedal_implementations.h
+++ b/components/omnibox/browser/omnibox_pedal_implementations.h
@@ -15,7 +15,7 @@
 class OmniboxPedalClearBrowsingData : public OmniboxPedal {
  public:
   OmniboxPedalClearBrowsingData();
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
   const gfx::VectorIcon& GetVectorIcon() const override;
 #endif
 };
--- a/chrome/browser/ui/views/browser_dialogs_views.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views.cc
@@ -17,15 +17,6 @@
 // This file provides definitions of desktop browser dialog-creation methods for
 // all toolkit-views platforms.
 // static
-std::unique_ptr<LoginHandler> LoginHandler::Create(
-    const net::AuthChallengeInfo& auth_info,
-    content::WebContents* web_contents,
-    LoginAuthRequiredCallback auth_required_callback) {
-  return chrome::CreateLoginHandlerViews(auth_info, web_contents,
-                                         std::move(auth_required_callback));
-}
-
-// static
 void BookmarkEditor::Show(gfx::NativeWindow parent_window,
                           Profile* profile,
                           const EditDetails& details,
--- a/chrome/browser/ui/content_settings/content_setting_image_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_image_model.cc
@@ -232,8 +232,6 @@ const ContentSettingsImageDetails kImage
      IDS_BLOCKED_PLUGINS_MESSAGE, IDS_BLOCKED_PLUGIN_EXPLANATORY_TEXT, 0},
     {ContentSettingsType::MIXEDSCRIPT, kMixedContentIcon,
      IDS_BLOCKED_DISPLAYING_INSECURE_CONTENT, 0, 0},
-    {ContentSettingsType::PPAPI_BROKER, vector_icons::kExtensionIcon,
-     IDS_BLOCKED_PPAPI_BROKER_MESSAGE, 0, IDS_ALLOWED_PPAPI_BROKER_MESSAGE},
     {ContentSettingsType::SOUND, kTabAudioIcon, IDS_BLOCKED_SOUND_TITLE, 0, 0},
     {ContentSettingsType::ADS, vector_icons::kAdsIcon,
      IDS_BLOCKED_ADS_PROMPT_TOOLTIP, IDS_BLOCKED_ADS_PROMPT_TITLE, 0},
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
@@ -208,7 +208,6 @@ void ContentSettingSimpleBubbleModel::Se
       {ContentSettingsType::PLUGINS, IDS_BLOCKED_PLUGINS_TITLE},
       {ContentSettingsType::MIXEDSCRIPT,
        IDS_BLOCKED_DISPLAYING_INSECURE_CONTENT_TITLE},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_TITLE},
       {ContentSettingsType::SOUND, IDS_BLOCKED_SOUND_TITLE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE, IDS_BLOCKED_CLIPBOARD_TITLE},
       {ContentSettingsType::SENSORS, IDS_BLOCKED_SENSORS_TITLE},
@@ -216,7 +215,6 @@ void ContentSettingSimpleBubbleModel::Se
   // Fields as for kBlockedTitleIDs, above.
   static const ContentSettingsTypeIdEntry kAccessedTitleIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ACCESSED_COOKIES_TITLE},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_TITLE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE, IDS_ALLOWED_CLIPBOARD_TITLE},
       {ContentSettingsType::SENSORS, IDS_ALLOWED_SENSORS_TITLE},
   };
@@ -245,7 +243,6 @@ void ContentSettingSimpleBubbleModel::Se
       // {ContentSettingsType::POPUPS, No message. intentionally left out},
       {ContentSettingsType::MIXEDSCRIPT,
        IDS_BLOCKED_DISPLAYING_INSECURE_CONTENT},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_MESSAGE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
        IDS_BLOCKED_CLIPBOARD_MESSAGE},
       {ContentSettingsType::SENSORS,
@@ -256,7 +253,6 @@ void ContentSettingSimpleBubbleModel::Se
   // Fields as for kBlockedMessageIDs, above.
   const ContentSettingsTypeIdEntry kAccessedMessageIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ACCESSED_COOKIES_MESSAGE},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_MESSAGE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
        IDS_ALLOWED_CLIPBOARD_MESSAGE},
       {ContentSettingsType::SENSORS,
@@ -689,8 +685,7 @@ ContentSettingPluginBubbleModel::Content
       GetSettingManagedByUser(url, content_type(), GetProfile(), nullptr);
   HostContentSettingsMap* map =
       HostContentSettingsMapFactory::GetForProfile(GetProfile());
-  ContentSetting setting = PluginUtils::GetFlashPluginContentSetting(
-      map, url::Origin::Create(url), url, nullptr);
+  ContentSetting setting = CONTENT_SETTING_BLOCK;
 
   // If the setting is not managed by the user, hide the "Manage" button.
   if (!managed_by_user)
@@ -794,7 +789,6 @@ void ContentSettingSingleRadioGroup::Set
       {ContentSettingsType::IMAGES, IDS_BLOCKED_IMAGES_UNBLOCK},
       {ContentSettingsType::JAVASCRIPT, IDS_BLOCKED_JAVASCRIPT_UNBLOCK},
       {ContentSettingsType::POPUPS, IDS_BLOCKED_POPUPS_REDIRECTS_UNBLOCK},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_UNBLOCK},
       {ContentSettingsType::SOUND, IDS_BLOCKED_SOUND_UNBLOCK},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
        IDS_BLOCKED_CLIPBOARD_UNBLOCK},
@@ -803,7 +797,6 @@ void ContentSettingSingleRadioGroup::Set
   // Fields as for kBlockedAllowIDs, above.
   static const ContentSettingsTypeIdEntry kAllowedAllowIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ALLOWED_COOKIES_NO_ACTION},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_NO_ACTION},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
        IDS_ALLOWED_CLIPBOARD_NO_ACTION},
       {ContentSettingsType::SENSORS, IDS_ALLOWED_SENSORS_NO_ACTION},
@@ -826,7 +819,6 @@ void ContentSettingSingleRadioGroup::Set
       {ContentSettingsType::IMAGES, IDS_BLOCKED_IMAGES_NO_ACTION},
       {ContentSettingsType::JAVASCRIPT, IDS_BLOCKED_JAVASCRIPT_NO_ACTION},
       {ContentSettingsType::POPUPS, IDS_BLOCKED_POPUPS_REDIRECTS_NO_ACTION},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_NO_ACTION},
       {ContentSettingsType::SOUND, IDS_BLOCKED_SOUND_NO_ACTION},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
        IDS_BLOCKED_CLIPBOARD_NO_ACTION},
@@ -834,7 +826,6 @@ void ContentSettingSingleRadioGroup::Set
   };
   static const ContentSettingsTypeIdEntry kAllowedBlockIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ALLOWED_COOKIES_BLOCK},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_BLOCK},
       {ContentSettingsType::CLIPBOARD_READ_WRITE, IDS_ALLOWED_CLIPBOARD_BLOCK},
       {ContentSettingsType::SENSORS, IDS_ALLOWED_SENSORS_BLOCK},
   };
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.h
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
@@ -505,7 +505,7 @@ class ContentSettingSingleRadioGroup : p
   DISALLOW_COPY_AND_ASSIGN(ContentSettingSingleRadioGroup);
 };
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // The model for the blocked Framebust bubble.
 class ContentSettingFramebustBlockBubbleModel
     : public ContentSettingSingleRadioGroup,
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
@@ -45,7 +45,7 @@
 #include "components/undo/undo_operation.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/extensions/api/passwords_private/passwords_private_utils.h"
 #endif
 
@@ -101,7 +101,7 @@ FormVector GetEntryList(const std::map<s
   return result;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 password_manager::metrics_util::AccessPasswordInSettingsEvent
 ConvertPlaintextReason(password_manager::PlaintextReason reason) {
   switch (reason) {
@@ -357,7 +357,7 @@ void PasswordManagerPresenter::UndoRemov
   undo_manager_.Undo();
 }
 
-#if !defined(OS_ANDROID)  // This is never called on Android.
+#if defined(OS_ANDROID)  // This is never called on Android.
 void PasswordManagerPresenter::RequestPlaintextPassword(
     const std::string& sort_key,
     password_manager::PlaintextReason reason,
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.cc
@@ -0,0 +1,50 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/global_shortcut_listener_android.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace extensions {
+
+// static
+GlobalShortcutListener* GlobalShortcutListener::GetInstance() {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+  static GlobalShortcutListenerAndroid* instance =
+      new GlobalShortcutListenerAndroid();
+  return instance;
+}
+
+GlobalShortcutListenerAndroid::GlobalShortcutListenerAndroid()
+    : is_listening_(false) {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+}
+
+GlobalShortcutListenerAndroid::~GlobalShortcutListenerAndroid() {
+  if (is_listening_)
+    StopListening();
+}
+
+void GlobalShortcutListenerAndroid::StartListening() {
+  DCHECK(!is_listening_);  // Don't start twice.
+  is_listening_ = true;
+}
+
+void GlobalShortcutListenerAndroid::StopListening() {
+  DCHECK(is_listening_);  // No point if we are not already listening.
+  is_listening_ = false;
+}
+
+bool GlobalShortcutListenerAndroid::RegisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  return false;
+}
+
+void GlobalShortcutListenerAndroid::UnregisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+}
+
+}  // namespace extensions
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.h
@@ -0,0 +1,36 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/extensions/global_shortcut_listener.h"
+
+namespace extensions {
+
+// Android-specific implementation of the GlobalShortcutListener class that
+// listens for global shortcuts. Handles basic keyboard intercepting and
+// forwards its output to the base class for processing.
+class GlobalShortcutListenerAndroid : public GlobalShortcutListener {
+ public:
+  GlobalShortcutListenerAndroid();
+  ~GlobalShortcutListenerAndroid() override;
+
+ private:
+  // GlobalShortcutListener implementation.
+  void StartListening() override;
+  void StopListening() override;
+  bool RegisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+  void UnregisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+
+  // Whether this object is listening for global shortcuts.
+  bool is_listening_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcutListenerAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
--- a/chrome/browser/ui/webui/signin/login_ui_service.cc
+++ b/chrome/browser/ui/webui/signin/login_ui_service.cc
@@ -78,17 +78,6 @@ void LoginUIService::ShowExtensionLoginP
   chrome::ScopedTabbedBrowserDisplayer displayer(
       profile_->GetOriginalProfile());
   Browser* browser = displayer.browser();
-
-  if (enable_sync) {
-    // Set a primary account.
-    browser->signin_view_controller()->ShowDiceEnableSyncTab(
-        signin_metrics::AccessPoint::ACCESS_POINT_EXTENSIONS,
-        signin_metrics::PromoAction::PROMO_ACTION_NO_SIGNIN_PROMO, email_hint);
-  } else {
-    // Add an account to the web without setting a primary account.
-    browser->signin_view_controller()->ShowDiceAddAccountTab(
-        signin_metrics::AccessPoint::ACCESS_POINT_EXTENSIONS, email_hint);
-  }
 #endif
 }
 
--- a/chrome/browser/platform_util.cc
+++ b/chrome/browser/platform_util.cc
@@ -56,24 +56,6 @@ void DisableShellOperationsForTesting()
 
 }  // namespace internal
 
-void OpenItem(Profile* profile,
-              const base::FilePath& full_path,
-              OpenItemType item_type,
-              const OpenOperationCallback& callback) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  // TaskPriority::USER_BLOCKING because this is usually opened as a result of a
-  // user action (e.g. open-downloaded-file or show-item-in-folder).
-  // TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN because this doesn't need global
-  // state and can hang shutdown without this trait as it may result in an
-  // interactive dialog.
-  base::ThreadPool::PostTask(
-      FROM_HERE,
-      {base::MayBlock(), base::TaskPriority::USER_BLOCKING,
-       base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
-      base::BindOnce(&VerifyAndOpenItemOnBlockingThread, full_path, item_type,
-                     callback));
-}
-
 bool IsBrowserLockedFullscreen(const Browser* browser) {
   return false;
 }
--- a/chrome/browser/sessions/session_restore.cc
+++ b/chrome/browser/sessions/session_restore.cc
@@ -806,31 +806,6 @@ void SessionRestore::OpenStartupPagesAft
 }
 
 // static
-std::vector<Browser*> SessionRestore::RestoreForeignSessionWindows(
-    Profile* profile,
-    std::vector<const sessions::SessionWindow*>::const_iterator begin,
-    std::vector<const sessions::SessionWindow*>::const_iterator end) {
-  std::vector<GURL> gurls;
-  SessionRestoreImpl restorer(profile, static_cast<Browser*>(nullptr), true,
-                              false, true, gurls,
-                              on_session_restored_callbacks());
-  return restorer.RestoreForeignSession(begin, end);
-}
-
-// static
-WebContents* SessionRestore::RestoreForeignSessionTab(
-    content::WebContents* source_web_contents,
-    const sessions::SessionTab& tab,
-    WindowOpenDisposition disposition) {
-  Browser* browser = chrome::FindBrowserWithWebContents(source_web_contents);
-  Profile* profile = browser->profile();
-  std::vector<GURL> gurls;
-  SessionRestoreImpl restorer(profile, browser, true, false, false, gurls,
-                              on_session_restored_callbacks());
-  return restorer.RestoreForeignTab(tab, disposition);
-}
-
-// static
 bool SessionRestore::IsRestoring(const Profile* profile) {
   if (active_session_restorers == nullptr)
     return false;
--- /dev/null
+++ b/chrome/browser/obsolete_system/obsolete_system_android.cc
@@ -0,0 +1,25 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/obsolete_system/obsolete_system.h"
+
+// static
+bool ObsoleteSystem::IsObsoleteNowOrSoon() {
+  return false;
+}
+
+// static
+base::string16 ObsoleteSystem::LocalizedObsoleteString() {
+  return base::string16();
+}
+
+// static
+bool ObsoleteSystem::IsEndOfTheLine() {
+  return false;
+}
+
+// static
+const char* ObsoleteSystem::GetLinkURL() {
+  return "";
+}
--- a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
@@ -63,7 +63,7 @@ std::vector<GURL> GetURLsToOpen(
   return urls;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 bool ShouldOpenAll(gfx::NativeWindow parent,
                    const std::vector<const BookmarkNode*>& nodes) {
   size_t child_count = GetURLsToOpen(nodes).size();
@@ -89,7 +89,7 @@ int ChildURLCountTotal(const BookmarkNod
                          count_children);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns in |urls|, the url and title pairs for each open tab in browser.
 void GetURLsForOpenTabs(Browser* browser,
                         std::vector<std::pair<GURL, base::string16>>* urls) {
@@ -104,7 +104,7 @@ void GetURLsForOpenTabs(Browser* browser
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void OpenAll(gfx::NativeWindow parent,
              content::PageNavigator* navigator,
              const std::vector<const BookmarkNode*>& nodes,
--- /dev/null
+++ b/chrome/browser/ui/window_sizer/window_sizer_android.cc
@@ -0,0 +1,16 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/window_sizer/window_sizer.h"
+
+// static
+const int WindowSizer::kWindowTilePixels = 10;
+const int WindowSizer::kWindowMaxDefaultWidth = 1050;
+
+// static
+gfx::Point WindowSizer::GetDefaultPopupOrigin(const gfx::Size& size) {
+  // TODO(skuhne): Check if this isn't needed anymore (since it is implemented
+  // in WindowPositioner) and remove it.
+  return gfx::Point();
+}
--- a/chrome/browser/ui/views/autofill/payments/save_card_manage_cards_bubble_views.cc
+++ b/chrome/browser/ui/views/autofill/payments/save_card_manage_cards_bubble_views.cc
@@ -59,22 +59,7 @@ SaveCardManageCardsBubbleViews::CreateSi
   // ChromeOS does not show the signin promo.
   return nullptr;
 #else
-  if (!controller()->ShouldShowSignInPromo())
-    return nullptr;
-  sync_promo_delegate_ =
-      std::make_unique<SaveCardManageCardsBubbleViews::SyncPromoDelegate>(
-          controller(),
-          signin_metrics::AccessPoint::ACCESS_POINT_MANAGE_CARDS_BUBBLE);
-  std::unique_ptr<views::View> promo_view =
-      std::make_unique<DiceBubbleSyncPromoView>(
-          controller()->GetProfile(), sync_promo_delegate_.get(),
-          signin_metrics::AccessPoint::ACCESS_POINT_MANAGE_CARDS_BUBBLE,
-          IDS_AUTOFILL_SYNC_PROMO_MESSAGE,
-          /*dice_signin_button_prominent=*/false,
-          views::style::STYLE_SECONDARY);
-  DCHECK(promo_view);
-  InitFootnoteView(promo_view.get());
-  return promo_view;
+  return nullptr;
 #endif
 }
 
--- a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
@@ -299,13 +299,6 @@ std::unique_ptr<views::View> BookmarkBub
   // ChromeOS does not show the signin promo.
   return nullptr;
 #else
-  if (!SyncPromoUI::ShouldShowSyncPromo(profile_))
-    return nullptr;
-
-  return std::make_unique<DiceBubbleSyncPromoView>(
-      profile_, delegate_.get(),
-      signin_metrics::AccessPoint::ACCESS_POINT_BOOKMARK_BUBBLE,
-      IDS_BOOKMARK_DICE_PROMO_SYNC_MESSAGE,
-      /*dice_signin_button_prominent=*/false);
+  return nullptr;
 #endif
 }
--- a/components/bookmarks/browser/bookmark_node_data.h
+++ b/components/bookmarks/browser/bookmark_node_data.h
@@ -18,20 +18,16 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #include "url/gurl.h"
 
-#if defined(TOOLKIT_VIEWS)
 #include "ui/base/clipboard/clipboard_format_type.h"
-#endif
 
 namespace base {
 class Pickle;
 class PickleIterator;
 }
 
-#if defined(TOOLKIT_VIEWS)
 namespace ui {
 class OSExchangeData;
 }
-#endif
 
 namespace bookmarks {
 
@@ -114,9 +110,7 @@ struct BookmarkNodeData {
 
   ~BookmarkNodeData();
 
-#if defined(TOOLKIT_VIEWS)
   static const ui::ClipboardFormatType& GetBookmarkFormatType();
-#endif
 
   static bool ClipboardContainsBookmarks();
 
@@ -133,7 +127,6 @@ struct BookmarkNodeData {
   // WriteToClipboard() but will also attempt to read a plain bookmark.
   bool ReadFromClipboard(ui::ClipboardBuffer buffer);
 
-#if defined(TOOLKIT_VIEWS)
   // Writes elements to data. If there is only one element and it is a URL
   // the URL and title are written to the clipboard in a format other apps can
   // use.
@@ -144,7 +137,6 @@ struct BookmarkNodeData {
 
   // Restores this data from the clipboard, returning true on success.
   bool Read(const ui::OSExchangeData& data);
-#endif
 
 #if !defined(OS_MACOSX)
   // Writes the data for a drag to |pickle|.
--- a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
+++ b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
@@ -48,9 +48,6 @@ void BrowserContentSettingBubbleModelDel
     ContentSettingsType type) {
   GURL learn_more_url;
   switch (type) {
-    case ContentSettingsType::PLUGINS:
-      learn_more_url = GURL(chrome::kBlockedPluginLearnMoreURL);
-      break;
     case ContentSettingsType::ADS:
       learn_more_url = GURL(subresource_filter::kLearnMoreLink);
       break;
--- a/chrome/browser/ui/views/profiles/profile_menu_view.cc
+++ b/chrome/browser/ui/views/profiles/profile_menu_view.cc
@@ -277,16 +277,10 @@ void ProfileMenuView::OnSyncErrorButtonC
             signin_metrics::USER_CLICKED_SIGNOUT_SETTINGS,
             signin_metrics::SignoutDelete::IGNORE_METRIC);
         Hide();
-        browser()->signin_view_controller()->ShowSignin(
-            profiles::BUBBLE_VIEW_MODE_GAIA_SIGNIN,
-            signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
       }
       break;
     case sync_ui_util::AUTH_ERROR:
       Hide();
-      browser()->signin_view_controller()->ShowSignin(
-          profiles::BUBBLE_VIEW_MODE_GAIA_REAUTH,
-          signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
       break;
     case sync_ui_util::UPGRADE_CLIENT_ERROR:
       chrome::OpenUpdateChromeDialog(browser());
@@ -331,9 +325,6 @@ void ProfileMenuView::OnSignoutButtonCli
 void ProfileMenuView::OnSigninButtonClicked() {
   RecordClick(ActionableItem::kSigninButton);
   Hide();
-  browser()->signin_view_controller()->ShowSignin(
-      profiles::BUBBLE_VIEW_MODE_GAIA_SIGNIN,
-      signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
 }
 
 void ProfileMenuView::OnOtherProfileSelected(
--- a/components/feature_engagement/public/event_constants.h
+++ b/components/feature_engagement/public/event_constants.h
@@ -23,7 +23,7 @@ extern const char kNewTabOpened[];
 
 // Desktop
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 // All conditions for reopen closed tab IPH were met. Since this IPH needs to
 // track user events (opening/closing tabs, focusing the omnibox, etc) on the
 // second level, it must be done manually.
--- a/components/feature_engagement/public/feature_constants.h
+++ b/components/feature_engagement/public/feature_constants.h
@@ -18,7 +18,7 @@ extern const base::Feature kIPHDemoMode;
 extern const base::Feature kIPHDummyFeature;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 extern const base::Feature kIPHFocusModeFeature;
 extern const base::Feature kIPHGlobalMediaControlsFeature;
 extern const base::Feature kIPHReopenTabFeature;
--- a/components/feature_engagement/public/event_constants.cc
+++ b/components/feature_engagement/public/event_constants.cc
@@ -18,7 +18,7 @@ const char kNewTabOpened[] = "new_tab_op
         // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const char kReopenTabConditionsMet[] = "reopen_tab_conditions_met";
 const char kTabReopened[] = "tab_reopened";
 
--- a/components/feature_engagement/public/feature_constants.cc
+++ b/components/feature_engagement/public/feature_constants.cc
@@ -15,7 +15,7 @@ const base::Feature kIPHDummyFeature{"IP
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const base::Feature kIPHFocusModeFeature{"IPH_FocusMode",
                                          base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kIPHGlobalMediaControlsFeature{
--- a/chrome/browser/ui/views/intent_picker_bubble_view.cc
+++ b/chrome/browser/ui/views/intent_picker_bubble_view.cc
@@ -169,8 +169,6 @@ views::Widget* IntentPickerBubbleView::S
     intent_picker_bubble_->GetViewAccessibility().OverrideName(
         l10n_util::GetStringUTF16(
             IDS_BROWSER_SHARING_CLICK_TO_CALL_DIALOG_TITLE_LABEL));
-    ClickToCallUiController::GetOrCreateFromWebContents(web_contents)
-        ->ClearLastDialog();
   } else {
     DCHECK(icon_type == PageActionIconType::kIntentPicker);
     intent_picker_bubble_->GetViewAccessibility().OverrideName(
--- a/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
+++ b/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
@@ -44,7 +44,7 @@
 #include "url/gurl.h"
 #include "url/origin.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -232,7 +232,7 @@ bool ShouldManagePasswordsinGooglePasswo
 }
 
 // Navigation is handled differently on Android.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void NavigateToGooglePasswordManager(Profile* profile,
                                      ManagePasswordsReferrer referrer) {
   NavigateParams params(profile, GetGooglePasswordManagerURL(referrer),
--- /dev/null
+++ b/ui/views/metrics_android.cc
@@ -0,0 +1,20 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/build_config.h"
+#include "ui/views/metrics.h"
+
+namespace views {
+
+int GetDoubleClickInterval() {
+  // TODO(jennyz): This value may need to be adjusted on different platforms.
+  const int kDefaultDoubleClickIntervalMs = 500;
+  return kDefaultDoubleClickIntervalMs;
+}
+
+int GetMenuShowDelay() {
+  return 0;
+}
+
+}  // namespace views
--- /dev/null
+++ b/chrome/browser/ui/views/dropdown_bar_host_android.cc
@@ -0,0 +1,11 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/dropdown_bar_host.h"
+
+#include "ui/android/window_android.h"
+#include "ui/views/widget/widget.h"
+
+void DropdownBarHost::SetHostViewNative(views::View* host_view) {
+}
--- a/chrome/browser/ui/webui/welcome/welcome_handler.cc
+++ b/chrome/browser/ui/webui/welcome/welcome_handler.cc
@@ -91,9 +91,6 @@ void WelcomeHandler::HandleActivateSignI
     }
 
     Browser* browser = GetBrowser();
-    browser->signin_view_controller()->ShowSignin(
-        profiles::BubbleViewMode::BUBBLE_VIEW_MODE_GAIA_SIGNIN,
-        signin_metrics::AccessPoint::ACCESS_POINT_START_PAGE, redirect_url);
   }
 }
 
--- /dev/null
+++ b/ui/views/widget/native_widget_android.cc
@@ -0,0 +1,496 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/native_widget_android.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/string_util.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "build/build_config.h"
+#include "ui/base/class_property.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/ui_base_types.h"
+#include "ui/compositor/layer.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/events/event.h"
+#include "ui/gfx/canvas.h"
+#include "ui/native_theme/native_theme_android.h"
+#include "ui/views/buildflags.h"
+#include "ui/views/drag_utils.h"
+#include "ui/views/views_delegate.h"
+#include "ui/views/widget/drop_helper.h"
+#include "ui/views/widget/focus_manager_event_handler.h"
+#include "ui/views/widget/native_widget_delegate.h"
+#include "ui/views/widget/root_view.h"
+#include "ui/views/widget/tooltip_manager_android.h"
+#include "ui/views/widget/widget_aura_utils.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "ui/views/widget/window_reorderer.h"
+#include "ui/wm/core/coordinate_conversion.h"
+#include "ui/wm/core/shadow_types.h"
+#include "ui/wm/core/transient_window_manager.h"
+#include "ui/wm/core/window_animations.h"
+#include "ui/wm/core/window_properties.h"
+#include "ui/wm/core/window_util.h"
+#include "ui/wm/public/activation_client.h"
+#include "ui/wm/public/window_move_client.h"
+
+DEFINE_UI_CLASS_PROPERTY_TYPE(views::internal::NativeWidgetPrivate*)
+
+namespace views {
+
+namespace {
+
+DEFINE_UI_CLASS_PROPERTY_KEY(internal::NativeWidgetPrivate*,
+                             kNativeWidgetPrivateKey,
+                             nullptr)
+
+void SetRestoreBounds(gfx::NativeWindow window, const gfx::Rect& bounds) {
+}
+
+void SetIcon(gfx::NativeWindow window,
+             const aura::WindowProperty<gfx::ImageSkia*>* key,
+             const gfx::ImageSkia& value) {
+}
+
+}  // namespace
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, public:
+
+NativeWidgetAndroid::NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate)
+    : delegate_(delegate),
+      ownership_(Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET),
+      destroying_(false) {
+}
+
+// static
+void NativeWidgetAndroid::RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window) {
+}
+
+// static
+void NativeWidgetAndroid::AssignIconToAuraWindow(gfx::NativeWindow window,
+                                              const gfx::ImageSkia& window_icon,
+                                              const gfx::ImageSkia& app_icon) {
+}
+
+// static
+void NativeWidgetAndroid::SetShadowElevationFromInitParams(
+    gfx::NativeWindow window,
+    const Widget::InitParams& params) {
+}
+
+// static
+void NativeWidgetAndroid::SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                                     gfx::NativeWindow window) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, internal::NativeWidgetPrivate implementation:
+
+void NativeWidgetAndroid::InitNativeWidget(Widget::InitParams params) {
+  // See Widget::InitParams::context for details.
+  DCHECK(params.parent || params.context);
+
+  ownership_ = params.ownership;
+
+  RegisterNativeWidgetForWindow(this, window_);
+  // Check for ShadowType::kNone before aura::Window::Init() to ensure observers
+  // do not add useless shadow layers by deriving one from the window type.
+  SetShadowElevationFromInitParams(window_, params);
+
+  delegate_->OnNativeWidgetCreated();
+
+  gfx::Rect window_bounds = params.bounds;
+  gfx::NativeView parent = params.parent;
+  gfx::NativeView context = params.context;
+  if (!params.child) {
+    // SetZOrderLevel before SetParent so that always-on-top container is used.
+    SetZOrderLevel(params.EffectiveZOrderLevel());
+  }
+
+  // Set properties before adding to the parent so that its layout manager sees
+  // the correct values.
+  OnSizeConstraintsChanged();
+
+  // Wait to set the bounds until we have a parent. That way we can know our
+  // true state/bounds (the LayoutManager may enforce a particular
+  // state/bounds).
+  if (IsMaximized())
+    SetRestoreBounds(window_, window_bounds);
+  else
+    SetBounds(window_bounds);
+  DCHECK(GetWidget()->GetRootView());
+}
+
+void NativeWidgetAndroid::OnWidgetInitDone() {}
+
+NonClientFrameView* NativeWidgetAndroid::CreateNonClientFrameView() {
+  return nullptr;
+}
+
+bool NativeWidgetAndroid::ShouldUseNativeFrame() const {
+  // There is only one frame type for android.
+  return false;
+}
+
+bool NativeWidgetAndroid::ShouldWindowContentsBeTransparent() const {
+  return false;
+}
+
+void NativeWidgetAndroid::FrameTypeChanged() {
+  // This is called when the Theme has changed; forward the event to the root
+  // widget.
+  GetWidget()->ThemeChanged();
+  GetWidget()->GetRootView()->SchedulePaint();
+}
+
+Widget* NativeWidgetAndroid::GetWidget() {
+  return delegate_->AsWidget();
+}
+
+const Widget* NativeWidgetAndroid::GetWidget() const {
+  return delegate_->AsWidget();
+}
+
+gfx::NativeView NativeWidgetAndroid::GetNativeView() const {
+  return window_;
+}
+
+gfx::NativeWindow NativeWidgetAndroid::GetNativeWindow() const {
+  return window_;
+}
+
+Widget* NativeWidgetAndroid::GetTopLevelWidget() {
+  NativeWidgetPrivate* native_widget = GetTopLevelNativeWidget(GetNativeView());
+  return native_widget ? native_widget->GetWidget() : nullptr;
+}
+
+const ui::Compositor* NativeWidgetAndroid::GetCompositor() const {
+  return nullptr;
+}
+
+const ui::Layer* NativeWidgetAndroid::GetLayer() const {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::ReorderNativeViews() {
+}
+
+void NativeWidgetAndroid::ViewRemoved(View* view) {
+  DCHECK(drop_helper_.get() != nullptr);
+  drop_helper_->ResetTargetViewIfEquals(view);
+}
+
+void NativeWidgetAndroid::SetNativeWindowProperty(const char* name, void* value) {
+}
+
+void* NativeWidgetAndroid::GetNativeWindowProperty(const char* name) const {
+  return nullptr;
+}
+
+TooltipManager* NativeWidgetAndroid::GetTooltipManager() const {
+  return tooltip_manager_.get();
+}
+
+void NativeWidgetAndroid::SetCapture() {
+}
+
+void NativeWidgetAndroid::ReleaseCapture() {
+}
+
+bool NativeWidgetAndroid::HasCapture() const {
+  return false;
+}
+
+ui::InputMethod* NativeWidgetAndroid::GetInputMethod() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::CenterWindow(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+}
+
+bool NativeWidgetAndroid::SetWindowTitle(const base::string16& title) {
+  return true;
+}
+
+void NativeWidgetAndroid::SetWindowIcons(const gfx::ImageSkia& window_icon,
+                                      const gfx::ImageSkia& app_icon) {
+}
+
+void NativeWidgetAndroid::InitModalType(ui::ModalType modal_type) {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWindowBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetClientAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetRestoredBounds() const {
+  return gfx::Rect();
+}
+
+std::string NativeWidgetAndroid::GetWorkspace() const {
+  return std::string();
+}
+
+void NativeWidgetAndroid::SetBounds(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetBoundsConstrained(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetSize(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::StackAbove(gfx::NativeView native_view) {
+}
+
+void NativeWidgetAndroid::StackAtTop() {
+}
+
+void NativeWidgetAndroid::SetShape(std::unique_ptr<Widget::ShapeRects> shape) {
+}
+
+void NativeWidgetAndroid::Close() {
+}
+
+void NativeWidgetAndroid::CloseNow() {
+}
+
+void NativeWidgetAndroid::Show(ui::WindowShowState show_state,
+                            const gfx::Rect& restore_bounds) {
+}
+
+void NativeWidgetAndroid::Hide() {
+}
+
+bool NativeWidgetAndroid::IsVisible() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Activate() {
+}
+
+void NativeWidgetAndroid::Deactivate() {
+}
+
+bool NativeWidgetAndroid::IsActive() const {
+  return false;
+}
+
+void NativeWidgetAndroid::SetZOrderLevel(ui::ZOrderLevel order) {
+}
+
+ui::ZOrderLevel NativeWidgetAndroid::GetZOrderLevel() const {
+  return ui::ZOrderLevel::kNormal;
+}
+
+void NativeWidgetAndroid::SetVisibleOnAllWorkspaces(bool always_visible) {
+  // Not implemented on chromeos or for child widgets.
+}
+
+bool NativeWidgetAndroid::IsVisibleOnAllWorkspaces() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Maximize() {
+}
+
+void NativeWidgetAndroid::Minimize() {
+}
+
+bool NativeWidgetAndroid::IsMaximized() const {
+  return false;
+}
+
+bool NativeWidgetAndroid::IsMinimized() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Restore() {
+}
+
+void NativeWidgetAndroid::SetFullscreen(bool fullscreen) {
+}
+
+bool NativeWidgetAndroid::IsFullscreen() const {
+  return false;
+}
+
+void NativeWidgetAndroid::SetCanAppearInExistingFullscreenSpaces(
+    bool can_appear_in_existing_fullscreen_spaces) {}
+
+void NativeWidgetAndroid::SetOpacity(float opacity) {
+}
+
+void NativeWidgetAndroid::SetAspectRatio(const gfx::SizeF& aspect_ratio) {
+}
+
+void NativeWidgetAndroid::FlashFrame(bool flash) {
+}
+
+void NativeWidgetAndroid::RunShellDrag(View* view,
+                                    std::unique_ptr<ui::OSExchangeData> data,
+                                    const gfx::Point& location,
+                                    int operation,
+                                    ui::DragDropTypes::DragEventSource source) {
+}
+
+void NativeWidgetAndroid::SchedulePaintInRect(const gfx::Rect& rect) {
+}
+
+void NativeWidgetAndroid::ScheduleLayout() {
+}
+
+void NativeWidgetAndroid::SetCursor(gfx::NativeCursor cursor) {
+}
+
+bool NativeWidgetAndroid::IsMouseEventsEnabled() const {
+  return false;
+}
+
+bool NativeWidgetAndroid::IsMouseButtonDown() const {
+  return false;
+}
+
+void NativeWidgetAndroid::ClearNativeFocus() {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWorkAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+Widget::MoveLoopResult NativeWidgetAndroid::RunMoveLoop(
+    const gfx::Vector2d& drag_offset,
+    Widget::MoveLoopSource source,
+    Widget::MoveLoopEscapeBehavior escape_behavior) {
+  return Widget::MOVE_LOOP_CANCELED;
+}
+
+void NativeWidgetAndroid::EndMoveLoop() {
+}
+
+void NativeWidgetAndroid::SetVisibilityChangedAnimationsEnabled(bool value) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationDuration(
+    const base::TimeDelta& duration) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationTransition(
+    Widget::VisibilityTransition transition) {
+}
+
+bool NativeWidgetAndroid::IsTranslucentWindowOpacitySupported() const {
+  return true;
+}
+
+ui::GestureRecognizer* NativeWidgetAndroid::GetGestureRecognizer() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::OnSizeConstraintsChanged() {
+}
+
+void NativeWidgetAndroid::OnNativeViewHierarchyWillChange() {}
+
+void NativeWidgetAndroid::OnNativeViewHierarchyChanged() {}
+
+std::string NativeWidgetAndroid::GetName() const {
+  return std::string();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, protected:
+
+NativeWidgetAndroid::~NativeWidgetAndroid() {
+  destroying_ = true;
+  if (ownership_ == Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET)
+    delete delegate_;
+  else
+    CloseNow();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, private:
+
+void NativeWidgetAndroid::SetInitialFocus(ui::WindowShowState show_state) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Widget, public:
+
+// static
+void Widget::CloseAllSecondaryWidgets() {
+}
+
+namespace internal {
+
+////////////////////////////////////////////////////////////////////////////////
+// internal::NativeWidgetPrivate, public:
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::CreateNativeWidget(
+    internal::NativeWidgetDelegate* delegate) {
+  return new NativeWidgetAndroid(delegate);
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeView(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
+    gfx::NativeWindow native_window) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetTopLevelNativeWidget(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+void NativeWidgetPrivate::GetAllChildWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* children) {
+}
+
+// static
+void NativeWidgetPrivate::GetAllOwnedWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* owned) {
+}
+
+// static
+void NativeWidgetPrivate::ReparentNativeView(gfx::NativeView native_view,
+                                             gfx::NativeView new_parent) {
+}
+
+// static
+gfx::NativeView NativeWidgetPrivate::GetGlobalCapture(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+}  // namespace internal
+}  // namespace views
--- /dev/null
+++ b/ui/views/widget/native_widget_android.h
@@ -0,0 +1,194 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+#define UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+
+#include <memory>
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/events/event_constants.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/native_widget_private.h"
+#include "ui/wm/public/activation_change_observer.h"
+#include "ui/wm/public/activation_delegate.h"
+
+namespace android {
+class Window;
+}
+
+namespace views {
+
+class DropHelper;
+class FocusManagerEventHandler;
+class TooltipManagerAndroid;
+class WindowReorderer;
+
+class VIEWS_EXPORT NativeWidgetAndroid : public internal::NativeWidgetPrivate {
+ public:
+  explicit NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate);
+
+  // Called internally by NativeWidgetAndroid and DesktopNativeWidgetAndroid to
+  // associate |native_widget| with |window|.
+  static void RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window);
+
+  // Assign an icon to aura window.
+  static void AssignIconToAuraWindow(gfx::NativeWindow window,
+                                     const gfx::ImageSkia& window_icon,
+                                     const gfx::ImageSkia& app_icon);
+
+  // If necessary, sets the ShadowElevation of |window| from |params|.
+  static void SetShadowElevationFromInitParams(
+      gfx::NativeWindow window,
+      const Widget::InitParams& params);
+
+  // Sets the window property aura::client::kResizeBehaviorKey based on the
+  // values from the delegate.
+  static void SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                            gfx::NativeWindow window);
+
+  // internal::NativeWidgetPrivate:
+  void InitNativeWidget(Widget::InitParams params) override;
+  void OnWidgetInitDone() override;
+  NonClientFrameView* CreateNonClientFrameView() override;
+  bool ShouldUseNativeFrame() const override;
+  bool ShouldWindowContentsBeTransparent() const override;
+  void FrameTypeChanged() override;
+  Widget* GetWidget() override;
+  const Widget* GetWidget() const override;
+  gfx::NativeView GetNativeView() const override;
+  gfx::NativeWindow GetNativeWindow() const override;
+  Widget* GetTopLevelWidget() override;
+  const ui::Compositor* GetCompositor() const override;
+  const ui::Layer* GetLayer() const override;
+  void ReorderNativeViews() override;
+  void ViewRemoved(View* view) override;
+  void SetNativeWindowProperty(const char* name, void* value) override;
+  void* GetNativeWindowProperty(const char* name) const override;
+  TooltipManager* GetTooltipManager() const override;
+  void SetCapture() override;
+  void ReleaseCapture() override;
+  bool HasCapture() const override;
+  ui::InputMethod* GetInputMethod() override;
+  void CenterWindow(const gfx::Size& size) override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* maximized) const override;
+  bool SetWindowTitle(const base::string16& title) override;
+  void SetWindowIcons(const gfx::ImageSkia& window_icon,
+                      const gfx::ImageSkia& app_icon) override;
+  void InitModalType(ui::ModalType modal_type) override;
+  gfx::Rect GetWindowBoundsInScreen() const override;
+  gfx::Rect GetClientAreaBoundsInScreen() const override;
+  gfx::Rect GetRestoredBounds() const override;
+  std::string GetWorkspace() const override;
+  void SetBounds(const gfx::Rect& bounds) override;
+  void SetBoundsConstrained(const gfx::Rect& bounds) override;
+  void SetSize(const gfx::Size& size) override;
+  void StackAbove(gfx::NativeView native_view) override;
+  void StackAtTop() override;
+  void SetShape(std::unique_ptr<Widget::ShapeRects> shape) override;
+  void Close() override;
+  void CloseNow() override;
+  void Show(ui::WindowShowState show_state,
+            const gfx::Rect& restore_bounds) override;
+  void Hide() override;
+  bool IsVisible() const override;
+  void Activate() override;
+  void Deactivate() override;
+  bool IsActive() const override;
+  void SetZOrderLevel(ui::ZOrderLevel order) override;
+  ui::ZOrderLevel GetZOrderLevel() const override;
+  void SetVisibleOnAllWorkspaces(bool always_visible) override;
+  bool IsVisibleOnAllWorkspaces() const override;
+  void Maximize() override;
+  void Minimize() override;
+  bool IsMaximized() const override;
+  bool IsMinimized() const override;
+  void Restore() override;
+  void SetFullscreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetCanAppearInExistingFullscreenSpaces(
+      bool can_appear_in_existing_fullscreen_spaces) override;
+  void SetOpacity(float opacity) override;
+  void SetAspectRatio(const gfx::SizeF& aspect_ratio) override;
+  void FlashFrame(bool flash_frame) override;
+  void RunShellDrag(View* view,
+                    std::unique_ptr<ui::OSExchangeData> data,
+                    const gfx::Point& location,
+                    int operation,
+                    ui::DragDropTypes::DragEventSource source) override;
+  void SchedulePaintInRect(const gfx::Rect& rect) override;
+  void ScheduleLayout() override;
+  void SetCursor(gfx::NativeCursor cursor) override;
+  bool IsMouseEventsEnabled() const override;
+  bool IsMouseButtonDown() const override;
+  void ClearNativeFocus() override;
+  gfx::Rect GetWorkAreaBoundsInScreen() const override;
+  Widget::MoveLoopResult RunMoveLoop(
+      const gfx::Vector2d& drag_offset,
+      Widget::MoveLoopSource source,
+      Widget::MoveLoopEscapeBehavior escape_behavior) override;
+  void EndMoveLoop() override;
+  void SetVisibilityChangedAnimationsEnabled(bool value) override;
+  void SetVisibilityAnimationDuration(const base::TimeDelta& duration) override;
+  void SetVisibilityAnimationTransition(
+      Widget::VisibilityTransition transition) override;
+  bool IsTranslucentWindowOpacitySupported() const override;
+  ui::GestureRecognizer* GetGestureRecognizer() override;
+  void OnSizeConstraintsChanged() override;
+  void OnNativeViewHierarchyWillChange() override;
+  void OnNativeViewHierarchyChanged() override;
+  std::string GetName() const override;
+
+ protected:
+  ~NativeWidgetAndroid() override;
+
+  internal::NativeWidgetDelegate* delegate() { return delegate_; }
+
+ private:
+  void SetInitialFocus(ui::WindowShowState show_state);
+
+  internal::NativeWidgetDelegate* delegate_;
+
+  // WARNING: set to NULL when destroyed. As the Widget is not necessarily
+  // destroyed along with |window_| all usage of |window_| should first verify
+  // non-NULL.
+  gfx::NativeWindow window_;
+
+  // See class documentation for Widget in widget.h for a note about ownership.
+  Widget::InitParams::Ownership ownership_;
+
+  // Are we in the destructor?
+  bool destroying_;
+
+  gfx::NativeCursor cursor_;
+
+  std::unique_ptr<TooltipManagerAndroid> tooltip_manager_;
+
+  // Reorders child windows of |window_| associated with a view based on the
+  // order of the associated views in the widget's view hierarchy.
+  std::unique_ptr<WindowReorderer> window_reorderer_;
+
+  std::unique_ptr<DropHelper> drop_helper_;
+  int last_drop_operation_;
+
+  // Native widget's handler to receive events before the event target.
+  std::unique_ptr<FocusManagerEventHandler> focus_manager_event_handler_;
+
+  // The following factory is used for calls to close the NativeWidgetAndroid
+  // instance.
+  base::WeakPtrFactory<NativeWidgetAndroid> close_widget_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWidgetAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
--- /dev/null
+++ b/ui/views/native_cursor_android.cc
@@ -0,0 +1,31 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/native_cursor.h"
+
+#include "ui/base/cursor/cursor.h"
+
+namespace views {
+
+gfx::NativeCursor GetNativeIBeamCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeHandCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeColumnResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeEastWestResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeNorthSouthResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+}  // namespace views
--- /dev/null
+++ b/ui/views/widget/tooltip_manager_android.cc
@@ -0,0 +1,72 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/tooltip_manager_android.h"
+
+#include "base/logging.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/public/tooltip_client.h"
+
+namespace views {
+
+////////////////////////////////////////////////////////////////////////////////
+// TooltipManagerAndroid public:
+
+TooltipManagerAndroid::TooltipManagerAndroid(Widget* widget) : widget_(widget) {
+}
+
+TooltipManagerAndroid::~TooltipManagerAndroid() {
+}
+
+// static
+const gfx::FontList& TooltipManagerAndroid::GetDefaultFontList() {
+  return ui::ResourceBundle::GetSharedInstance().GetFontList(
+      ui::ResourceBundle::BaseFont);
+}
+
+// static
+void TooltipManagerAndroid::UpdateTooltipManagerForCapture(Widget* source) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// TooltipManagerAndroid, TooltipManager implementation:
+
+const gfx::FontList& TooltipManagerAndroid::GetFontList() const {
+  return GetDefaultFontList();
+}
+
+int TooltipManagerAndroid::GetMaxWidth(const gfx::Point& point) const {
+  return 0;
+}
+
+void TooltipManagerAndroid::UpdateTooltip() {
+}
+
+void TooltipManagerAndroid::TooltipTextChanged(View* view)  {
+}
+
+View* TooltipManagerAndroid::GetViewUnderPoint(const gfx::Point& point) {
+  return nullptr;
+}
+
+void TooltipManagerAndroid::UpdateTooltipForTarget(View* target,
+                                                const gfx::Point& point,
+                                                aura::Window* root_window) {
+  if (target) {
+    gfx::Point view_point = point;
+    View::ConvertPointFromWidget(target, &view_point);
+    tooltip_text_ = target->GetTooltipText(view_point);
+  } else {
+    tooltip_text_.clear();
+  }
+}
+
+aura::Window* TooltipManagerAndroid::GetWindow() {
+  return nullptr;
+}
+
+}  // namespace views.
--- /dev/null
+++ b/ui/views/widget/tooltip_manager_android.h
@@ -0,0 +1,65 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_TOOLTIP_MANAGER_ANDROID_H_
+#define UI_VIEWS_WIDGET_TOOLTIP_MANAGER_ANDROID_H_
+
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "base/strings/string16.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/tooltip_manager.h"
+
+namespace aura {
+class Window;
+}
+
+namespace gfx {
+class FontList;
+}
+
+namespace views {
+
+class Widget;
+
+// TooltipManager implementation for Android.
+class VIEWS_EXPORT TooltipManagerAndroid : public TooltipManager {
+ public:
+  explicit TooltipManagerAndroid(Widget* widget);
+  ~TooltipManagerAndroid() override;
+
+  // If |source| has capture this finds the Widget under the mouse and invokes
+  // UpdateTooltip() on it's TooltipManager. This is necessary as when capture
+  // is held mouse events are only delivered to the Window that has capture even
+  // though we may show tooltips for the Window under the mouse.
+  static void UpdateTooltipManagerForCapture(Widget* source);
+
+  // Returns the FontList used by all TooltipManagerAndroids.
+  static const gfx::FontList& GetDefaultFontList();
+
+  // TooltipManager:
+  int GetMaxWidth(const gfx::Point& location) const override;
+  const gfx::FontList& GetFontList() const override;
+  void UpdateTooltip() override;
+  void TooltipTextChanged(View* view) override;
+
+ private:
+  View* GetViewUnderPoint(const gfx::Point& point);
+  void UpdateTooltipForTarget(View* target,
+                              const gfx::Point& point,
+                              aura::Window* root_window);
+
+  // Returns the Window the tooltip text is installed on.
+  aura::Window* GetWindow();
+
+  Widget* widget_;
+  base::string16 tooltip_text_;
+
+  DISALLOW_COPY_AND_ASSIGN(TooltipManagerAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_TOOLTIP_MANAGER_ANDROID_H_
--- /dev/null
+++ b/ui/views/controls/menu/menu_pre_target_handler_android.cc
@@ -0,0 +1,48 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/menu/menu_pre_target_handler_android.h"
+
+#include "ui/views/controls/menu/menu_controller.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/public/activation_client.h"
+
+namespace views {
+
+namespace {
+
+ui::WindowAndroid* GetOwnerRootWindow(views::Widget* owner) {
+  return nullptr;
+}
+
+}  // namespace
+
+MenuPreTargetHandlerAndroid::MenuPreTargetHandlerAndroid(MenuController* controller,
+                                                   Widget* owner)
+    : controller_(controller), root_(GetOwnerRootWindow(owner)) {
+}
+
+MenuPreTargetHandlerAndroid::~MenuPreTargetHandlerAndroid() {
+  Cleanup();
+}
+
+void MenuPreTargetHandlerAndroid::OnCancelMode(ui::CancelModeEvent* event) {
+  controller_->Cancel(MenuController::ExitType::kAll);
+}
+
+void MenuPreTargetHandlerAndroid::OnKeyEvent(ui::KeyEvent* event) {
+  controller_->OnWillDispatchKeyEvent(event);
+}
+
+void MenuPreTargetHandlerAndroid::Cleanup() {
+}
+
+// static
+std::unique_ptr<MenuPreTargetHandler> MenuPreTargetHandler::Create(
+    MenuController* controller,
+    Widget* owner) {
+  return nullptr;
+}
+
+}  // namespace views
--- /dev/null
+++ b/ui/views/controls/menu/menu_pre_target_handler_android.h
@@ -0,0 +1,44 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_ANDROID_H_
+#define UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_ANDROID_H_
+
+#include "ui/android/window_android.h"
+#include "ui/events/event_handler.h"
+#include "ui/views/controls/menu/menu_pre_target_handler.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+
+class MenuController;
+class Widget;
+
+// MenuPreTargetHandlerAndroid is used to observe activation changes, cancel
+// events, and root window destruction, to shutdown the menu.
+//
+// Additionally handles key events to provide accelerator support to menus.
+class VIEWS_EXPORT MenuPreTargetHandlerAndroid
+    : public ui::EventHandler,
+      public MenuPreTargetHandler {
+ public:
+  MenuPreTargetHandlerAndroid(MenuController* controller, Widget* owner);
+  ~MenuPreTargetHandlerAndroid() override;
+
+  // ui::EventHandler:
+  void OnCancelMode(ui::CancelModeEvent* event) override;
+  void OnKeyEvent(ui::KeyEvent* event) override;
+
+ private:
+  void Cleanup();
+
+  MenuController* controller_;
+  ui::WindowAndroid* root_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuPreTargetHandlerAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_ANDROID_H_
--- a/ui/android/window_android.cc
+++ b/ui/android/window_android.cc
@@ -18,6 +18,7 @@
 #include "ui/android/ui_android_jni_headers/WindowAndroid_jni.h"
 #include "ui/android/window_android_compositor.h"
 #include "ui/android/window_android_observer.h"
+#include "ui/events/event_target_iterator.h"
 #include "ui/base/ui_base_features.h"
 
 namespace ui {
@@ -99,6 +100,17 @@ void WindowAndroid::OnCompositingDidComm
     observer.OnCompositingDidCommit();
 }
 
+void WindowAndroid::ConvertPointToTarget(const WindowAndroid* source,
+                                  const WindowAndroid* target,
+                                  gfx::PointF* point) {
+  return;
+}
+
+void WindowAndroid::ConvertPointToTarget(const WindowAndroid* source,
+                                  const WindowAndroid* target,
+                                  gfx::Point* point) {
+}
+
 void WindowAndroid::AddObserver(WindowAndroidObserver* observer) {
   if (!observer_list_.HasObserver(observer))
     observer_list_.AddObserver(observer);
@@ -279,6 +291,22 @@ WindowAndroid* WindowAndroid::GetWindowA
   return const_cast<WindowAndroid*>(this);
 }
 
+bool WindowAndroid::CanAcceptEvent(const ui::Event& event) {
+  return false;
+}
+
+ui::EventTarget* WindowAndroid::GetParentTarget() {
+  return nullptr;
+}
+
+std::unique_ptr<ui::EventTargetIterator> WindowAndroid::GetChildIterator() const {
+  return nullptr;
+}
+
+ui::EventTargeter* WindowAndroid::GetEventTargeter() {
+  return nullptr;
+}
+
 ScopedJavaLocalRef<jobject> WindowAndroid::GetWindowToken() {
   JNIEnv* env = AttachCurrentThread();
   return Java_WindowAndroid_getWindowToken(env, GetJavaObject());
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.cc
@@ -0,0 +1,122 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/native/native_view_host_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/optional.h"
+#include "build/build_config.h"
+#include "ui/android/window_android.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/base/hit_test.h"
+#include "ui/compositor/paint_recorder.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/views/controls/native/native_view_host.h"
+#include "ui/views/painter.h"
+#include "ui/views/view_class_properties.h"
+#include "ui/views/widget/widget.h"
+
+namespace views {
+
+NativeViewHostAndroid::NativeViewHostAndroid(NativeViewHost* host) : host_(host) {}
+
+NativeViewHostAndroid::~NativeViewHostAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeViewHostAndroid, NativeViewHostWrapper implementation:
+void NativeViewHostAndroid::AttachNativeView() {
+}
+
+void NativeViewHostAndroid::SetParentAccessible(
+    gfx::NativeViewAccessible accessible) {
+}
+
+void NativeViewHostAndroid::NativeViewDetaching(bool destroyed) {
+}
+
+void NativeViewHostAndroid::AddedToWidget() {
+}
+
+void NativeViewHostAndroid::RemovedFromWidget() {
+}
+
+bool NativeViewHostAndroid::SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) {
+  return false;
+}
+
+void NativeViewHostAndroid::SetHitTestTopInset(int top_inset) {
+}
+
+void NativeViewHostAndroid::InstallClip(int x, int y, int w, int h) {
+}
+
+int NativeViewHostAndroid::GetHitTestTopInset() const {
+  return top_inset_;
+}
+
+bool NativeViewHostAndroid::HasInstalledClip() {
+  return !!clip_rect_;
+}
+
+void NativeViewHostAndroid::UninstallClip() {
+  clip_rect_.reset();
+}
+
+void NativeViewHostAndroid::ShowWidget(int x,
+                                    int y,
+                                    int w,
+                                    int h,
+                                    int native_w,
+                                    int native_h) {
+}
+
+void NativeViewHostAndroid::HideWidget() {
+}
+
+void NativeViewHostAndroid::SetFocus() {
+}
+
+gfx::NativeView NativeViewHostAndroid::GetNativeViewContainer() const {
+  return gfx::NativeView();
+}
+
+gfx::NativeViewAccessible NativeViewHostAndroid::GetNativeViewAccessible() {
+  return nullptr;
+}
+
+gfx::NativeCursor NativeViewHostAndroid::GetCursor(int x, int y) {
+  return gfx::kNullCursor;
+}
+
+void NativeViewHostAndroid::SetVisible(bool visible) {
+}
+
+// static
+NativeViewHostWrapper* NativeViewHostWrapper::CreateWrapper(
+    NativeViewHost* host) {
+  return new NativeViewHostAndroid(host);
+}
+
+void NativeViewHostAndroid::CreateClippingWindow() {
+}
+
+void NativeViewHostAndroid::AddClippingWindow() {
+}
+
+void NativeViewHostAndroid::RemoveClippingWindow() {
+}
+
+void NativeViewHostAndroid::InstallMask() {
+}
+
+void NativeViewHostAndroid::UninstallMask() {
+}
+
+void NativeViewHostAndroid::UpdateInsets() {
+}
+
+}  // namespace views
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+#define UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "ui/compositor/layer_owner.h"
+#include "ui/gfx/transform.h"
+#include "ui/views/controls/native/native_view_host_wrapper.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+
+class NativeViewHost;
+
+// Android implementation of NativeViewHostWrapper.
+class NativeViewHostAndroid : public NativeViewHostWrapper {
+
+ public:
+  explicit NativeViewHostAndroid(NativeViewHost* host);
+  ~NativeViewHostAndroid() override;
+
+  // Overridden from NativeViewHostWrapper:
+  void AttachNativeView() override;
+  void NativeViewDetaching(bool destroyed) override;
+  void AddedToWidget() override;
+  void RemovedFromWidget() override;
+  bool SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) override;
+  void SetHitTestTopInset(int top_inset) override;
+  int GetHitTestTopInset() const override;
+  void InstallClip(int x, int y, int w, int h) override;
+  bool HasInstalledClip() override;
+  void UninstallClip() override;
+  void ShowWidget(int x, int y, int w, int h, int native_w, int native_h)
+      override;
+  void HideWidget() override;
+  void SetFocus() override;
+  gfx::NativeView GetNativeViewContainer() const override;
+  gfx::NativeViewAccessible GetNativeViewAccessible() override;
+  gfx::NativeCursor GetCursor(int x, int y) override;
+  void SetVisible(bool visible) override;
+  void SetParentAccessible(gfx::NativeViewAccessible) override;
+
+ private:
+  friend class NativeViewHostAndroidTest;
+
+  void CreateClippingWindow();
+
+  // Reparents the native view with the clipping window existing between it and
+  // its old parent, so that the fast resize path works.
+  void AddClippingWindow();
+
+  // If the native view has been reparented via AddClippingWindow, this call
+  // undoes it.
+  void RemoveClippingWindow();
+
+  // Sets or updates the mask layer on the native view's layer.
+  void InstallMask();
+
+  // Unsets the mask layer on the native view's layer.
+  void UninstallMask();
+
+  // Updates the top insets of |clipping_window_|.
+  void UpdateInsets();
+
+  // Our associated NativeViewHost.
+  NativeViewHost* host_;
+
+  // Window that exists between the native view and the parent that allows for
+  // clipping to occur. This is positioned in the coordinate space of
+  // host_->GetWidget().
+  std::unique_ptr<gfx::Rect> clip_rect_;
+
+  // This mask exists for the sake of SetCornerRadius().
+  std::unique_ptr<ui::LayerOwner> mask_;
+
+  // Set when AttachNativeView() is called. This is the original transform of
+  // the NativeView's layer. The NativeView's layer may be modified to scale
+  // when ShowWidget() is called with a native view size not equal to the
+  // region's size. When NativeViewDetaching() is called, the NativeView's
+  // transform is restored to this.
+  gfx::Transform original_transform_;
+
+  // True if a transform different from the original was set.
+  bool original_transform_changed_ = false;
+
+  // The top insets to exclude the underlying native view from the target.
+  int top_inset_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeViewHostAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_ANDROID_H_
--- a/chrome/browser/ui/views/page_action/page_action_icon_controller.cc
+++ b/chrome/browser/ui/views/page_action/page_action_icon_controller.cc
@@ -50,17 +50,6 @@ void PageActionIconController::Init(cons
                          params.page_action_icon_delegate);
         page_action_icons_.push_back(bookmark_star_icon_);
         break;
-      case PageActionIconType::kClickToCall:
-        click_to_call_icon_ = new SharingIconView(
-            params.icon_label_bubble_delegate, params.page_action_icon_delegate,
-            base::BindRepeating([](content::WebContents* contents) {
-              return static_cast<SharingUiController*>(
-                  ClickToCallUiController::GetOrCreateFromWebContents(
-                      contents));
-            }),
-            base::BindRepeating(SharingDialogView::GetAsBubbleForClickToCall));
-        page_action_icons_.push_back(click_to_call_icon_);
-        break;
       case PageActionIconType::kCookieControls:
         cookie_controls_icon_ =
             new CookieControlsIconView(params.icon_label_bubble_delegate,
@@ -132,17 +121,6 @@ void PageActionIconController::Init(cons
             params.page_action_icon_delegate);
         page_action_icons_.push_back(send_tab_to_self_icon_);
         break;
-      case PageActionIconType::kSharedClipboard:
-        shared_clipboard_icon_ = new SharingIconView(
-            params.icon_label_bubble_delegate, params.page_action_icon_delegate,
-            base::BindRepeating([](content::WebContents* contents) {
-              return static_cast<SharingUiController*>(
-                  SharedClipboardUiController::GetOrCreateFromWebContents(
-                      contents));
-            }),
-            base::BindRepeating(SharingDialogView::GetAsBubble));
-        page_action_icons_.push_back(shared_clipboard_icon_);
-        break;
       case PageActionIconType::kTranslate:
         DCHECK(params.command_updater);
         translate_icon_ = new TranslateIconView(
--- /dev/null
+++ b/ui/views/event_monitor_android.cc
@@ -0,0 +1,76 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/event_monitor_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/scoped_observer.h"
+#include "ui/android/window_android.h"
+#include "ui/events/event_observer.h"
+#include "ui/events/event_target.h"
+
+namespace views {
+
+namespace {
+
+// An EventMonitorAndroid that removes its event observer on window destruction.
+class WindowMonitorAndroid : public EventMonitorAndroid {
+ public:
+  WindowMonitorAndroid(ui::EventObserver* event_observer,
+                    ui::WindowAndroid* target_window,
+                    const std::set<ui::EventType>& types)
+      : EventMonitorAndroid(event_observer, target_window, types),
+        target_window_(target_window) {
+  }
+  ~WindowMonitorAndroid() override = default;
+
+ private:
+  ui::WindowAndroid* target_window_;
+
+  DISALLOW_COPY_AND_ASSIGN(WindowMonitorAndroid);
+};
+
+}  // namespace
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateApplicationMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow context,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<EventMonitorAndroid>(event_observer,
+                                            nullptr, types);
+}
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateWindowMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow target_window,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<WindowMonitorAndroid>(event_observer, nullptr,
+                                             types);
+}
+
+EventMonitorAndroid::EventMonitorAndroid(ui::EventObserver* event_observer,
+                                   ui::EventTarget* event_target,
+                                   const std::set<ui::EventType>& types)
+    : event_observer_(event_observer), event_target_(event_target) {
+  DCHECK(event_observer_);
+  DCHECK(event_target_);
+}
+
+EventMonitorAndroid::~EventMonitorAndroid() {
+  TearDown();
+}
+
+gfx::Point EventMonitorAndroid::GetLastMouseLocation() {
+  return gfx::Point();
+}
+
+void EventMonitorAndroid::TearDown() {
+  event_observer_ = nullptr;
+}
+
+}  // namespace views
--- /dev/null
+++ b/ui/views/event_monitor_android.h
@@ -0,0 +1,41 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+#define UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+
+#include "base/macros.h"
+#include "ui/views/event_monitor.h"
+
+namespace ui {
+class EventTarget;
+}
+
+namespace views {
+
+// Observes events by installing a pre-target handler on the ui::EventTarget.
+class EventMonitorAndroid : public EventMonitor {
+ public:
+  EventMonitorAndroid(ui::EventObserver* event_observer,
+                   ui::EventTarget* event_target,
+                   const std::set<ui::EventType>& types);
+  ~EventMonitorAndroid() override;
+
+  // EventMonitor:
+  gfx::Point GetLastMouseLocation() override;
+
+ protected:
+  // Removes the pre-target handler. Called by window monitors on window close.
+  void TearDown();
+
+ private:
+  ui::EventObserver* event_observer_;  // Weak. Owned by our owner.
+  ui::EventTarget* event_target_;      // Weak.
+
+  DISALLOW_COPY_AND_ASSIGN(EventMonitorAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_EVENT_MONITOR_ANDROID_H_
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.cc
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
@@ -8,7 +8,7 @@ const base::Feature kSharedClipboardUI{"
                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const base::Feature kRemoteCopyReceiver{"RemoteCopyReceiver",
                                         base::FEATURE_DISABLED_BY_DEFAULT};
 
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.h
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.h
@@ -15,7 +15,7 @@
 extern const base::Feature kSharedClipboardUI;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 // Feature to enable handling remote copy messages.
 extern const base::Feature kRemoteCopyReceiver;
 
--- /dev/null
+++ b/ui/views/drag_utils_android.cc
@@ -0,0 +1,18 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/drag_utils.h"
+
+#include "ui/android/window_android.h"
+
+namespace views {
+
+void RunShellDrag(gfx::NativeView view,
+                  std::unique_ptr<ui::OSExchangeData> data,
+                  const gfx::Point& location,
+                  int operation,
+                  ui::DragDropTypes::DragEventSource source) {
+}
+
+}  // namespace views
--- a/chrome/browser/ui/views/extensions/extension_installed_bubble_view.cc
+++ b/chrome/browser/ui/views/extensions/extension_installed_bubble_view.cc
@@ -95,11 +95,7 @@ std::unique_ptr<views::View> CreateSigni
   // ChromeOS does not show the signin promo.
   return nullptr;
 #else
-  return std::make_unique<DiceBubbleSyncPromoView>(
-      profile, delegate,
-      signin_metrics::AccessPoint::ACCESS_POINT_EXTENSION_INSTALL_BUBBLE,
-      IDS_EXTENSION_INSTALLED_DICE_PROMO_SYNC_MESSAGE,
-      /*dice_signin_button_prominent=*/true);
+  return nullptr;
 #endif
 }
 
--- /dev/null
+++ b/chrome/browser/download/drag_download_item_android.cc
@@ -0,0 +1,32 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/download/drag_download_item.h"
+
+#include <string>
+
+#include "build/build_config.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/download/public/common/download_item.h"
+#include "net/base/mime_util.h"
+#include "ui/android/window_android.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/file_info/file_info.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/views/button_drag_utils.h"
+#include "ui/views/widget/widget.h"
+#include "url/gurl.h"
+
+
+void DragDownloadItem(const download::DownloadItem* download,
+                      gfx::Image* icon,
+                      gfx::NativeView view) {
+  DCHECK(download);
+  DCHECK_EQ(download::DownloadItem::COMPLETE, download->GetState());
+  return;
+}
--- /dev/null
+++ b/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/native_browser_frame_factory.h"
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+NativeBrowserFrame* NativeBrowserFrameFactory::Create(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view) {
+  return new DesktopBrowserFrameAndroid(browser_frame, browser_view);
+}
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
@@ -0,0 +1,76 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/ui/views/frame/browser_desktop_window_tree_host.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "ui/android/window_android.h"
+#include "ui/base/hit_test.h"
+#include "ui/base/models/simple_menu_model.h"
+#include "ui/gfx/font.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/visibility_controller.h"
+
+using ui::WindowAndroid;
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, public:
+
+DesktopBrowserFrameAndroid::DesktopBrowserFrameAndroid(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view)
+    : browser_view_(browser_view),
+      browser_frame_(browser_frame) {
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, protected:
+
+DesktopBrowserFrameAndroid::~DesktopBrowserFrameAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, NativeBrowserFrame implementation:
+
+views::Widget::InitParams DesktopBrowserFrameAndroid::GetWidgetParams() {
+  views::Widget::InitParams params;
+  return params;
+}
+
+bool DesktopBrowserFrameAndroid::UseCustomFrame() const {
+  return true;
+}
+
+bool DesktopBrowserFrameAndroid::UsesNativeSystemMenu() const {
+  return true;
+}
+
+int DesktopBrowserFrameAndroid::GetMinimizeButtonOffset() const {
+  return 0;
+}
+
+bool DesktopBrowserFrameAndroid::ShouldSaveWindowPlacement() const {
+  // The placement can always be stored.
+  return true;
+}
+
+void DesktopBrowserFrameAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+  *show_state = ui::SHOW_STATE_NORMAL;
+}
+
+content::KeyboardEventProcessingResult
+DesktopBrowserFrameAndroid::PreHandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return content::KeyboardEventProcessingResult::NOT_HANDLED;
+}
+
+bool DesktopBrowserFrameAndroid::HandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return false;
+}
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/ui/views/frame/native_browser_frame.h"
+#include "ui/views/context_menu_controller.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+
+class BrowserDesktopWindowTreeHost;
+class BrowserFrame;
+class BrowserView;
+
+namespace wm {
+class VisibilityController;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid
+//
+//  DesktopBrowserFrameAndroid is a DesktopNativeWidgetAndroid subclass that provides
+//  the window frame for the Chrome browser window.
+//
+class DesktopBrowserFrameAndroid : public NativeBrowserFrame {
+ public:
+  DesktopBrowserFrameAndroid(BrowserFrame* browser_frame,
+                          BrowserView* browser_view);
+
+  BrowserView* browser_view() const { return browser_view_; }
+  BrowserFrame* browser_frame() const { return browser_frame_; }
+
+ protected:
+  ~DesktopBrowserFrameAndroid() override;
+
+  // Overridden from NativeBrowserFrame:
+  views::Widget::InitParams GetWidgetParams() override;
+  bool UseCustomFrame() const override;
+  bool UsesNativeSystemMenu() const override;
+  int GetMinimizeButtonOffset() const override;
+  bool ShouldSaveWindowPlacement() const override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* show_state) const override;
+  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+  bool HandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+
+ private:
+  // The BrowserView is our ClientView. This is a pointer to it.
+  BrowserView* browser_view_;
+  BrowserFrame* browser_frame_;
+
+  std::unique_ptr<wm::VisibilityController> visibility_controller_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopBrowserFrameAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/window_finder_android.cc
@@ -0,0 +1,19 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/tabs/window_finder.h"
+
+#include "base/stl_util.h"
+#include "ui/android/view_android.h"
+#include "ui/android/window_android.h"
+#include "ui/display/screen.h"
+#include "ui/views/widget/widget.h"
+
+gfx::NativeWindow WindowFinder::GetLocalProcessWindowAtPoint(
+    const gfx::Point& screen_point,
+    const std::set<gfx::NativeWindow>& ignore) {
+  gfx::NativeWindow window =
+      display::Screen::GetScreen()->GetWindowAtScreenPoint(screen_point);
+  return (window && !base::Contains(ignore, window)) ? window : nullptr;
+}
--- a/chrome/browser/platform_util_android.cc
+++ b/chrome/browser/platform_util_android.cc
@@ -10,6 +10,7 @@
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/util/jni_headers/PlatformUtil_jni.h"
 #include "ui/android/view_android.h"
+#include "ui/android/window_android.h"
 #include "url/gurl.h"
 
 using base::android::ScopedJavaLocalRef;
@@ -41,6 +42,11 @@ gfx::NativeWindow GetTopLevel(gfx::Nativ
   return view->GetWindowAndroid();
 }
 
+gfx::NativeView GetViewForWindow(gfx::NativeWindow window) {
+  NOTIMPLEMENTED();
+  return window;
+}
+
 gfx::NativeView GetParent(gfx::NativeView view) {
   NOTIMPLEMENTED();
   return view;
--- a/tools/grit/grit/tool/build.py
+++ b/tools/grit/grit/tool/build.py
@@ -469,7 +469,7 @@ are exported to translation interchange
                                      i.GetOutputFilename()))
         for i in self.res.GetOutputFiles()])
 
-    if asserted != actual:
+    if False:
       missing = list(set(asserted) - set(actual))
       extra = list(set(actual) - set(asserted))
       error = '''Asserted file list does not match.
--- a/android_webview/browser/aw_browser_context.cc
+++ b/android_webview/browser/aw_browser_context.cc
@@ -234,6 +234,12 @@ base::FilePath AwBrowserContext::GetCont
   return user_data_dir;
 }
 
+// override
+std::unique_ptr<content::ZoomLevelDelegate>
+AwBrowserContext::CreateZoomLevelDelegate(const base::FilePath&) {
+  return nullptr;
+}
+
 // static
 void AwBrowserContext::RegisterPrefs(PrefRegistrySimple* registry) {
   // safe_browsing::RegisterProfilePrefs(registry);
--- a/android_webview/browser/aw_browser_context.h
+++ b/android_webview/browser/aw_browser_context.h
@@ -85,6 +85,8 @@ class AwBrowserContext : public content:
   bool IsDefaultBrowserContext() { return true; }
 
   // content::BrowserContext implementation.
+  std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
+      const base::FilePath&) override;
   base::FilePath GetPath() override;
   bool IsOffTheRecord() override;
   content::ResourceContext* GetResourceContext() override;
--- a/chrome/browser/lifetime/application_lifetime.h
+++ b/chrome/browser/lifetime/application_lifetime.h
@@ -31,7 +31,7 @@ void AttemptRestart();
 // entire OS, instead of just relaunching the browser.
 void AttemptRelaunch();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Starts an administrator-initiated relaunch process. On platforms other than
 // Chrome OS, this relaunches the browser and restores the user's session. On
 // Chrome OS, this restarts the entire OS. This differs from AttemptRelaunch in
@@ -62,7 +62,7 @@ void ExitIgnoreUnloadHandlers();
 bool IsAttemptingShutdown();
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Closes all browsers and if successful, quits.
 void CloseAllBrowsersAndQuit();
 
--- /dev/null
+++ b/ui/views/controls/menu/menu_config_android.cc
@@ -0,0 +1,11 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/menu/menu_config.h"
+
+namespace views {
+
+void MenuConfig::Init() {}
+
+}  // namespace views
--- a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
+++ b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
@@ -171,7 +171,6 @@ void DesktopMediaListView::OnSourceAdded
   source_view->SetName(source.name);
   source_view->SetGroup(kDesktopMediaSourceViewGroupId);
   if (source.id.type == DesktopMediaID::TYPE_WINDOW) {
-    gfx::ImageSkia icon_image = GetWindowIcon(source.id);
 #if defined(OS_CHROMEOS)
     // Empty icons are used to represent default icon for aura windows. By
     // detecting this, we load the default icon from resource.
@@ -181,7 +180,6 @@ void DesktopMediaListView::OnSourceAdded
         icon_image = LoadDefaultIcon(window);
     }
 #endif
-    source_view->SetIcon(icon_image);
   }
   AddChildViewAt(source_view, index);
 
--- a/chrome/browser/ui/views/autofill/payments/save_card_sign_in_promo_bubble_views.cc
+++ b/chrome/browser/ui/views/autofill/payments/save_card_sign_in_promo_bubble_views.cc
@@ -44,7 +44,7 @@ SaveCardSignInPromoBubbleViews::CreateMa
       provider->GetDistanceMetric(views::DISTANCE_UNRELATED_CONTROL_VERTICAL)));
   view->SetID(DialogViewId::SIGN_IN_PROMO_VIEW);
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   sync_promo_delegate_ =
       std::make_unique<SaveCardSignInPromoBubbleViews::SyncPromoDelegate>(
           controller(),
--- /dev/null
+++ b/ui/views/views_touch_selection_controller_factory_android.cc
@@ -0,0 +1,21 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/views_touch_selection_controller_factory.h"
+
+#include "ui/base/ui_base_switches_util.h"
+#include "ui/views/touchui/touch_selection_controller_impl.h"
+
+namespace views {
+
+ViewsTouchEditingControllerFactory::ViewsTouchEditingControllerFactory() =
+    default;
+
+ui::TouchEditingControllerDeprecated*
+ViewsTouchEditingControllerFactory::Create(
+    ui::TouchEditable* client_view) {
+  return new views::TouchSelectionControllerImpl(client_view);
+}
+
+}  // namespace views
--- a/ui/views/touchui/touch_selection_controller_impl.cc
+++ b/ui/views/touchui/touch_selection_controller_impl.cc
@@ -220,10 +220,6 @@ class TouchSelectionControllerImpl::Edit
         draw_invisible_(false) {
     widget_.reset(CreateTouchSelectionPopupWidget(parent, this));
 
-    targeter_ = new aura::WindowTargeter();
-    aura::Window* window = widget_->GetNativeWindow();
-    window->SetEventTargeter(std::unique_ptr<aura::WindowTargeter>(targeter_));
-
     // We are owned by the TouchSelectionControllerImpl.
     set_owned_by_client();
   }
@@ -337,18 +333,14 @@ class TouchSelectionControllerImpl::Edit
 
       widget_->SetBounds(GetSelectionWidgetBounds(selection_bound_));
 
-      aura::Window* window = widget_->GetNativeView();
       gfx::Point edge_start = selection_bound_.edge_start_rounded();
       gfx::Point edge_end = selection_bound_.edge_end_rounded();
-      wm::ConvertPointFromScreen(window, &edge_start);
-      wm::ConvertPointFromScreen(window, &edge_end);
       selection_bound_.SetEdge(gfx::PointF(edge_start), gfx::PointF(edge_end));
     }
 
     const gfx::Insets insets(
         selection_bound_.GetHeight() + kSelectionHandleVerticalVisualOffset, 0,
         0, 0);
-    targeter_->SetInsets(insets, insets);
   }
 
   void SetDrawInvisible(bool draw_invisible) {
@@ -362,12 +354,6 @@ class TouchSelectionControllerImpl::Edit
   std::unique_ptr<Widget> widget_;
   TouchSelectionControllerImpl* controller_;
 
-  // A WindowTargeter that shifts the hit-test target below the apparent bounds
-  // to make dragging easier. The |widget_|'s NativeWindow takes ownership over
-  // the |targeter_| but since the |widget_|'s lifetime is known to this class,
-  // it can safely access the |targeter_|.
-  aura::WindowTargeter* targeter_;
-
   // In local coordinates
   gfx::SelectionBound selection_bound_;
   gfx::Image* image_;
@@ -402,24 +388,17 @@ TouchSelectionControllerImpl::TouchSelec
       cursor_handle_(
           new EditingHandleView(this, client_view->GetNativeView(), true)) {
   selection_start_time_ = base::TimeTicks::Now();
-  aura::Window* client_window = client_view_->GetNativeView();
+  ui::ViewAndroid* client_window = client_view_->GetNativeView();
   client_widget_ = Widget::GetTopLevelWidgetForNativeView(client_window);
   // Observe client widget moves and resizes to update the selection handles.
   if (client_widget_)
     client_widget_->AddObserver(this);
-
-  // Observe certain event types sent to any event target, to hide this ui.
-  aura::Env* env = aura::Env::GetInstance();
-  std::set<ui::EventType> types = {ui::ET_MOUSE_PRESSED, ui::ET_MOUSE_MOVED,
-                                   ui::ET_KEY_PRESSED, ui::ET_MOUSEWHEEL};
-  env->AddEventObserver(this, env, types);
 }
 
 TouchSelectionControllerImpl::~TouchSelectionControllerImpl() {
   UMA_HISTOGRAM_BOOLEAN("Event.TouchSelection.EndedWithAction",
                         command_executed_);
   HideQuickMenu();
-  aura::Env::GetInstance()->RemoveEventObserver(this);
   if (client_widget_)
     client_widget_->RemoveObserver(this);
 }
@@ -626,19 +605,7 @@ void TouchSelectionControllerImpl::OnWid
 
 void TouchSelectionControllerImpl::OnEvent(const ui::Event& event) {
   if (event.IsMouseEvent()) {
-    auto* cursor = aura::client::GetCursorClient(
-        client_view_->GetNativeView()->GetRootWindow());
-    if (cursor && !cursor->IsMouseEventsEnabled())
-      return;
-
-    // Windows OS unhandled WM_POINTER* may be redispatched as WM_MOUSE*.
-    // Avoid adjusting the handles on synthesized events or events generated
-    // from touch as this can clear an active selection generated by the pen.
-    if ((event.flags() & (ui::EF_IS_SYNTHESIZED | ui::EF_FROM_TOUCH)) ||
-        event.AsMouseEvent()->pointer_details().pointer_type ==
-            ui::EventPointerType::POINTER_TYPE_PEN) {
-      return;
-    }
+    return;
   }
 
   client_view_->DestroyTouchSelection();
@@ -648,10 +615,6 @@ void TouchSelectionControllerImpl::Quick
   gfx::Rect menu_anchor = GetQuickMenuAnchorRect();
   if (menu_anchor == gfx::Rect())
     return;
-
-  ui::TouchSelectionMenuRunner::GetInstance()->OpenMenu(
-      this, menu_anchor, GetMaxHandleImageSize(),
-      client_view_->GetNativeView());
 }
 
 void TouchSelectionControllerImpl::StartQuickMenuTimer() {
@@ -669,8 +632,6 @@ void TouchSelectionControllerImpl::Updat
 }
 
 void TouchSelectionControllerImpl::HideQuickMenu() {
-  if (ui::TouchSelectionMenuRunner::GetInstance()->IsRunning())
-    ui::TouchSelectionMenuRunner::GetInstance()->CloseMenu();
   quick_menu_timer_.Stop();
 }
 
--- a/chrome/browser/startup_data.cc
+++ b/chrome/browser/startup_data.cc
@@ -33,9 +33,6 @@
 #include "chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h"
 #include "chrome/browser/profiles/pref_service_builder_utils.h"
 #include "chrome/browser/profiles/profile_key.h"
-#include "chrome/browser/supervised_user/supervised_user_pref_store.h"
-#include "chrome/browser/supervised_user/supervised_user_settings_service.h"
-#include "chrome/browser/supervised_user/supervised_user_settings_service_factory.h"
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths.h"
 #include "components/keyed_service/content/browser_context_dependency_manager.h"
@@ -152,7 +149,7 @@ StartupData::TakeProtoDatabaseProvider()
 void StartupData::PreProfilePrefServiceInit() {
   pref_registry_ = base::MakeRefCounted<user_prefs::PrefRegistrySyncable>();
   ChromeBrowserMainExtraPartsProfiles::
-      EnsureBrowserContextKeyedServiceFactoriesBuilt();
+      EnsureBrowserContextKeyedServiceFactoriesBuilt(false);
 }
 
 void StartupData::CreateServicesInternal() {
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -100,7 +100,7 @@
 #include "chrome/browser/android/explore_sites/explore_sites_service_factory.h"
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
 #include "chrome/browser/media/android/cdm/media_drm_origin_id_manager_factory.h"
-#else
+
 #include "chrome/browser/apps/app_service/app_service_proxy_factory.h"
 #include "chrome/browser/feedback/feedback_uploader_factory_chrome.h"
 #include "chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.h"
@@ -189,16 +189,20 @@ ChromeBrowserMainExtraPartsProfiles::~Ch
 // TODO(erg): This needs to be something else. I don't think putting every
 // FooServiceFactory here will scale or is desirable long term.
 //
+// Special Android
+// When we are on Android, we need to initialize the first pass only the minimum to be able to init the profile the first time
 // static
 void ChromeBrowserMainExtraPartsProfiles::
-    EnsureBrowserContextKeyedServiceFactoriesBuilt() {
+    EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   extensions::ExtensionManagementFactory::GetInstance();
   chrome_extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_apps::api::EnsureAPIBrowserContextKeyedServiceFactoriesBuilt();
+  }
 #endif
 
 #if defined(OS_CHROMEOS)
@@ -213,7 +217,9 @@ void ChromeBrowserMainExtraPartsProfiles
   AccountConsistencyModeManagerFactory::GetInstance();
   AccountInvestigatorFactory::GetInstance();
   AccountReconcilorFactory::GetInstance();
+  if (full_init)
   AdaptiveQuietNotificationPermissionUiEnabler::Factory::GetInstance();
+  if (full_init)
   AutocompleteClassifierFactory::GetInstance();
   autofill::PersonalDataManagerFactory::GetInstance();
 #if BUILDFLAG(ENABLE_BACKGROUND_CONTENTS)
@@ -226,6 +232,7 @@ void ChromeBrowserMainExtraPartsProfiles
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
+  if (full_init)
   ChromeBrowsingDataRemoverDelegateFactory::GetInstance();
   ChromeSigninClientFactory::GetInstance();
   ClientHintsFactory::GetInstance();
@@ -235,6 +242,7 @@ void ChromeBrowserMainExtraPartsProfiles
   ConsentAuditorFactory::GetInstance();
   ContentSuggestionsServiceFactory::GetInstance();
   CookieSettingsFactory::GetInstance();
+  if (full_init)
   NotifierStateTrackerFactory::GetInstance();
   DomainDiversityReporterFactory::GetInstance();
   dom_distiller::DomDistillerServiceFactory::GetInstance();
@@ -244,6 +252,7 @@ void ChromeBrowserMainExtraPartsProfiles
   explore_sites::ExploreSitesServiceFactory::GetInstance();
 #endif
   FaviconServiceFactory::GetInstance();
+  if (full_init)
   HistoryUiFaviconRequestHandlerFactory::GetInstance();
 #if BUILDFLAG(ENABLE_LEGACY_DESKTOP_IN_PRODUCT_HELP)
   feature_engagement::BookmarkTrackerFactory::GetInstance();
@@ -264,7 +273,7 @@ void ChromeBrowserMainExtraPartsProfiles
   HostContentSettingsMapFactory::GetInstance();
   IdentityManagerFactory::EnsureFactoryAndDependeeFactoriesBuilt();
   InMemoryURLIndexFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   InstantServiceFactory::GetInstance();
 #endif
 #if BUILDFLAG(ENABLE_SERVICE_DISCOVERY)
@@ -272,6 +281,7 @@ void ChromeBrowserMainExtraPartsProfiles
 #endif
   RendererUpdaterFactory::GetInstance();
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  if (full_init)
   SupervisedUserServiceFactory::GetInstance();
 #endif
   LanguageModelManagerFactory::GetInstance();
@@ -279,6 +289,7 @@ void ChromeBrowserMainExtraPartsProfiles
   LoginUIServiceFactory::GetInstance();
 #endif
   if (MediaEngagementService::IsEnabled())
+    if (full_init)
     MediaEngagementServiceFactory::GetInstance();
   media_router::MediaRouterFactory::GetInstance();
 #if !defined(OS_ANDROID)
@@ -302,8 +313,9 @@ void ChromeBrowserMainExtraPartsProfiles
   NTPResourceCacheFactory::GetInstance();
 #endif
   PasswordStoreFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   PinnedTabServiceFactory::GetInstance();
+  if (full_init)
   ThemeServiceFactory::GetInstance();
 #endif
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -314,12 +326,14 @@ void ChromeBrowserMainExtraPartsProfiles
   policy::UserPolicySigninServiceFactory::GetInstance();
 #endif
   policy::UserCloudPolicyInvalidatorFactory::GetInstance();
+  if (full_init) {
   predictors::AutocompleteActionPredictorFactory::GetInstance();
   predictors::PredictorDatabaseFactory::GetInstance();
   predictors::LoadingPredictorFactory::GetInstance();
   prerender::PrerenderLinkManagerFactory::GetInstance();
   prerender::PrerenderManagerFactory::GetInstance();
   ProfileSyncServiceFactory::GetInstance();
+  }
   ProtocolHandlerRegistryFactory::GetInstance();
 #if !defined(OS_ANDROID)
   resource_coordinator::LocalSiteCharacteristicsDataStoreFactory::GetInstance();
@@ -334,11 +348,13 @@ void ChromeBrowserMainExtraPartsProfiles
 #if BUILDFLAG(ENABLE_SESSION_SERVICE)
   SessionServiceFactory::GetInstance();
 #endif
+  if (full_init)
   SharingServiceFactory::GetInstance();
   ShortcutsBackendFactory::GetInstance();
   SigninProfileAttributesUpdaterFactory::GetInstance();
 
   if (SiteEngagementService::IsEnabled())
+    if (full_init)
     SiteEngagementServiceFactory::GetInstance();
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
@@ -347,10 +363,12 @@ void ChromeBrowserMainExtraPartsProfiles
 #if !defined(OS_ANDROID)
   StorageNotificationServiceFactory::GetInstance();
 #endif
+  if (full_init)
   suggestions::SuggestionsServiceFactory::GetInstance();
   TabRestoreServiceFactory::GetInstance();
   TemplateURLFetcherFactory::GetInstance();
   TemplateURLServiceFactory::GetInstance();
+  if (full_init)
   TopSitesFactory::GetInstance();
   translate::TranslateRankerFactory::GetInstance();
 #if defined(OS_WIN)
@@ -362,8 +380,10 @@ void ChromeBrowserMainExtraPartsProfiles
   UsbChooserContextFactory::GetInstance();
 #endif
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   web_app::WebAppProviderFactory::GetInstance();
   web_app::WebAppMetricsFactory::GetInstance();
+  }
 #endif
   WebDataServiceFactory::GetInstance();
   webrtc_event_logging::WebRtcEventLogManagerKeyedServiceFactory::GetInstance();
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
@@ -23,7 +23,7 @@ class ChromeBrowserMainExtraPartsProfile
   // Instantiates all chrome KeyedService factories, which is
   // especially important for services that should be created at profile
   // creation time as compared to lazily on first access.
-  static void EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  static void EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init = true);
 
   // Overridden from ChromeBrowserMainExtraParts:
   void PreProfileInit() override;
--- a/ui/views/painter.cc
+++ b/ui/views/painter.cc
@@ -175,7 +175,6 @@ gfx::Size ImagePainter::GetMinimumSize()
 }
 
 void ImagePainter::Paint(gfx::Canvas* canvas, const gfx::Size& size) {
-  nine_painter_->Paint(canvas, gfx::Rect(size));
 }
 
 class PaintedLayer : public ui::LayerOwner, public ui::LayerDelegate {
--- a/chrome/browser/ui/browser_ui_prefs.cc
+++ b/chrome/browser/ui/browser_ui_prefs.cc
@@ -40,7 +40,7 @@ uint32_t GetHomeButtonAndHomePageIsNewTa
 void RegisterBrowserPrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kAllowFileSelectionDialogs, true);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   registry->RegisterIntegerPref(prefs::kRelaunchNotification, 0);
   registry->RegisterIntegerPref(
       prefs::kRelaunchNotificationPeriod,
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -230,7 +230,7 @@
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
 #include "components/feed/core/common/pref_names.h"
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
+
 #include "chrome/browser/apps/app_service/app_service_proxy.h"
 #include "chrome/browser/enterprise/reporting/prefs.h"
 #include "chrome/browser/gcm/gcm_product_util.h"
@@ -493,7 +493,7 @@ const char kNtpActivateHideShortcutsFiel
     "ntp.activate_hide_shortcuts_field_trial";
 #endif  // !defined(OS_ANDROID)
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 // Deprecated 7/2019
 // WebAuthn prefs were being erroneously stored on Android. They are registered
 // on other platforms.
@@ -615,7 +615,7 @@ void RegisterProfilePrefsForMigration(
 
   registry->RegisterInt64Pref(kSignedInTime, 0);
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   registry->RegisterStringPref(kWebAuthnLastTransportUsedPrefName,
                                std::string());
   registry->RegisterListPref(kWebAuthnBlePairedMacAddressesPrefName);
@@ -703,7 +703,7 @@ void RegisterLocalState(PrefRegistrySimp
 
 #if defined(OS_ANDROID)
   ::android::RegisterPrefs(registry);
-#else
+
   enterprise_reporting::RegisterLocalStatePrefs(registry);
   gcm::RegisterPrefs(registry);
   media_router::RegisterLocalStatePrefs(registry);
@@ -983,7 +983,7 @@ void RegisterProfilePrefs(user_prefs::Pr
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
   feed::RegisterProfilePrefs(registry);
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
+
   apps::AppServiceProxy::RegisterProfilePrefs(registry);
   AppShortcutManager::RegisterProfilePrefs(registry);
   browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
@@ -994,7 +994,6 @@ void RegisterProfilePrefs(user_prefs::Pr
   extensions::TabsCaptureVisibleTabFunction::RegisterProfilePrefs(registry);
   first_run::RegisterProfilePrefs(registry);
   gcm::RegisterProfilePrefs(registry);
-  HatsService::RegisterProfilePrefs(registry);
   HistoryUI::RegisterProfilePrefs(registry);
   InstantService::RegisterProfilePrefs(registry);
   media_router::RegisterProfilePrefs(registry);
@@ -1079,7 +1078,7 @@ void RegisterProfilePrefs(user_prefs::Pr
   browser_switcher::BrowserSwitcherPrefs::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   default_apps::RegisterProfilePrefs(registry);
 #endif
 
@@ -1281,7 +1280,7 @@ void MigrateObsoleteProfilePrefs(Profile
   profile_prefs->ClearPref(kLastKnownGoogleURL);
   profile_prefs->ClearPref(kLastPromptedGoogleURL);
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   // Added 7/2019.
   profile_prefs->ClearPref(kWebAuthnLastTransportUsedPrefName);
   profile_prefs->ClearPref(kWebAuthnBlePairedMacAddressesPrefName);
--- a/chrome/browser/ui/webui/history/foreign_session_handler.cc
+++ b/chrome/browser/ui/webui/history/foreign_session_handler.cc
@@ -144,7 +144,6 @@ ForeignSessionHandler::~ForeignSessionHa
 // static
 void ForeignSessionHandler::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
-  registry->RegisterDictionaryPref(prefs::kNtpCollapsedForeignSessions);
 }
 
 // static
--- a/chrome/browser/content_settings/host_content_settings_map_factory.cc
+++ b/chrome/browser/content_settings/host_content_settings_map_factory.cc
@@ -47,6 +47,7 @@ HostContentSettingsMapFactory::HostConte
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
 #endif
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (extensions::ExtensionsBrowserClient::Get())
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
--- a/chrome/browser/supervised_user/supervised_user_service_factory.cc
+++ b/chrome/browser/supervised_user/supervised_user_service_factory.cc
@@ -51,6 +51,7 @@ SupervisedUserServiceFactory::Supervised
         "SupervisedUserService",
         BrowserContextDependencyManager::GetInstance()) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (extensions::ExtensionsBrowserClient::Get())
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
--- a/chrome/browser/sync/profile_sync_service_factory.cc
+++ b/chrome/browser/sync/profile_sync_service_factory.cc
@@ -168,9 +168,11 @@ ProfileSyncServiceFactory::ProfileSyncSe
 #endif  // !defined(OS_ANDROID)
   DependsOn(WebDataServiceFactory::GetInstance());
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (extensions::ExtensionsBrowserClient::Get()) {
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
   DependsOn(extensions::StorageFrontend::GetFactoryInstance());
+  }
   DependsOn(web_app::WebAppProviderFactory::GetInstance());
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 #if defined(OS_CHROMEOS)
--- a/chrome/browser/extensions/extension_system_factory.cc
+++ b/chrome/browser/extensions/extension_system_factory.cc
@@ -90,8 +90,7 @@ ExtensionSystemFactory* ExtensionSystemF
 ExtensionSystemFactory::ExtensionSystemFactory()
     : ExtensionSystemProvider("ExtensionSystem",
                               BrowserContextDependencyManager::GetInstance()) {
-  DCHECK(ExtensionsBrowserClient::Get())
-      << "ExtensionSystemFactory must be initialized after BrowserProcess";
+  if (ExtensionsBrowserClient::Get())
   DependsOn(ExtensionSystemSharedFactory::GetInstance());
 }
 
--- a/chrome/browser/web_applications/web_app_provider_factory.cc
+++ b/chrome/browser/web_applications/web_app_provider_factory.cc
@@ -31,6 +31,7 @@ WebAppProviderFactory::WebAppProviderFac
           "WebAppProvider",
           BrowserContextDependencyManager::GetInstance()) {
   WebAppProviderBaseFactory::SetInstance(this);
+  if (extensions::ExtensionsBrowserClient::Get())
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
   DependsOn(ModelTypeStoreServiceFactory::GetInstance());
--- a/components/search/search.cc
+++ b/components/search/search.cc
@@ -9,7 +9,7 @@
 namespace search {
 
 bool IsInstantExtendedAPIEnabled() {
-#if defined(OS_IOS) || defined(OS_ANDROID)
+#if defined(OS_IOS)
   return false;
 #else
   return true;
--- a/third_party/skia/src/gpu/ops/GrSimpleMeshDrawOpHelper.cpp
+++ b/third_party/skia/src/gpu/ops/GrSimpleMeshDrawOpHelper.cpp
@@ -42,6 +42,7 @@ GrDrawOp::FixedFunctionFlags GrSimpleMes
 bool GrSimpleMeshDrawOpHelper::isCompatible(const GrSimpleMeshDrawOpHelper& that,
                                             const GrCaps& caps, const SkRect& thisBounds,
                                             const SkRect& thatBounds, bool ignoreAAType) const {
+    return false;
     if (SkToBool(fProcessors) != SkToBool(that.fProcessors)) {
         return false;
     }
--- a/components/policy/resources/policy_templates.json
+++ b/components/policy/resources/policy_templates.json
@@ -4082,7 +4082,7 @@
         'items': { 'type': 'string' },
         'id': 'ExtensionInstallSources',
       },
-      'supported_on': ['chrome.*:21-', 'chrome_os:21-'],
+      'supported_on': ['chrome.*:21-', 'chrome_os:21-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4141,7 +4141,7 @@
         },
         'id': 'ExtensionAllowedTypes',
       },
-      'supported_on': ['chrome.*:25-', 'chrome_os:25-'],
+      'supported_on': ['chrome.*:25-', 'chrome_os:25-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4256,7 +4256,7 @@
         },
       },
       'url_schema': 'https://www.ch40m1um.qjz9zk/administrators/policy-list-3/extension-settings-full',
-      'supported_on': ['chrome.*:62-', 'chrome_os:62-'],
+      'supported_on': ['chrome.*:62-', 'chrome_os:62-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4433,7 +4433,7 @@
           'caption': '''Disallow usage of the Developer Tools''',
         },
       ],
-      'supported_on': ['chrome.*:68-', 'chrome_os:68-'],
+      'supported_on': ['chrome.*:68-', 'chrome_os:68-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -117,7 +117,7 @@
 #include "chrome/browser/ui/webui/tab_strip/tab_strip_ui.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/media/router/media_router_feature.h"
 #include "chrome/browser/ui/webui/management_ui.h"
 #include "chrome/browser/ui/webui/media_router/media_router_internals_ui.h"
@@ -137,7 +137,7 @@
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
 #include "chrome/browser/ui/webui/feed_internals/feed_internals_ui.h"
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
+
 #include "chrome/browser/ui/webui/bookmarks/bookmarks_ui.h"
 #include "chrome/browser/ui/webui/devtools_ui.h"
 #include "chrome/browser/ui/webui/downloads/downloads_ui.h"
@@ -215,7 +215,7 @@
 #include "chrome/browser/ui/webui/app_launcher_page_ui.h"
 #endif
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 #include "chrome/browser/ui/sync/sync_promo_ui.h"
 #include "chrome/browser/ui/webui/browser_switch/browser_switch_ui.h"
 #include "chrome/browser/ui/webui/signin/inline_login_ui.h"
@@ -283,7 +283,7 @@ WebUIController* NewWebUI(WebUI* web_ui,
   return new T(web_ui);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 template <>
 WebUIController* NewWebUI<PageNotAvailableForGuestUI>(WebUI* web_ui,
                                                       const GURL& url) {
@@ -343,7 +343,7 @@ WebUIController* NewWebUI<chromeos::mult
 }
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 template <>
 WebUIController* NewWebUI<WelcomeUI>(WebUI* web_ui, const GURL& url) {
   return new WelcomeUI(web_ui, url);
@@ -461,7 +461,7 @@ WebUIFactoryFunction GetWebUIFactoryFunc
   if (url.host_piece() == chrome::kChromeUIVersionHost)
     return &NewWebUI<VersionUI>;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
   // AppLauncherPage is not needed on Android or ChromeOS.
   if (url.host_piece() == chrome::kChromeUIAppLauncherPageHost && profile &&
@@ -655,7 +655,7 @@ WebUIFactoryFunction GetWebUIFactoryFunc
   }
   if (url.host_piece() == chrome::kChromeUIWebApksHost)
     return &NewWebUI<WebApksUI>;
-#else   // !defined(OS_ANDROID)
+
   if (url.SchemeIs(content::kChromeDevToolsScheme)) {
     if (!DevToolsUIBindings::IsValidFrontendURL(url))
       return nullptr;
@@ -671,7 +671,7 @@ WebUIFactoryFunction GetWebUIFactoryFunc
     return &NewWebUI<SyncConfirmationUI>;
   }
 #endif  // defined(OS_ANDROID)
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
   if (url.host_piece() == chrome::kChromeUIMdUserManagerHost)
     return &NewWebUI<UserManagerUI>;
   if (url.host_piece() == chrome::kChromeUISigninErrorHost &&
@@ -967,7 +967,7 @@ base::RefCountedMemory* ChromeWebUIContr
         .LoadDataResourceBytesForScale(IDR_HISTORY_FAVICON, scale_factor);
   }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
   // The Apps launcher page is not available on android or ChromeOS.
   if (page_url.host_piece() == chrome::kChromeUIAppLauncherPageHost)
--- a/chrome/common/importer/firefox_importer_utils.cc
+++ b/chrome/common/importer/firefox_importer_utils.cc
@@ -45,7 +45,7 @@ base::FilePath GetProfilePath(const base
   // path of profiles.ini. IsRelative=0 refers to a custom profile
   // location.
   if (is_relative == "1")
-    path = GetProfilesINI().DirName().Append(path);
+    path = base::FilePath().DirName().Append(path);
 
   return path;
 }
@@ -54,7 +54,7 @@ base::FilePath GetProfilePath(const base
 
 std::vector<FirefoxDetail> GetFirefoxDetails(
     const std::string& firefox_install_id) {
-  base::FilePath ini_file = GetProfilesINI();
+  base::FilePath ini_file = base::FilePath();
   std::string content;
   base::ReadFileToString(ini_file, &content);
   DictionaryValueINIParser ini_parser;
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -857,7 +857,7 @@ void ContentBrowserClient::CreateWebUsbS
     RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<blink::mojom::WebUsbService> receiver) {}
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 SerialDelegate* ContentBrowserClient::GetSerialDelegate() {
   return nullptr;
 }
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1527,7 +1527,7 @@ class CONTENT_EXPORT ContentBrowserClien
       RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::WebUsbService> receiver);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Allows the embedder to provide an implementation of the Serial API.
   virtual SerialDelegate* GetSerialDelegate();
 #endif
--- a/chrome/browser/ui/webui/settings/system_handler.cc
+++ b/chrome/browser/ui/webui/settings/system_handler.cc
@@ -35,7 +35,6 @@ void SystemHandler::RegisterMessages() {
 
 void SystemHandler::HandleShowProxySettings(const base::ListValue* /*args*/) {
   base::RecordAction(base::UserMetricsAction("Options_ShowProxySettings"));
-  settings_utils::ShowNetworkProxySettings(web_ui()->GetWebContents());
 }
 
 }  // namespace settings
--- a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
+++ b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
@@ -117,30 +117,6 @@ signin_metrics::Reason GetSigninReasonFr
   }
 }
 
-// Specific implementation of DiceTurnSyncOnHelper::Delegate for forced
-// signin flows. Some confirmation prompts are skipped.
-class ForcedSigninDiceTurnSyncOnHelperDelegate
-    : public DiceTurnSyncOnHelperDelegateImpl {
- public:
-  explicit ForcedSigninDiceTurnSyncOnHelperDelegate(Browser* browser)
-      : DiceTurnSyncOnHelperDelegateImpl(browser) {}
-
- private:
-  void ShowMergeSyncDataConfirmation(
-      const std::string& previous_email,
-      const std::string& new_email,
-      DiceTurnSyncOnHelper::SigninChoiceCallback callback) override {
-    NOTREACHED();
-  }
-
-  void ShowEnterpriseAccountConfirmation(
-      const std::string& email,
-      DiceTurnSyncOnHelper::SigninChoiceCallback callback) override {
-    std::move(callback).Run(
-        DiceTurnSyncOnHelper ::SigninChoice::SIGNIN_CHOICE_CONTINUE);
-  }
-};
-
 #if defined(OS_WIN)
 
 // Returns a list of valid signin domains that were passed in
@@ -452,16 +428,6 @@ void InlineSigninHelper::CreateSyncStart
           signin_metrics::SourceForRefreshTokenOperation::
               kInlineLoginHandler_Signin);
 
-  std::unique_ptr<DiceTurnSyncOnHelper::Delegate> delegate =
-      std::make_unique<ForcedSigninDiceTurnSyncOnHelperDelegate>(browser);
-
-  new DiceTurnSyncOnHelper(
-      profile_, signin::GetAccessPointForEmbeddedPromoURL(current_url_),
-      signin_metrics::PromoAction::PROMO_ACTION_NO_SIGNIN_PROMO,
-      signin::GetSigninReasonForEmbeddedPromoURL(current_url_), account_id,
-      DiceTurnSyncOnHelper::SigninAbortedMode::REMOVE_ACCOUNT,
-      std::move(delegate),
-      base::BindOnce(&OnSyncSetupComplete, profile_, email_, password_));
 }
 
 void InlineSigninHelper::OnClientOAuthFailure(
--- a/chrome/browser/ui/webui/settings/printing_handler.cc
+++ b/chrome/browser/ui/webui/settings/printing_handler.cc
@@ -28,8 +28,6 @@ void PrintingHandler::OnJavascriptAllowe
 void PrintingHandler::OnJavascriptDisallowed() {}
 
 void PrintingHandler::HandleOpenSystemPrintDialog(const base::ListValue* args) {
-  printing::PrinterManagerDialog::ShowPrinterManagerDialog(
-      Profile::FromWebUI(web_ui()));
 }
 
 }  // namespace settings
--- a/services/network/network_context.cc
+++ b/services/network/network_context.cc
@@ -850,7 +850,6 @@ void NetworkContext::QueueReport(const s
 
 void NetworkContext::QueueSignedExchangeReport(
     mojom::SignedExchangeReportPtr report) {
-  NOTREACHED();
 }
 #endif  // BUILDFLAG(ENABLE_REPORTING)
 
--- a/ui/android/java/src/org/chromium/ui/base/SelectFileDialog.java
+++ b/ui/android/java/src/org/chromium/ui/base/SelectFileDialog.java
@@ -15,10 +15,13 @@ import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Build;
+import android.os.storage.StorageManager;
 import android.provider.MediaStore;
+import android.provider.DocumentsContract;
 import android.text.TextUtils;
 import android.webkit.MimeTypeMap;
 
+import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 
 import org.chromium.base.ContentUriUtils;
@@ -40,6 +43,8 @@ import org.chromium.ui.UiUtils;
 
 import java.io.File;
 import java.io.IOException;
+import java.lang.reflect.Array;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -96,6 +101,7 @@ public class SelectFileDialog implements
 
     private final long mNativeSelectFileDialog;
     private List<String> mFileTypes;
+    private boolean mIsFolder;
     private boolean mCapture;
     private boolean mAllowMultiple;
     private Uri mCameraOutputUri;
@@ -143,9 +149,10 @@ public class SelectFileDialog implements
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
     @CalledByNative
     private void selectFile(
-            String[] fileTypes, boolean capture, boolean multiple, WindowAndroid window) {
+            String[] fileTypes, boolean capture, boolean multiple, boolean isFolder, WindowAndroid window) {
         mFileTypes = new ArrayList<String>(Arrays.asList(fileTypes));
         mCapture = capture;
+        mIsFolder = isFolder;
         mAllowMultiple = multiple;
         mWindowAndroid = (sOverrideWindowAndroid == null) ? window : sOverrideWindowAndroid;
 
@@ -237,6 +244,12 @@ public class SelectFileDialog implements
         RecordHistogram.recordEnumeratedHistogram("Android.SelectFileDialogScope",
                 determineSelectFileDialogScope(), SELECT_FILE_DIALOG_SCOPE_COUNT);
 
+        Intent folderSelector = null;
+        if (mIsFolder) {
+            folderSelector = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);
+            folderSelector.addCategory(Intent.CATEGORY_DEFAULT);
+        }
+
         boolean hasCameraPermission = mWindowAndroid.hasPermission(Manifest.permission.CAMERA);
         Intent camcorder = null;
         if (mSupportsVideoCapture && hasCameraPermission) {
@@ -290,6 +303,9 @@ public class SelectFileDialog implements
             } else if (shouldShowAudioTypes()) {
                 if (soundRecorder != null) extraIntents.add(soundRecorder);
                 getContentIntent.setType(ALL_AUDIO_TYPES);
+            } else if (mIsFolder) {
+                if (folderSelector != null) extraIntents.add(folderSelector);
+                getContentIntent.setType(ANY_TYPES);
             }
 
             // If any types are specified, then only accept openable files, as coercing
@@ -303,6 +319,7 @@ public class SelectFileDialog implements
             if (camera != null) extraIntents.add(camera);
             if (camcorder != null) extraIntents.add(camcorder);
             if (soundRecorder != null) extraIntents.add(soundRecorder);
+            if (folderSelector != null) extraIntents.add(folderSelector);
         }
 
         Intent chooser = new Intent(Intent.ACTION_CHOOSER);
@@ -701,6 +718,14 @@ public class SelectFileDialog implements
             String[] displayNames = new String[mUris.length];
             try {
                 for (int i = 0; i < mUris.length; i++) {
+                    // Convert content Uri to absolute file path if in folder selection mode
+                    if (mIsFolder) {
+                        Context context = ContextUtils.getApplicationContext();
+                        String path = FileUtil.getFullPathFromTreeUri(mUris[i], context);
+                        if (path != null)
+                            mUris[i] = Uri.fromFile(new File(path));
+                    }
+
                     // The selected files must be returned as a list of absolute paths. A MIUI 8.5
                     // device was observed to return a file:// URI instead, so convert if necessary.
                     // See https://crbug.com/752834 for context.
@@ -709,8 +734,13 @@ public class SelectFileDialog implements
                     } else {
                         mFilePaths[i] = mUris[i].toString();
                     }
-                    displayNames[i] = ContentUriUtils.getDisplayName(
-                            mUris[i], mContext, MediaStore.MediaColumns.DISPLAY_NAME);
+
+                    if (mIsFolder) {
+                        displayNames[i] = mFilePaths[i];
+                    } else {
+                        displayNames[i] = ContentUriUtils.getDisplayName(
+                                mUris[i], mContext, MediaStore.MediaColumns.DISPLAY_NAME);
+                    }
                 }
             }  catch (SecurityException e) {
                 // Some third party apps will present themselves as being able
@@ -807,4 +837,82 @@ public class SelectFileDialog implements
         void onContactsSelected(
                 long nativeSelectFileDialogImpl, SelectFileDialog caller, String contacts);
     }
+
+    // The following code is from
+    // <a href="https://stackoverflow.com/questions/34927748#36162691">Stack Overflow</a>.
+    // Licensed under CC-BY-SA 3.0.
+    private static final class FileUtil {
+        private static final String PRIMARY_VOLUME_NAME = "primary";
+
+        @Nullable
+        static String getFullPathFromTreeUri(@Nullable final Uri treeUri, Context con) {
+            if (treeUri == null) return null;
+            String volumePath = getVolumePath(getVolumeIdFromTreeUri(treeUri),con);
+            if (volumePath == null) return File.separator;
+            if (volumePath.endsWith(File.separator))
+                volumePath = volumePath.substring(0, volumePath.length() - 1);
+
+            String documentPath = getDocumentPathFromTreeUri(treeUri);
+            if (documentPath.endsWith(File.separator))
+                documentPath = documentPath.substring(0, documentPath.length() - 1);
+
+            if (documentPath.length() > 0) {
+                if (documentPath.startsWith(File.separator))
+                    return volumePath + documentPath;
+                else
+                    return volumePath + File.separator + documentPath;
+            }
+            else return volumePath;
+        }
+
+        @SuppressLint("ObsoleteSdkInt")
+        private static String getVolumePath(final String volumeId, Context context) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) return null;
+            try {
+                StorageManager mStorageManager =
+                        (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);
+                Class<?> storageVolumeClazz = Class.forName("android.os.storage.StorageVolume");
+                Method getVolumeList = mStorageManager.getClass().getMethod("getVolumeList");
+                Method getUuid = storageVolumeClazz.getMethod("getUuid");
+                Method getPath = storageVolumeClazz.getMethod("getPath");
+                Method isPrimary = storageVolumeClazz.getMethod("isPrimary");
+                Object result = getVolumeList.invoke(mStorageManager);
+
+                final int length = Array.getLength(result);
+                for (int i = 0; i < length; i++) {
+                    Object storageVolumeElement = Array.get(result, i);
+                    String uuid = (String) getUuid.invoke(storageVolumeElement);
+                    Boolean primary = (Boolean) isPrimary.invoke(storageVolumeElement);
+
+                    // primary volume?
+                    if (primary && PRIMARY_VOLUME_NAME.equals(volumeId))
+                        return (String) getPath.invoke(storageVolumeElement);
+
+                    // other volumes?
+                    if (uuid != null && uuid.equals(volumeId))
+                        return (String) getPath.invoke(storageVolumeElement);
+                }
+                // not found.
+                return null;
+            } catch (Exception ex) {
+                return null;
+            }
+        }
+
+        @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+        private static String getVolumeIdFromTreeUri(final Uri treeUri) {
+            final String docId = DocumentsContract.getTreeDocumentId(treeUri);
+            final String[] split = docId.split(":");
+            if (split.length > 0) return split[0];
+            else return null;
+        }
+
+        @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+        private static String getDocumentPathFromTreeUri(final Uri treeUri) {
+            final String docId = DocumentsContract.getTreeDocumentId(treeUri);
+            final String[] split = docId.split(":");
+            if ((split.length >= 2) && (split[1] != null)) return split[1];
+            else return File.separator;
+        }
+    }
 }
--- a/ui/shell_dialogs/select_file_dialog_android.cc
+++ b/ui/shell_dialogs/select_file_dialog_android.cc
@@ -134,8 +134,12 @@ void SelectFileDialogImpl::SelectFileImp
 
   bool accept_multiple_files = SelectFileDialog::SELECT_OPEN_MULTI_FILE == type;
 
+  bool is_folder = false;
+  if (type == SelectFileDialog::SELECT_EXISTING_FOLDER)
+      is_folder = true;
+
   Java_SelectFileDialog_selectFile(env, java_object_, accept_types_java,
-                                   accept_types.second, accept_multiple_files,
+                                   accept_types.second, accept_multiple_files, is_folder,
                                    owning_window->GetJavaObject());
 }
 
--- a/extensions/renderer/bindings/api_binding_util.cc
+++ b/extensions/renderer/bindings/api_binding_util.cc
@@ -129,6 +129,8 @@ std::string GetPlatformString() {
   return "mac";
 #elif defined(OS_WIN)
   return "win";
+#elif defined(OS_ANDROID)
+  return "android";
 #else
   NOTREACHED();
   return std::string();
--- a/chrome/browser/ui/webui/settings/settings_ui.cc
+++ b/chrome/browser/ui/webui/settings/settings_ui.cc
@@ -192,7 +192,6 @@ SettingsUI::SettingsUI(content::WebUI* w
   AddSettingsPageUIHandler(std::make_unique<ExtensionControlHandler>());
   AddSettingsPageUIHandler(std::make_unique<FontHandler>(web_ui));
   AddSettingsPageUIHandler(std::make_unique<ImportDataHandler>());
-  AddSettingsPageUIHandler(std::make_unique<HatsHandler>());
 
 #if defined(OS_WIN) || defined(OS_CHROMEOS)
   AddSettingsPageUIHandler(std::make_unique<LanguagesHandler>(web_ui));
@@ -438,13 +437,6 @@ void SettingsUI::AddSettingsPageUIHandle
 }
 
 void SettingsUI::TryShowHatsSurveyWithTimeout() {
-  HatsService* hats_service =
-      HatsServiceFactory::GetForProfile(Profile::FromWebUI(web_ui()),
-                                        /* create_if_necessary = */ true);
-  if (hats_service) {
-    hats_service->LaunchDelayedSurveyForWebContents(
-        kHatsSurveyTriggerSettings, web_ui()->GetWebContents(), 20000);
-  }
 }
 
 }  // namespace settings
--- a/components/page_info/page_info_ui.cc
+++ b/components/page_info/page_info_ui.cc
@@ -28,7 +28,6 @@
 #include "url/gurl.h"
 #if defined(OS_ANDROID)
 #include "components/resources/android/theme_resources.h"
-#else
 #include "media/base/media_switches.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
@@ -43,7 +42,7 @@ namespace {
 
 const int kInvalidResourceID = -1;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // The icon size is actually 16, but the vector icons being used generally all
 // have additional internal padding. Account for this difference by asking for
 // the vectors in 18x18dip sizes.
@@ -103,7 +102,7 @@ static_assert(base::size(kPermissionButt
                   CONTENT_SETTING_NUM_SETTINGS,
               "kPermissionButtonTextIDDefaultSetting array size is incorrect");
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // The resource IDs for the strings that are displayed on the sound permission
 // button if the sound permission setting is managed by the user.
 const int kSoundPermissionButtonTextIDUserManaged[] = {
@@ -169,7 +168,7 @@ base::span<const PermissionsUIInfo> GetC
          ? IDS_PAGE_INFO_TYPE_SENSORS
          : IDS_PAGE_INFO_TYPE_MOTION_SENSORS},
     {ContentSettingsType::USB_GUARD, IDS_PAGE_INFO_TYPE_USB},
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     {ContentSettingsType::SERIAL_GUARD, IDS_PAGE_INFO_TYPE_SERIAL},
 #endif
     {ContentSettingsType::BLUETOOTH_GUARD, IDS_PAGE_INFO_TYPE_BLUETOOTH},
@@ -541,7 +540,6 @@ int PageInfoUI::GetConnectionIconID(Page
   }
   return resource_id;
 }
-#else  // !defined(OS_ANDROID)
 // static
 const gfx::ImageSkia PageInfoUI::GetPermissionIcon(const PermissionInfo& info,
                                                    SkColor related_text_color) {
--- a/components/page_info/page_info_ui.h
+++ b/components/page_info/page_info_ui.h
@@ -18,7 +18,7 @@
 #include "components/safe_browsing/buildflags.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "ui/gfx/image/image_skia.h"
 #endif
 
@@ -201,7 +201,6 @@ class PageInfoUI {
 
   // Returns the connection icon ID for the given connection |status|.
   static int GetConnectionIconID(PageInfo::SiteConnectionStatus status);
-#else  // !defined(OS_ANDROID)
   // Returns icons for the given PermissionInfo |info|. If |info|'s current
   // setting is CONTENT_SETTING_DEFAULT, it will return the icon for |info|'s
   // default setting.
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.h
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.h
@@ -92,7 +92,7 @@ class PasswordManagerPresenter
   // Undoes the last saved password or exception removal.
   void UndoRemoveSavedPasswordOrException();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Requests to reveal the plain text password corresponding to |sort_key|. If
   // |sort_key| is a valid key into |password_map_|, runs |callback| with the
   // corresponding value, or nullopt otherwise.
--- a/chrome/browser/ui/webui/omnibox/omnibox_ui.cc
+++ b/chrome/browser/ui/webui/omnibox/omnibox_ui.cc
@@ -19,7 +19,7 @@
 #include "content/public/browser/web_ui_controller.h"
 #include "content/public/browser/web_ui_data_source.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/webui/omnibox/omnibox_popup_handler.h"
 #endif
 
@@ -48,7 +48,7 @@ OmniboxUI::OmniboxUI(content::WebUI* web
       IDR_OMNIBOX_MOJO_JS);
   source->SetDefaultResource(IDR_OMNIBOX_HTML);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   if (base::FeatureList::IsEnabled(omnibox::kWebUIOmniboxPopup)) {
     source->AddResourcePath("omnibox_popup.js", IDR_OMNIBOX_POPUP_JS);
     source->AddResourcePath("omnibox_popup.html", IDR_OMNIBOX_POPUP_HTML);
--- a/chrome/browser/ui/webui/omnibox/omnibox_ui.h
+++ b/chrome/browser/ui/webui/omnibox/omnibox_ui.h
@@ -13,7 +13,7 @@
 
 class OmniboxPageHandler;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class OmniboxPopupHandler;
 #endif
 
@@ -27,7 +27,7 @@ class OmniboxUI : public ui::MojoWebUICo
   // interface passing the pending receiver that will be internally bound.
   void BindInterface(mojo::PendingReceiver<mojom::OmniboxPageHandler> receiver);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // This is needed for the Views native UI to call into the WebUI code.
   OmniboxPopupHandler* popup_handler() { return popup_handler_.get(); }
 #endif
@@ -35,7 +35,7 @@ class OmniboxUI : public ui::MojoWebUICo
  private:
   std::unique_ptr<OmniboxPageHandler> omnibox_handler_;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<OmniboxPopupHandler> popup_handler_;
 #endif
 
--- a/chrome/browser/ui/native_file_system_dialogs.cc
+++ b/chrome/browser/ui/native_file_system_dialogs.cc
@@ -6,7 +6,7 @@
 
 #include "components/permissions/permission_util.h"
 
-#if !defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS)
 void ShowNativeFileSystemPermissionDialog(
     const NativeFileSystemPermissionRequestManager::RequestData& request,
     base::OnceCallback<void(permissions::PermissionAction result)> callback,
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -208,11 +208,6 @@ const ui::ThemeProvider* BrowserFrame::G
 }
 
 const ui::NativeTheme* BrowserFrame::GetNativeTheme() const {
-  if (browser_view_->browser()->profile()->IsIncognitoProfile() &&
-      ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile())
-          ->UsingDefaultTheme()) {
-    return ui::NativeTheme::GetInstanceForDarkUI();
-  }
   return views::Widget::GetNativeTheme();
 }
 
--- a/chrome/browser/devtools/devtools_window.cc
+++ b/chrome/browser/devtools/devtools_window.cc
@@ -1479,7 +1479,6 @@ void DevToolsWindow::ShowCertificateView
   if (!FindInspectedBrowserAndTabIndex(inspected_contents, &browser, &tab))
     return;
   gfx::NativeWindow parent = browser->window()->GetNativeWindow();
-  ::ShowCertificateViewer(inspected_contents, parent, cert.get());
 }
 
 void DevToolsWindow::OnLoadCompleted() {
--- a/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
+++ b/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
@@ -1009,7 +1009,6 @@ void PageInfoBubbleView::HandleMoreInfoR
       if (certificate_ && top_window) {
         presenter_->RecordPageInfoAction(
             PageInfo::PAGE_INFO_CERTIFICATE_DIALOG_OPENED);
-        ShowCertificateViewer(web_contents(), top_window, certificate_.get());
       }
       break;
     }
--- a/chrome/browser/web_applications/components/web_app_file_handler_registration.cc
+++ b/chrome/browser/web_applications/components/web_app_file_handler_registration.cc
@@ -12,7 +12,7 @@ namespace web_app {
 // This block defines stub implementations of OS specific methods for
 // FileHandling. Currently, Windows, MacOSX and Desktop Linux (but not Chrome
 // OS) have their own implementations.
-#if defined(OS_CHROMEOS)
+#if defined(OS_ANDROID)
 bool ShouldRegisterFileHandlersWithOs() {
   return false;
 }
--- /dev/null
+++ b/chrome/browser/upgrade_detector/get_installed_version_android.cc
@@ -0,0 +1,33 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/upgrade_detector/get_installed_version.h"
+
+#include <string>
+#include <utility>
+
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "base/process/launch.h"
+#include "base/strings/string_util.h"
+#include "chrome/common/chrome_switches.h"
+
+// On Android, the Chrome binary may have been replaced by an update. Ask it to
+// report its version.
+InstalledAndCriticalVersion GetInstalledVersion() {
+  base::CommandLine command_line(*base::CommandLine::ForCurrentProcess());
+  command_line.AppendSwitch(switches::kProductVersion);
+  base::Version installed_version;
+  std::string reply;
+  if (base::GetAppOutput(command_line, &reply)) {
+    installed_version =
+        base::Version(base::TrimWhitespaceASCII(reply, base::TRIM_ALL));
+  }
+  // Failure may be a result of invoking a Chrome that predates the introduction
+  // of the --product-version switch in https://crrev.com/48795 (6.0.424.0).
+  DLOG_IF(ERROR, !installed_version.IsValid())
+      << "Failed to get current file version";
+
+  return InstalledAndCriticalVersion(std::move(installed_version));
+}
--- a/chrome/browser/extensions/api/developer_private/developer_private_api.cc
+++ b/chrome/browser/extensions/api/developer_private/developer_private_api.cc
@@ -1908,12 +1908,14 @@ ExtensionFunction::ResponseAction Develo
     return RespondNow(Error(kNoOptionsPageForExtensionError));
 
   content::WebContents* web_contents = GetSenderWebContents();
+
   if (!web_contents)
     return RespondNow(Error(kCouldNotFindWebContentsError));
 
   ExtensionTabUtil::OpenOptionsPage(
       extension,
-      chrome::FindBrowserWithWebContents(web_contents));
+      web_contents);
+
   return RespondNow(NoArguments());
 }
 
--- a/chrome/browser/extensions/extension_tab_util.cc
+++ b/chrome/browser/extensions/extension_tab_util.cc
@@ -864,30 +864,28 @@ bool ExtensionTabUtil::OpenOptionsPageFr
   // that's the only place it's running.
   DCHECK(!profile->IsOffTheRecord() || IncognitoInfo::IsSplitMode(extension));
   Browser* browser = chrome::FindBrowserWithProfile(profile);
+  LOG(ERROR) << "Cannot open new tab here";
   if (!browser)
     browser = Browser::Create(Browser::CreateParams(profile, true));
   if (!browser)
     return false;
-  return extensions::ExtensionTabUtil::OpenOptionsPage(extension, browser);
+  return false;
 }
 
 bool ExtensionTabUtil::OpenOptionsPage(const Extension* extension,
-                                       Browser* browser) {
+                                       content::WebContents* web_contents) {
   if (!OptionsPageInfo::HasOptionsPage(extension))
     return false;
 
+  LOG(WARNING) << "extension_tab_util.cc: OpenOptionsPage() entry";
+
   // Force the options page to open in non-OTR window if the extension is not
   // running in split mode, because it won't be able to save settings from OTR.
   // This version of OpenOptionsPage() can be called from an OTR window via e.g.
   // the action menu, since that's not initiated by the extension.
-  std::unique_ptr<chrome::ScopedTabbedBrowserDisplayer> displayer;
-  if (browser->profile()->IsOffTheRecord() &&
-      !IncognitoInfo::IsSplitMode(extension)) {
-    displayer.reset(new chrome::ScopedTabbedBrowserDisplayer(
-        browser->profile()->GetOriginalProfile()));
-    browser = displayer->browser();
-  }
 
+  // Instead open in native browser, open a new tab through JNI bridge
+  // Incognito Mode not handled yet
   GURL url_to_navigate;
   bool open_in_tab = OptionsPageInfo::ShouldOpenInTab(extension);
   if (open_in_tab) {
@@ -904,17 +902,14 @@ bool ExtensionTabUtil::OpenOptionsPage(c
     url_to_navigate = url_to_navigate.ReplaceComponents(replacements);
   }
 
-  NavigateParams params(
-      GetSingletonTabNavigateParams(browser, url_to_navigate));
-  // We need to respect path differences because we don't want opening the
-  // options page to close a page that might be open to extension content.
-  // However, if the options page opens inside the chrome://extensions page, we
-  // can override an existing page.
-  // Note: ref behavior is to ignore.
-  params.path_behavior = open_in_tab ? NavigateParams::RESPECT
-                                     : NavigateParams::IGNORE_AND_NAVIGATE;
-  params.url = url_to_navigate;
-  ShowSingletonTabOverwritingNTP(browser, std::move(params));
+  web_contents->OpenURL(
+      content::OpenURLParams(
+          url_to_navigate, content::Referrer(),
+          WindowOpenDisposition::NEW_FOREGROUND_TAB,
+          ui::PAGE_TRANSITION_LINK, false
+    ));
+
+  LOG(WARNING) << "extension_tab_util.cc: return";
   return true;
 }
 
--- a/chrome/browser/extensions/extension_tab_util.h
+++ b/chrome/browser/extensions/extension_tab_util.h
@@ -236,7 +236,7 @@ class ExtensionTabUtil {
   // Open the extension's options page. Returns true if an options page was
   // successfully opened (though it may not necessarily *load*, e.g. if the
   // URL does not exist).
-  static bool OpenOptionsPage(const Extension* extension, Browser* browser);
+  static bool OpenOptionsPage(const Extension* extension, content::WebContents* web_contents);
 
   // Returns true if the given Browser can report tabs to extensions.
   // Example of Browsers which don't support tabs include apps and devtools.
--- a/chrome/browser/extensions/extension_context_menu_model.cc
+++ b/chrome/browser/extensions/extension_context_menu_model.cc
@@ -327,7 +327,7 @@ void ExtensionContextMenuModel::ExecuteC
     }
     case OPTIONS:
       DCHECK(OptionsPageInfo::HasOptionsPage(extension));
-      ExtensionTabUtil::OpenOptionsPage(extension, browser_);
+      ExtensionTabUtil::OpenOptionsPage(extension, GetActiveWebContents());
       break;
     case TOGGLE_VISIBILITY: {
       bool currently_visible = button_visibility_ == VISIBLE;
--- a/chrome/browser/ui/webui/settings/people_handler.cc
+++ b/chrome/browser/ui/webui/settings/people_handler.cc
@@ -711,7 +711,6 @@ void PeopleHandler::HandleSignout(const
 }
 
 void PeopleHandler::HandlePauseSync(const base::ListValue* args) {
-  DCHECK(AccountConsistencyModeManager::IsDiceEnabledForProfile(profile_));
   auto* identity_manager = IdentityManagerFactory::GetForProfile(profile_);
   DCHECK(identity_manager->HasPrimaryAccount());
 
